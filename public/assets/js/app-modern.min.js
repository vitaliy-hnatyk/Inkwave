/* Copyright - Plasfy - All Rights Reserved
 * You CANNOT reproduce, distribute, or create derivative works
 * Proprietary Code Is Copyright Protected
 * https://plasfy.com
*/

//<![CDATA[
function nocontext(e) {
    var clickedTag = (e == null) ? event.srcElement.tagName : e.target.tagName;
    if (clickedTag == "IMG") {
        return false;
    }
}

document.oncontextmenu = nocontext;

//]]>

function imgError(image) {
    image.onerror = "";
    image.src = "https://assets.plasfy.com/img-error.svg";
    return true;
}

function switchText() {
    let obj1 = document.getElementById("product-width");
    let obj2 = document.getElementById("product-height");

    let temp = obj1.value;
    obj1.value = obj2.value;
    obj2.value = temp;
}

const NON_NBD_GALLERY_TYPES = ['overlay-test', 'emojis', 'iconfinder', 'aiavatars', 'url', 'upload'];

const DUPLICATED_PHOTOS_TABS = [
    'Pixabay',
    'Pexels',
    'Unsplash'
];

const GRADIENT_AWARE_SHAPES = [
    'rect',
    'triangle',
    'line',
    'polygon',
    'circle',
    'group',
    'ellipse',
    'path'
];

const GRADIENT_AWARE_TEXT = [
    'textbox',
    'i-text',
    'text',
    'textbox',
    'curvedText'
];

const GRADIENT_AWARE_TYPES = [
    ...GRADIENT_AWARE_SHAPES,
    ...GRADIENT_AWARE_TEXT
];
const SUPER_ROLE_NAME = "professional";

var appConfig = {
    localMode: false,
    debugMode: false,
    isModern: true,
    isVisual: false,
    isCuz: false,
    ready: false,
    domainChanged: false,
    init: function () {
        this.mediaUrl = this.localMode ? 'http://localhost/nbmedia/v1' : 'https://studio.cmsmart.net/v1';
        this.domainChanged = NBDESIGNCONFIG.nbdesigner_fix_domain_changed == 'yes' ? true : false;
        this.isModern = NBDESIGNCONFIG.layout == 'modern' ? true : false;
        this.isVisual = NBDESIGNCONFIG.layout == 'visual' ? true : false;
    },
    autoSave: NBDESIGNCONFIG.nbdesigner_auto_save_draft == 'yes' ? true : false,
    loadAllDesign: NBDESIGNCONFIG.nbdesigner_enable_load_all_design == 'yes' ? true : false
};
/*advanced*/
if (typeof udc_nbd_js_config != 'undefined') {
    Object.assign(appConfig, {allowDynamicQty: true});
}

const SNAP_TIMER = 100;

function arrayMin(arr) {
    return arr.reduce(function (p, v) {
        p *= 1;
        v *= 1;
        return (p < v ? p : v);
    });
};

function arrayMax(arr) {
    return arr.reduce(function (p, v) {
        p *= 1;
        v *= 1;
        return (p > v ? p : v);
    });
};

var img = document.createElement('img');
img.src = '/assets/images/middlecontrol.svg';

var img2 = document.createElement('img');
img2.src = '/assets/images/middlecontrolhoz.svg';

var img3 = document.createElement('img');
img3.src = '/assets/images/edgecontrol.svg';

var img4 = document.createElement('img');
img4.src = '/assets/images/rotateicon.svg';

function isMobile() {
    return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|Silk/i.test(navigator.userAgent);
}

function getCornerSize() {
    return isMobile() ? 35 : 25; // px
}

fabric.Object.prototype._drawControl = function (control, ctx, methodName, left, top, size) {
    const wsize = getCornerSize();
    const hsize = getCornerSize();

    // Save the canvas context before applying transformations
    ctx.save();

    // Translate the context to the control's position (left, top)
    ctx.translate(left, top);

    // Apply the rotation for the object but not double-rotate the controls
    // Remove the angle adjustment as it's already handled in the positioning
    switch (control) {
        case 'tl':
        case 'tr':
        case 'bl':
        case 'br':
            ctx.drawImage(img3, -wsize / 4, -hsize / 4, wsize, hsize);
            break;
        case 'ml':
        case 'mr':
            ctx.drawImage(img, -wsize / 4, -hsize / 4, wsize, hsize);
            break;
        case 'mt':
        case 'mb':
            ctx.drawImage(img2, -wsize / 4, -hsize / 4, wsize, hsize);
            break;
        case 'mtr':
            ctx.drawImage(img4, -wsize / 2, -hsize / 2, 40, 40);
            break;
    }

    // Restore the canvas context to its original state
    ctx.restore();
};

fabric.Textbox.prototype._drawControl = function (control, ctx, methodName, left, top, size) {
    const wsize = getCornerSize();
    const hsize = getCornerSize();

    // Save the canvas context before applying transformations
    ctx.save();

    // Translate the context to the control's position (left, top)
    ctx.translate(left, top);

    // Apply the rotation for the object but not double-rotate the controls
    // Remove the angle adjustment as it's already handled in the positioning
    switch (control) {
        case 'tl':
        case 'tr':
        case 'bl':
        case 'br':
            ctx.drawImage(img3, -wsize / 4, -hsize / 4, wsize, hsize);
            break;
        case 'ml':
        case 'mr':
            ctx.drawImage(img, -wsize / 4, -hsize / 4, wsize, hsize);
            break;
        case 'mt':
        case 'mb':
            break;
        case 'mtr':
            ctx.drawImage(img4, -wsize / 2, -hsize / 2, 40, 40);
            break;
    }

    // Restore the canvas context to its original state
    ctx.restore();
};

/*fabric.Object.prototype._drawControl = function(control, ctx, methodName, left, top) {
    if (!this.isControlVisible(control)) {
        return;
    }
    var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
    switch (this.cornerStyle) {
        case 'circle':
            ctx.beginPath();
            ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
            ctx[methodName]();
            if (stroke) {
                ctx.stroke();
            }
            break;
        default:
            this.transparentCorners || ctx.clearRect(left, top, size, size);
            ctx[methodName + 'Rect'](left, top, size, size);
            if (stroke) {
                ctx.strokeRect(left, top, size, size);
            }
    }
    if( control == 'mtr' ){
        var rotateControlIcon = new Image;
        rotateControlIcon.src = "data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3E%3Cpath%20fill='currentColor'%20d='M15.25%2018.48V15a.75.75%200%201%200-1.5%200v4c0%20.97.78%201.75%201.75%201.75h4a.75.75%200%201%200%200-1.5h-2.6a8.75%208.75%200%200%200-2.07-15.53.75.75%200%201%200-.49%201.42%207.25%207.25%200%200%201%20.91%2013.34zM8.75%205.52V9a.75.75%200%200%200%201.5%200V5c0-.97-.78-1.75-1.75-1.75h-4a.75.75%200%200%200%200%201.5h2.6a8.75%208.75%200%200%200%202.18%2015.57.75.75%200%200%200%20.47-1.43%207.25%207.25%200%200%201-1-13.37z'/%3E%3C/svg%3E";
        try {
            ctx.drawImage(rotateControlIcon, left+1, top+1, size-2, size-2);
        } catch (e) {
            //ctx[methodName](left, top, size, size);
        }
    }
};*/
qrcode.stringToBytes = qrcode.stringToBytesFuncs['UTF-8'];
var photoFrames = [
    {"areas": "\"a\"", "rows": "", "columns": ""}, {
    "areas": "\"a b\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a\" \"b\"", "rows": "", "columns": ""}, {
    "areas": "\"a\" \"b\"",
    "rows": "2fr 1fr",
    "columns": ""
}, {"areas": "\"a\"", "rows": "", "columns": ""}, {
    "areas": "\"a b\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a\" \"b\"", "rows": "", "columns": ""}, {
    "areas": "\"a\" \"b\"",
    "rows": "2fr 1fr",
    "columns": ""
}, {"areas": "\"b\" \"a\"", "rows": "1fr 2fr", "columns": ""}, {
    "areas": "\"a b\"",
    "rows": "",
    "columns": "2fr 1fr"
}, {"areas": "\"b a\"", "rows": "", "columns": "1fr 2fr"}, {
    "areas": "\"a b c\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a\" \"b\" \"c\"", "rows": "", "columns": ""}, {
    "areas": "\"a b\" \"c c\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a a\" \"b c\"", "rows": "", "columns": ""}, {
    "areas": "\"a b\" \"a c\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a c\" \"b c\"", "rows": "", "columns": ""}, {
    "areas": "\"a a\" \"b c\"",
    "rows": "2fr 1fr",
    "columns": ""
}, {"areas": "\"b c\" \"a a\"", "rows": "1fr 2fr", "columns": ""}, {
    "areas": "\"a b\" \"a c\"",
    "rows": "",
    "columns": "2fr 1fr"
}, {"areas": "\"b a\" \"c a\"", "rows": "", "columns": "1fr 2fr"}, {
    "areas": "\"a a\" \"b c\"",
    "rows": "2fr 1fr",
    "columns": "1fr 2fr"
}, {"areas": "\"a b\" \"a c\"", "rows": "1fr 2fr", "columns": "2fr 1fr"}, {
    "areas": "\"a b\" \"c c\"",
    "rows": "2fr 1fr",
    "columns": "1fr 2fr"
}, {"areas": "\"a a\" \"b c\"", "rows": "1fr 2fr", "columns": "1fr 2fr"}, {
    "areas": "\"a b\" \"a c\"",
    "rows": "1fr 2fr",
    "columns": "1fr 2fr"
}, {"areas": "\"a b\" \"c b\"", "rows": "1fr 2fr", "columns": "2fr 1fr"}, {
    "areas": "\"a b\" \"a c\"",
    "rows": "",
    "columns": "1fr 2fr"
}, {"areas": "\"a b\" \"c b\"", "rows": "", "columns": "2fr 1fr"}, {
    "areas": "\"a a\" \"b c\"",
    "rows": "",
    "columns": "7fr 5fr"
}, {"areas": "\"a b\" \"c c\"", "rows": "2fr 1fr", "columns": "2fr 1fr"}, {
    "areas": "\"a b\" \"a c\"",
    "rows": "2fr 1fr",
    "columns": "2fr 1fr"
}, {"areas": "\"a b c d\"", "rows": "", "columns": ""}, {
    "areas": "\"a\" \"b\" \"c\" \"d\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b\" \"c d\"", "rows": "", "columns": ""}, {
    "areas": "\"a a a\" \"b c d\"",
    "rows": "2fr 1fr",
    "columns": ""
}, {"areas": "\"a b c\" \"d d d\"", "rows": "1fr 2fr", "columns": ""}, {
    "areas": "\"a b\" \"a c\" \"a d\"",
    "rows": "",
    "columns": "2fr 1fr"
}, {"areas": "\"a d\" \"b d\" \"c d\"", "rows": "", "columns": "1fr 2fr"}, {
    "areas": "\"a b\" \"c d\"",
    "rows": "",
    "columns": "1fr 2fr"
}, {"areas": "\"a b\" \"c d\"", "rows": "", "columns": "2fr 1fr"}, {
    "areas": "\"a b\" \"c d\"",
    "rows": "2fr 1fr",
    "columns": "1fr 2fr"
}, {"areas": "\"a a\" \"b d\" \"c d\"", "rows": "2fr 1fr 1fr", "columns": "1fr 2fr"}, {
    "areas": "\"a a b\" \"c d d\"",
    "rows": "1fr 2fr",
    "columns": ""
}, {"areas": "\"a b b\" \"c c d\"", "rows": "2fr 1fr", "columns": "2fr 1fr 3fr"}, {
    "areas": "\"a b c\" \"a d d\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a a b\" \"c d d\"", "rows": "2fr 1fr", "columns": ""}, {
    "areas": "\"a b\" \"c b\" \"c d\"",
    "rows": "2fr 1fr 3fr",
    "columns": "2fr 1fr"
}, {"areas": "\"a a\" \"b c\" \"b d\"", "rows": "3fr 2fr 2fr", "columns": ""}, {
    "areas": "\"a b\" \"a d\" \"c d\"",
    "rows": "",
    "columns": "2fr 1fr"
}, {"areas": "\"a b c d e\"", "rows": "", "columns": ""}, {
    "areas": "\"a\" \"b\" \"c\" \"d\" \"e\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a a\" \"b c\" \"d e\"", "rows": "", "columns": ""}, {
    "areas": "\"a b\" \"c d\" \"e e\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b d\" \"a c e\"", "rows": "", "columns": ""}, {
    "areas": "\"a b e\" \"c d e\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a a a a\" \"b c d e\"", "rows": "", "columns": ""}, {
    "areas": "\"a b c d\" \"e e e e\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b\" \"a c\" \"a d\" \"a e\"", "rows": "", "columns": ""}, {
    "areas": "\"a e\" \"b e\" \"c e\" \"d e\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a c d\" \"b c e\"", "rows": "", "columns": "1fr 2fr 1fr"}, {
    "areas": "\"a a a\" \"b c e\" \"d d e\"",
    "rows": "2fr 1fr 2fr",
    "columns": "1fr 1fr 3fr"
}, {"areas": "\"a a b\" \"c e e\" \"d e e\"", "rows": "", "columns": ""}, {
    "areas": "\"a a b\" \"a a c\" \"e d c\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a c c\" \"b c c\" \"d d e\"",
    "rows": "1fr 1fr 2fr",
    "columns": "1fr 1fr 2fr"
}, {
    "areas": "\"a e e\" \"b e e\" \"c c d\"",
    "rows": "",
    "columns": "1fr 1fr 2fr"
}, {
    "areas": "\"a a a\" \"b c e\" \"b d e\"",
    "rows": "3fr 1fr 1fr",
    "columns": "2fr 1fr 2fr"
}, {"areas": "\"a a b\" \"d c b\" \"d e e\"", "rows": "", "columns": ""}, {
    "areas": "\"a b c\" \"a d c\" \"e e e\"",
    "rows": "",
    "columns": "3fr 5fr 3fr"
}, {"areas": "\"a c c\" \"a d e\" \"b d e\"", "rows": "", "columns": ""}, {
    "areas": "\"a c d\" \"b c e\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a a b b\" \"c d d e\"", "rows": "", "columns": "2fr 1fr 1fr 2fr"}, {
    "areas": "\"a b\" \"c c\" \"d e\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a a a a\" \"b c d e\"", "rows": "3fr 1fr", "columns": ""}, {
    "areas": "\"a b c d e f\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a\" \"b\" \"c\" \"d\" \"e\" \"f\"", "rows": "", "columns": ""}, {
    "areas": "\"a b c\" \"d e f\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b\" \"c d\" \"e f\"", "rows": "", "columns": ""}, {
    "areas": "\"a a a a a\" \"b c d e f\"",
    "rows": "2fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f f f f f\"",
    "rows": "1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a b\" \"a c\" \"a d\" \"a e\" \"a f\"",
    "rows": "",
    "columns": "2fr 1fr"
}, {
    "areas": "\"a f\" \"b f\" \"c f\" \"d f\" \"e f\"",
    "rows": "",
    "columns": "1fr 2fr"
}, {"areas": "\"a a b b\" \"c d e f\"", "rows": "2fr 1fr", "columns": ""}, {
    "areas": "\"a b c d\" \"e e f f\"",
    "rows": "1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a c\" \"a d\" \"b e\" \"b f\"",
    "rows": "",
    "columns": "2fr 1fr"
}, {
    "areas": "\"a e\" \"b e\" \"c f\" \"d f\"",
    "rows": "",
    "columns": "1fr 2fr"
}, {"areas": "\"a b b\" \"c b b\" \"d e f\"", "rows": "", "columns": ""}, {
    "areas": "\"a a e\" \"a a f\" \"b c d\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b c\" \"d d e\" \"d d f\"", "rows": "", "columns": ""}, {
    "areas": "\"a b c\" \"d f f\" \"e f f\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b c\" \"d b f\" \"d e f\"", "rows": "", "columns": ""}, {
    "areas": "\"a a b\" \"c d d\" \"e e f\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"c d d f\" \"c e e f\"",
    "rows": "4fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a e\" \"b c e\" \"b c f\" \"d d f\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": "1fr 1fr 2fr"
}, {
    "areas": "\"a a b\" \"c d b\" \"c d e\" \"f f e\"",
    "rows": "",
    "columns": "1fr 1fr 2fr"
}, {"areas": "\"a a c\" \"b b c\" \"d e f\"", "rows": "", "columns": ""}, {
    "areas": "\"a b c\" \"a d e\" \"f f f\"",
    "rows": "1fr 1fr 4fr",
    "columns": "4fr 1fr 1fr"
}, {
    "areas": "\"a a b c\" \"a a d d\" \"f e d d\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b\" \"c d e\" \"c f f\"",
    "rows": "2fr 1fr 1fr",
    "columns": "2fr 1fr 1fr"
}, {
    "areas": "\"a a a a\" \"b b c c\" \"d e e f\"",
    "rows": "2fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a b\" \"c d b\" \"e f b\"",
    "rows": "2fr 1fr 1fr",
    "columns": "1fr 1fr 2fr"
}, {
    "areas": "\"a a b\" \"a a c\" \"f e d\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a\" \"b c d e\" \"f f d e\"",
    "rows": "2fr 1fr 1fr",
    "columns": "1fr 1fr 2fr 2fr"
}, {
    "areas": "\"a a b\" \"a a c\" \"d e e\" \"f e e\"",
    "rows": "",
    "columns": "1fr 2fr 1fr"
}, {"areas": "\"a b c d e f g\"", "rows": "", "columns": ""}, {
    "areas": "\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b c c\" \"d e e f f g\"",
    "rows": "",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a b b c c d\" \"e e f f g g\"",
    "rows": "",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a a a a a a\" \"b c d e f g\"",
    "rows": "3fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g g g g g g\"",
    "rows": "1fr 3fr",
    "columns": ""
}, {
    "areas": "\"a a a\" \"b c d\" \"e f g\"",
    "rows": "3fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e f\" \"g g g\"",
    "rows": "1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"b a e\" \"c a f\" \"d a g\"",
    "rows": "",
    "columns": "1fr 2fr 1fr"
}, {
    "areas": "\"b c d\" \"a a a\" \"e f g\"",
    "rows": "1fr 2fr 1fr",
    "columns": ""
}, {"areas": "\"a a b\" \"c d b\" \"e f g\"", "rows": "", "columns": ""}, {
    "areas": "\"a b f\" \"c c g\" \"d e g\"",
    "rows": "2fr 1fr 2fr",
    "columns": "1fr 1fr 2fr"
}, {
    "areas": "\"a a b c\" \"d e f c\" \"g g g g\"",
    "rows": "1fr 1fr 3fr",
    "columns": ""
}, {
    "areas": "\"a c c\" \"b c c\" \"d d e\" \"d d f\" \"g g g\"",
    "rows": "1fr 1fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a b b\" \"c d e\" \"c f g\"",
    "rows": "2fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b b c\" \"d b b e\" \"f f g g\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b\" \"a c d\" \"a e e\" \"a f g\"",
    "rows": "",
    "columns": "2fr 1fr 1fr"
}, {
    "areas": "\"a b b\" \"c d e\" \"c f g\"",
    "rows": "2fr 1fr 1fr",
    "columns": "2fr 1fr 1fr"
}, {
    "areas": "\"a b c d e f g h\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b c d\" \"e f g h\"", "rows": "", "columns": ""}, {
    "areas": "\"a b\" \"c d\" \"e f\" \"g h\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b c d\" \"e f g h\"", "rows": "1fr 3fr", "columns": ""}, {
    "areas": "\"a b c d\" \"e f g h\"",
    "rows": "3fr 1fr",
    "columns": ""
}, {
    "areas": "\"a e\" \"b f\" \"c g\" \"d h\"",
    "rows": "",
    "columns": "3fr 1fr"
}, {
    "areas": "\"a b\" \"c d\" \"e f\" \"g h\"",
    "rows": "",
    "columns": "1fr 3fr"
}, {
    "areas": "\"a c e g\" \"a d e h\" \"b d f h\"",
    "rows": "1fr 2fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b\" \"c d d\" \"e e f\" \"g h h\"",
    "rows": "",
    "columns": "1fr 2fr 1fr"
}, {
    "areas": "\"a a b b\" \"c d e f\" \"g g h h\"",
    "rows": "1fr 2fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"c c d d\" \"e f g h\"",
    "rows": "1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a a b b c c\" \"d e e f f g\" \"h h h h h h\"",
    "rows": "1fr 2fr 1fr",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a b b c\" \"d d e e\" \"f g g h\"",
    "rows": "1fr 2fr 1fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a d d\" \"b c d d\" \"e e f g\" \"e e h h\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b\" \"c d e\" \"c d f\" \"g g h\"",
    "rows": "",
    "columns": "1fr 1fr 2fr"
}, {
    "areas": "\"a b b c\" \"d d e e\" \"f g g h\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a b b\" \"a a c c\" \"d e c c\" \"d e f f\" \"h h f f\" \"h h g g\"",
    "rows": "3fr 1fr 2fr 2fr 1fr 3fr",
    "columns": ""
}, {
    "areas": "\"a a a a\" \"b c d d\" \"e e f g\" \"h h h h\"",
    "rows": "3fr 2fr 2fr 3fr",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"c c b b\" \"d e h i\" \"f g h i\"",
    "rows": "2fr 2fr 1fr 1fr",
    "columns": "1fr 1fr 2fr 2fr"
}, {
    "areas": "\"a a b b\" \"c d d e\" \"f f g g\" \"h h h h\"",
    "rows": "1fr 1fr 1fr 2fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c\" \"d d d\" \"e f g\" \"h h h\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a d f\" \"b d g\" \"b e g\" \"c e h\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": "1fr 2fr 1fr"
}, {
    "areas": "\"a b b c\" \"d d e e\" \"f g g h\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a d d\" \"b d d\" \"c e f\" \"c g h\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a\" \"b b b b\" \"c d f g\" \"c e f h\"",
    "rows": "2fr 2fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a d f\" \"b d g\" \"b e g\" \"c e h\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\"",
    "rows": "",
    "columns": ""
}, {"areas": "\"a b c\" \"d e f\" \"g h i\"", "rows": "", "columns": ""}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\"",
    "rows": "",
    "columns": "2fr 3fr 2fr"
}, {
    "areas": "\"a a b b\" \"c d d e\" \"f g h i\"",
    "rows": "1fr 3fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a a a\" \"b c c d\" \"e e f f\" \"g h h i\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c c\" \"d d e f\" \"g h i i\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b d\" \"a a c d\" \"e f g d\" \"h h h i\"",
    "rows": "1fr 1fr 1fr 3fr",
    "columns": "1fr 1fr 1fr 3fr"
}, {
    "areas": "\"a b b c\" \"d d e e\" \"f g g h\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c\" \"d b e\" \"f g h\" \"f i h\"",
    "rows": "2fr 2fr 1fr 1fr",
    "columns": "2fr 3fr 2fr"
}, {
    "areas": "\"a b b\" \"c b b\" \"d d e\" \"d d f\" \"g h h\" \"i h h\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e e e e\" \"f g h i\"",
    "rows": "1fr 3fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i h h f\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c\" \"d b e\" \"f b g\" \"h b i\"",
    "rows": "",
    "columns": "1fr 2fr 1fr"
}, {
    "areas": "\"a a b b\" \"c c d d\" \"e f f g\" \"h f f i\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d d e\" \"d d f\" \"g h i\"",
    "rows": "",
    "columns": "1fr 1fr 2fr"
}, {
    "areas": "\"a a a b\" \"a a a c\" \"d e e c\" \"f g i i\" \"f h i i\"",
    "rows": "2fr 1fr 1fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i i i i\"",
    "rows": "1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a b c\" \"a d e\" \"a f g\" \"a h i\"",
    "rows": "",
    "columns": "2fr 1fr 1fr"
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\"",
    "rows": "2fr 1fr 1fr",
    "columns": "2fr 1fr 1fr"
}, {
    "areas": "\"a a b d d\" \"a a c d d\" \"e f f f g\" \"h f f f i\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"c f f g\" \"d f f h\" \"e f f i\"",
    "rows": "3fr 1fr 1fr 1fr",
    "columns": "1fr 2fr 2fr 1fr"
}, {
    "areas": "\"a d g\" \"b d h\" \"c e i\" \"c f i\"",
    "rows": "3fr 1fr 1fr 3fr",
    "columns": ""
}, {
    "areas": "\"a d g\" \"b d h\" \"b e h\" \"c f i\"",
    "rows": "1fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a a\" \"b c d e f\" \"g h i j k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b\" \"c d\" \"e f\" \"g h\" \"i j\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a\" \"b c d\" \"e f g\" \"h i j\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"a e f g\" \"a h i j\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 1fr"
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\" \"j j j\"",
    "rows": "1fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a b c j\" \"d e f j\" \"g h i j\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a b c\" \"a a d e\" \"f g j j\" \"h i j j\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e e f f\" \"g h i j\"",
    "rows": "1fr 2fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b b c\" \"d e e f\" \"g h i j\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e g\" \"d f g\" \"h i j\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a b e f\" \"c d e f\" \"g h i i\" \"g h j j\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"a b c e\" \"a b c f\" \"g g g j\" \"h h h j\" \"i i i j\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 3fr"
}, {
    "areas": "\"a a b c\" \"a a d e\" \"f g j j\" \"h i j j\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c\" \"d e b j\" \"f g i j\" \"h h i j\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": "1fr 1fr 2fr 2fr"
}, {
    "areas": "\"a b b b\" \"c d e h\" \"c f g h\" \"i i i j\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i h h j\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a a j\" \"b b b j\" \"c c c j\" \"d e f j\" \"g h i j\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a a b b b\" \"c d e f g h\" \"i i i j j j\"",
    "rows": "3fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a a a a b\" \"a a a a c\" \"a a a a d\" \"a a a a e\" \"j i h g f\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"c d d e\" \"f f f f\" \"g h h i\" \"j j k k\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a c d e\" \"a f g h\" \"b f g h\" \"b i j k\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": "2fr 1fr 1fr 1fr"
}, {
    "areas": "\"a b c d\" \"e f g d\" \"e f g k\" \"h i j k\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b k\" \"c d k\" \"e f k\" \"g h k\" \"i j k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"a d e\" \"a f g\" \"a h i\" \"a j k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k k k k k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a a\" \"b c d e f\" \"g h i j k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f f f f f\" \"g h i j k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a f g\" \"b f h\" \"c f i\" \"d f j\" \"e f k\"",
    "rows": "",
    "columns": "4fr 7fr 4fr"
}, {
    "areas": "\"a a b b b\" \"c d e f g\" \"h h h i i\" \"j j k k k\"",
    "rows": "4fr 3fr 4fr 4fr",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f f f f e\" \"f f f f g\" \"h i j k g\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"a a c d\" \"e e f f\" \"g h f f\" \"i i j j\" \"i i k k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b\" \"a a a c\" \"d e f g\" \"h i j k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b e e e\" \"c d e e e\" \"f f f g h\" \"f f f i j\" \"k k k k k\"",
    "rows": "1fr 1fr 1fr 1fr 2fr",
    "columns": "1fr 1fr 2fr 1fr 1fr"
}, {
    "areas": "\"a a a a\" \"b c d k\" \"e f g k\" \"h i j k\"",
    "rows": "3fr 1fr 1fr 1fr",
    "columns": "1fr 1fr 1fr 3fr"
}, {
    "areas": "\"a f g\" \"b f h\" \"c f i\" \"d f j\" \"e f k\"",
    "rows": "",
    "columns": "1fr 3fr 1fr"
}, {
    "areas": "\"a b c d e\" \"f f f f f\" \"g h i j k\"",
    "rows": "1fr 3fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b b d\" \"a c c d\" \"e f g k\" \"e h h k\" \"e i j k\"",
    "rows": "3fr 3fr 2fr 2fr 2fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c d\" \"e f f g\" \"h i j k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b\" \"a a c\" \"a a d\" \"e h h\" \"f h h\" \"g h h\"",
    "rows": "",
    "columns": "1fr 3fr 1fr"
}, {
    "areas": "\"a a g i\" \"b c g j\" \"d e h j\" \"f f h k\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": "1fr 1fr 2fr 2fr"
}, {
    "areas": "\"a a b c\" \"d e e f\" \"g e e f\" \"g h h f\" \"i j j k\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a b c c\" \"d e e e f\" \"g e e e h\" \"i i j k k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c d\" \"a a e e e\" \"f g e e e\" \"h h i i j\" \"h h i i k\"",
    "rows": "1fr 2fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b\" \"c d\" \"e f\" \"g h\" \"i j\" \"k l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\" \"j k l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"a a c d\" \"a a e f\" \"g h l l\" \"i j l l\" \"k k l l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"a a c d\" \"e e f f\" \"g h f f\" \"i i j j\" \"i i k l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b\" \"c d d\" \"e e f\" \"g h h\" \"i i j\" \"k l l\"",
    "rows": "",
    "columns": "2fr 1fr 2fr"
}, {
    "areas": "\"a b c c\" \"d d e f\" \"g h i i\" \"j j k l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c c\" \"d b e f\" \"g h i j\" \"k k l l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b\" \"a a a c\" \"d e f g\" \"h i j j\" \"k l j j\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a c d f\" \"b c e f\" \"g h j k\" \"g i j l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k l\"",
    "rows": "1fr 2fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"c d d e\" \"f f g g\" \"h i i j\" \"k k l l\"",
    "rows": "1fr 1fr 2fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a c c d\" \"b c c d\" \"e f g h\" \"i j j k\" \"i j j l\"",
    "rows": "1fr 1fr 2fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a a b\" \"c d e l\" \"f g h l\" \"i j k l\"",
    "rows": "3fr 1fr 1fr 1fr",
    "columns": "1fr 1fr 1fr 3fr"
}, {
    "areas": "\"a b c d\" \"a e e d\" \"f g g h\" \"f i j h\"",
    "rows": "1fr 2fr 2fr 1fr",
    "columns": "1fr 2fr 2fr 1fr"
}, {
    "areas": "\"a a a a a a\" \"b c c d d e\" \"f f g g h h\" \"i j j k k l\"",
    "rows": "3fr 1fr 1fr 1fr",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a a b c d\" \"e f f g g\" \"h f f g g\" \"h i i g g\" \"j k k l l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c\" \"d e f g\" \"h i j g\" \"h k k m\" \"l k k m\"",
    "rows": "2fr 1fr 1fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b b c\" \"d e f g\" \"d h i g\" \"j k k l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b d\" \"a a c d\" \"e f h h\" \"e g h h\" \"i i j l\" \"i i k l\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c d\" \"l l l e\" \"l l l f\" \"l l l g\" \"k j i h\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e e c f\" \"e e c g\" \"h i l l\" \"h j l l\" \"h k l l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b b\" \"a a a c d\" \"a a a e f\" \"g h i l l\" \"g j k l l\"",
    "rows": "2fr 1fr 1fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 1fr 1fr"
}, {
    "areas": "\"a a a a a a\" \"b c d e f g\" \"h i j k l m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g g g g g g\" \"h i j k l m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m m m m m m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b h\" \"a c i\" \"a d j\" \"a e k\" \"a f l\" \"a g m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a g h\" \"b g i\" \"c g j\" \"d g k\" \"e g l\" \"f g m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b m\" \"c d m\" \"e f m\" \"g h m\" \"i j m\" \"k l m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a a a\" \"b c d e f g\" \"h i j k l m\"",
    "rows": "3fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"a e f g\" \"a h i j\" \"a k l m\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 1fr"
}, {
    "areas": "\"a b c\" \"d e f\" \"g g g\" \"h i j\" \"k l m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e e f f\" \"g g g g\" \"h h i i\" \"j k l m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g g g h\" \"i j k l m\"",
    "rows": "1fr 3fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f f g h h\" \"i j k l m\"",
    "rows": "1fr 2fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b c d\" \"e f g h h\" \"i i i j k\" \"i i i l m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a l\" \"b b b l\" \"c d e l\" \"f g h m\" \"i j k m\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c d d\" \"e f c d d\" \"g g h i j\" \"g g h k l\" \"m m m m m\"",
    "rows": "1fr 1fr 1fr 1fr 2fr",
    "columns": "1fr 1fr 2fr 1fr 1fr"
}, {
    "areas": "\"a b c d\" \"e f f g\" \"h f f i\" \"j k l m\"",
    "rows": "1fr 2fr 2fr 1fr",
    "columns": "1fr 2fr 2fr 1fr"
}, {
    "areas": "\"a b c d\" \"e f f g\" \"h f f i\" \"j k l m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c\" \"d e f g\" \"h i j j\" \"k k l m\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f f g\" \"h f f g\" \"i j j j\" \"k l l m\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a d f i k\" \"b d g i l\" \"b e g j l\" \"c e h j m\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a a a b c d\" \"a a a b e f\" \"a a a m m m\" \"g h i m m m\" \"g j k m m m\" \"l l l m m m\"",
    "rows": "1fr 1fr 2fr 1fr 1fr 2fr",
    "columns": "2fr 1fr 1fr 2fr 1fr 1fr"
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b\" \"c d\" \"e f\" \"g h\" \"i j\" \"k l\" \"m n\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c\" \"a a d e\" \"a a f g\" \"h i n n\" \"j k n n\" \"l m n n\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"c d e f\" \"g h i j\" \"k l m n\"",
    "rows": "3fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b b c c\" \"d e e f f g\" \"h h i i j j\" \"k l l m m n\"",
    "rows": "",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a a b b c c\" \"d e e f f g\" \"h i i j j k\" \"l l m m n n\"",
    "rows": "",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a a b c c d\" \"e e e f f f\" \"g h h i j j\" \"k k l m m n\"",
    "rows": "",
    "columns": "3fr 1fr 3fr 3fr 1fr 3fr"
}, {
    "areas": "\"a b c d\" \"e e f f\" \"g h i j\" \"k l m n\"",
    "rows": "1fr 2fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b b\" \"c d e f\" \"g h i j\" \"k l m n\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b c d\" \"a a e f g\" \"h i j k k\" \"l m n k k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b g g\" \"c d g g\" \"e f h i\" \"j j k l\" \"j j m n\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d d\" \"e e c d d\" \"e e f f g\" \"h i k l l\" \"j j k l l\" \"j j k m n\"",
    "rows": "",
    "columns": "1fr 1fr 2fr 1fr 1fr"
}, {
    "areas": "\"a c c d f f\" \"b c c e f f\" \"g g g g g g\" \"h h i k k l\" \"h h j k k m\" \"n n n n n n\"",
    "rows": "1fr 1fr 2fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a a a b c\" \"a a a d e\" \"a a a f g\" \"h i n n n\" \"j k n n n\" \"l m n n n\"",
    "rows": "",
    "columns": "1fr 1fr 2fr 1fr 1fr"
}, {
    "areas": "\"a b c c d e\" \"f f f g g g\" \"h i j j k l\" \"m m m n n n\"",
    "rows": "3fr 2fr 3fr 2fr",
    "columns": "2fr 2fr 1fr 1fr 2fr 2fr"
}, {
    "areas": "\"a a b b c c\" \"d e b b j k\" \"f g i i l m\" \"h h i i n n\"",
    "rows": "2fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a b c c d d\" \"e e f g d d\" \"h h h h h h\" \"i j k l m n\"",
    "rows": "1fr 1fr 2fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b b c c d\" \"e e f f g g\" \"h i i j j k\" \"l l m m n n\"",
    "rows": "",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k l m n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g g g i\" \"h g g g i\" \"h g g g j\" \"k l m n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f f g h h\" \"i i g j j\" \"k l m n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c d\" \"e f g h h\" \"i i j k l\" \"i i m n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c c\" \"d d e c c\" \"f g h c c\" \"i j k k l\" \"m j n o o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b c\" \"a a a d d\" \"e f g g h\" \"i j j k l\" \"m j j n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c d\" \"e f f f g\" \"h f f f i\" \"j k k l l\" \"m m n n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b b\" \"c d d e f\" \"g h i j k\" \"l m n n o\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d d\" \"e f g d d\" \"h i j d d\" \"k l m n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b i i i\" \"c d i i i\" \"e f i i i\" \"g h j j k\" \"l l m n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d d\" \"a e f g h\" \"i e f g j\" \"k e f g l\" \"m m n o l\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b b c\" \"d e f g h\" \"d i i i h\" \"d j k l h\" \"m n n n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c d\" \"e f g g d\" \"e f h i j\" \"k l l i j\" \"k m n n o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g g h h\" \"i g g h h\" \"j k k h h\" \"l m n o o\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c c d\" \"e f f f f g\" \"h f f f f i\" \"j f f f f k\" \"l m m n n o\"",
    "rows": "1fr 1fr 1fr 2fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"n o o o f\" \"m o o o g\" \"l k j i h\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b c\" \"a a a d e\" \"f g j j j\" \"h i j j j\" \"k k k l m\" \"k k k n o\"",
    "rows": "",
    "columns": "1fr 1fr 2fr 1fr 1fr"
}, {
    "areas": "\"a b c d e f\" \"g m m m m j\" \"h m m m m k\" \"i m m m m l\" \"n n n o o o\"",
    "rows": "1fr 1fr 1fr 1fr 2fr",
    "columns": ""
}, {
    "areas": "\"a a a b c c\" \"a a a d d d\" \"e f g d d d\" \"e h i d d d\" \"j k k k l m\" \"j k k k n o\"",
    "rows": "2fr 2fr 1fr 1fr 1fr 1fr",
    "columns": "2fr 1fr 1fr 2fr 1fr 1fr"
}, {
    "areas": "\"a a b b c\" \"a a d e h\" \"a a f g h\" \"i j m m h\" \"k l m m h\" \"n n m m o\"",
    "rows": "2fr 1fr 1fr 1fr 1fr 2fr",
    "columns": "1fr 1fr 1fr 1fr 4fr"
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a i\" \"b j\" \"c k\" \"d l\" \"e m\" \"f n\" \"g o\" \"h p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a a\" \"b c d e f\" \"g h i j k\" \"l m n o p\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a a b b\" \"c d d e f\" \"g h i j k\" \"l m n o p\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g g g h\" \"i g g g j\" \"k k l m m\" \"n n o p p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f f g i k\" \"f f h j k\" \"l m n o p\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c c d\" \"e f c c g\" \"h h i j k\" \"h h l m m\" \"n n o p p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"a e f g\" \"a h i j\" \"a k l m\" \"a n o p\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 1fr"
}, {
    "areas": "\"a a a b c\" \"d e f g h\" \"i j k k k\" \"l m n o p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c d\" \"e f g h h\" \"i i j k l\" \"m n o p p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g d\" \"h i j d\" \"k l m d\" \"n o p d\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a a b b c d\" \"a a b b e f\" \"a a g h k k\" \"a a i j k k\" \"l m p p p p\" \"n o p p p p\"",
    "rows": "1fr 1fr 1fr 1fr 2fr 2fr",
    "columns": "2fr 2fr 1fr 1fr 1fr 1fr"
}, {
    "areas": "\"a b c d e\" \"f g g h h\" \"i g g h h\" \"j k k h h\" \"l m n o p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b c\" \"a a a a d e\" \"f j j m o o\" \"g j j n o o\" \"h j j p p p\" \"i k l p p p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g g g h\" \"i g g g j\" \"k g g g l\" \"m n o p q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d d\" \"e f g h i\" \"j f g h k\" \"l f g h m\" \"n n o p q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d d\" \"e f f f g\" \"h i i i j\" \"k l l l m\" \"n n o p q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c c\" \"d d e f f\" \"g h i j k\" \"l l m n n\" \"o o p q q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d d\" \"e f g h i\" \"e j g k i\" \"e l g m i\" \"n n o p q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"a b f d e\" \"g h i j k\" \"l m n o p\" \"l m q o p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"f g k i j\" \"l m n o p\" \"l m q o p\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b c\" \"d e f g c\" \"d h i j k\" \"l m n o k\" \"l p p q q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c d\" \"e f g h d\" \"e f i j k\" \"l m n j k\" \"l o p p q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c c\" \"d d e e f\" \"g h i j k\" \"l m m n n\" \"o o p p q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i f g j\" \"k l l m\" \"n o p q\"",
    "rows": "1fr 1fr 1fr 2fr 1fr",
    "columns": "1fr 2fr 2fr 1fr"
}, {
    "areas": "\"a b c d e\" \"f g g h h\" \"i g g l l\" \"j k k l l\" \"m n o p q\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i e\" \"j k l m n\" \"j o p q r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c c\" \"d d e f f\" \"g h i i j\" \"k l m n o\" \"p p q r r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c c\" \"d d e f f\" \"g h i j k\" \"l l m n n\" \"o o p q r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"a g h i j f\" \"a k l m n f\" \"a o p q r f\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c c c c\" \"d e c c c c\" \"f g c c c c\" \"h i c c c c\" \"j k l m n o\" \"p p q q r r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b c c\" \"d d e e f f\" \"g h i j k l\" \"m n o p q r\"",
    "rows": "2fr 2fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g g h h i i\" \"j k l m n o\" \"p p q q r r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c c d d\" \"e f c c d d\" \"g g h i j j\" \"g g k l j j\" \"m m n n o p\" \"m m n n q r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c c d\" \"e f g g h h\" \"i i j k l l\" \"m m n o p p\" \"q q q r r r\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k g h i l\" \"m g h i n\" \"o p q r s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g g g j\" \"k h h h l\" \"m i i i n\" \"o p q r s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b b c\" \"d e f g h\" \"i j j j k\" \"l m n o p\" \"q r r r s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i e\" \"j k k k e\" \"j l m n o\" \"j p q r s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"f k k k j\" \"f l m n j\" \"o p q r s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b c\" \"d e f g h\" \"i j j j k\" \"l m n o p\" \"q r s s s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i e\" \"j k h l e\" \"j m h n o\" \"j p q r s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b b c\" \"d e f g h\" \"i j f k l\" \"m n f o p\" \"q r r r s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h d i\" \"j k h d l\" \"m k h n o\" \"p k q r s\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a k\" \"b l\" \"c m\" \"d n\" \"e o\" \"f p\" \"g q\" \"h r\" \"i s\" \"j t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j j j j j j j j j\" \"k l m n o p q r s\" \"t t t t t t t t t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j j j j j j j j j\" \"k k k k k k k k k\" \"l m n o p q r s t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"a e c d\" \"f g h i\" \"f g j i\" \"k l m n\" \"o l m n\" \"p q r s\" \"p q r t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a a\" \"b c c c c\" \"b d e f g\" \"b h i j g\" \"k l m n g\" \"o o p q r\" \"o o s s s\" \"t t t t t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b\" \"a a a a c\" \"d e f g h\" \"i i i j k\" \"l m n n o\" \"p q r s t\"",
    "rows": "1fr 3fr 1fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a a a a\" \"b c d e f\" \"b g g h i\" \"b g g j i\" \"k l m n i\" \"o o p p p\" \"o o q r s\" \"t t t t t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c j j j\" \"d e f j j j\" \"g h i j j j\" \"k k k l m n\" \"k k k o p q\" \"k k k r s t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b c d\" \"a a a e f g\" \"a a a h i j\" \"k l m t t t\" \"n o p t t t\" \"q r s t t t\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b\" \"a a a a c\" \"a a a a h\" \"d e f g h\" \"i i j k l\" \"m n o p q\" \"r s t t t\"",
    "rows": "1fr 1fr 2fr 1fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c c d\" \"e f f g g h\" \"i j j k k l\" \"m m n n o o\" \"p p q q r r\" \"s s t t u u\"",
    "rows": "",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a b c d d\" \"e f g h h\" \"i j k l m\" \"n n o p q\" \"r r s t u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c c d d e f\" \"g g g h i j k k\" \"l l m n n o o o\" \"p q q r s t u u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c d e e\" \"f f f g g g h\" \"i j k l m m n\" \"o o o p q q q\" \"r r s s t u u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b c c d\" \"a a a a e e f g\" \"h i j k l l l m\" \"n n n o l l l p\" \"q q r r s t t u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b c c d d\" \"e e f f f f g h\" \"i j f f f f k l\" \"m m m n o o o p\" \"q q r r s t t u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b c c d\" \"e e f f g g\" \"h i i j j k\" \"l l m m n n\" \"o p p q q r\" \"s s t t u u\"",
    "rows": "",
    "columns": "3fr 1fr 2fr 2fr 1fr 3fr"
}, {
    "areas": "\"a b b c d\" \"e b b f g\" \"h i j j k\" \"l m j j n\" \"o p p q r\" \"s p p t u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"t u u u u g\" \"s u u u u h\" \"r u u u u i\" \"q u u u u j\" \"p o n m l k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c\" \"a a d e\" \"f g h h\" \"i i j k\" \"l m n o\" \"p p q r\" \"s s t t\" \"s s u u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j k\" \"l m n o p q r s t u v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a l\" \"b m\" \"c n\" \"d o\" \"e p\" \"f q\" \"g r\" \"h s\" \"i t\" \"j u\" \"k v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a a a a\" \"b c d e f g h\" \"i j k l m n o\" \"p q r s t u v\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d d\" \"e f g h i\" \"j j k l l\" \"m n o p q\" \"r r s t u\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c d e\" \"f g h i j k\" \"l m n o p q\" \"r s t u v v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b e e e\" \"c b e e e\" \"d d e e e\" \"f g i i j\" \"h h i i k\" \"l m n o p\" \"q r r s p\" \"t r r u v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b b c\" \"a a b b d\" \"e g g h i\" \"f g g j k\" \"l m m n n\" \"o m m n n\" \"p q r r s\" \"t u r r v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e k k k k k\" \"f g h i j k k k k k\" \"l l l l l m n o p q\" \"l l l l l r s t u v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e k\" \"f g h i j k\" \"l m n o p v\" \"q r s t u v\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 1fr 1fr 5fr"
}, {
    "areas": "\"a b c c d d e f\" \"g g g h i j k k\" \"l m n o o p p p\" \"q r r s t u v v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"t u u u u g\" \"s u u u u h\" \"r v v v v i\" \"q v v v v j\" \"p o n m l k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r u u v v i\" \"q u u v v j\" \"p o n m l k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b b c d\" \"a a a a b b e f\" \"a a a a g h k k\" \"a a a a i j k k\" \"l l m n v v v v\" \"l l o p v v v v\" \"q r u u v v v v\" \"s t u u v v v v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a b b b\" \"a a a b b b\" \"c d g g h i\" \"e f g g j k\" \"l l l m m m\" \"n o r r s t\" \"p q r r u v\"",
    "rows": "1fr 1fr 1fr 1fr 2fr 1fr 1fr",
    "columns": "1fr 1fr 2fr 2fr 1fr 1fr"
}, {
    "areas": "\"a b e f g g\" \"a c e f g g\" \"d d e f h i\" \"d d e f h j\" \"k k k q q q\" \"l m o q q q\" \"l n o q q q\" \"p p o q q q\"",
    "rows": "1fr 1fr 1fr 1fr 4fr 1fr 1fr 2fr",
    "columns": "1fr 1fr 2fr 2fr 1fr 1fr"
}, {
    "areas": "\"a a a a b b b b\" \"c d e f f g h i\" \"j k l m m n o p\" \"q r s t t u v w\"",
    "rows": "2fr 1fr 1fr 1fr",
    "columns": "2fr 2fr 2fr 1fr 1fr 2fr 2fr 2fr"
}, {
    "areas": "\"a b c d e f g\" \"h h h h h h h\" \"i j k l m n o\" \"p p p p p p p\" \"q r s t u v w\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b\" \"a a a a c\" \"d e f f c\" \"g h i j k\" \"l l l m n\" \"o p q q r\" \"s t u v w\"",
    "rows": "1fr 2fr 1fr 1fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a b b c\" \"a a b b d\" \"e g g h i\" \"f g g j k\" \"l l m n n\" \"o o p n n\" \"q r s s v\" \"t u s s w\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b b b c c c c\" \"d d e e e f g g g h h\" \"i j j k k l m m n n o\" \"p p q q q r s s s t t\" \"u u u u v v v w w w w\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 1fr 1fr 3fr 1fr 1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a c c d d\" \"b c c d d\" \"e f g g h\" \"i j g g k\" \"i l l n o\" \"m l l p q\" \"r s t t u\" \"v v t t w\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b e e f h h\" \"c d e e g h h\" \"i k k l n h h\" \"j k k m o h h\" \"p p q s u u v\" \"p p r t u u w\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b e e e\" \"c b e e e\" \"d d e e e\" \"f g i i j\" \"h h i i k\" \"l m n o p\" \"q r r s t\" \"u r r v w\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b b c d\" \"e b b b f g\" \"h i j k k l\" \"m n n o p q\" \"r s t u v w\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b b b c d\" \"e b b b f g\" \"h h i j j g\" \"l m m j j k\" \"n n o p q r\" \"s t u v w w\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r w w w w i\" \"q w w w w j\" \"p o n m l k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i i j k\" \"l l l l l l\" \"m n o o p q\" \"r s t u v w\"",
    "rows": "1fr 1fr 2fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b c c c\" \"d e f c c c\" \"g g g h i j\" \"g g g k l m\" \"n o p q q r\" \"s u u v x x\" \"t u u w x x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d d e\" \"f g h d d i\" \"j k k k k l\" \"m k k k k r\" \"m n o p q r\" \"s s t v v w\" \"s s u v v x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b e e f\" \"c d e e g\" \"h h h h i\" \"h h h h j\" \"k l m n n\" \"o o p n n\" \"o o r s t\" \"u v w w x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a c c d d e\" \"b c c d d f\" \"g g h i j j\" \"g g k l j j\" \"m m n n o o\" \"p p n n q q\" \"p p r s q q\" \"t u v v w x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b e e e e\" \"c b e e e e\" \"d d e e e e\" \"f g i i j k\" \"h h i i l k\" \"m n o p q q\" \"r t t u q q\" \"s t t v w x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b c\" \"a a a a d d\" \"e f g h i j\" \"k k k l m n\" \"o p q q r r\" \"s t u v w x\"",
    "rows": "1fr 3fr 1fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"t u u v v g\" \"s u u v v h\" \"r w w x x i\" \"q w w x x j\" \"p o n m l k\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b d e f\" \"a a c g g h\" \"k l m g g i\" \"n o o t u j\" \"p o o v x x\" \"q r s w x x\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d y\" \"e f g h y\" \"i j k l y\" \"m n o p y\" \"q r s t y\" \"u v w x y\"",
    "rows": "",
    "columns": "1fr 1fr 1fr 1fr 4fr"
}, {
    "areas": "\"a a a a a a\" \"b c d e f g\" \"h i j k l m\" \"n o p q r s\" \"t u v w x y\"",
    "rows": "4fr 1fr 1fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y y y y y y\"",
    "rows": "1fr 1fr 1fr 1fr 4fr",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"a f g h i\" \"a j k l m\" \"a n o p q\" \"a r s t u\" \"a v w x y\"",
    "rows": "",
    "columns": "4fr 1fr 1fr 1fr 1fr"
}, {
    "areas": "\"a b c d e f g\" \"h h h i i i i\" \"j k l m n o p\" \"q q q q r r r\" \"s t u v w x y\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a h j q s\" \"b h k q t\" \"c h l q u\" \"d i m q v\" \"e i n r w\" \"f i o r x\" \"g i p r y\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c c d e\" \"f g c c h i\" \"j k k l l m\" \"o k k l l n\" \"o p q r s n\" \"t u u w w x\" \"v u u w w y\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b m n o\" \"c d m p q\" \"e f m r s\" \"g h m t u\" \"i j m v w\" \"k l m x y\"",
    "rows": "",
    "columns": "1fr 1fr 3fr 1fr 1fr"
}, {
    "areas": "\"a b c d d d\" \"e f g d d d\" \"h h h i j k\" \"h h h l m n\" \"o p q r r s\" \"t v v w y y\" \"u v v x y y\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a a a b b c c c d d\" \"e e f f g h h i i j j\" \"k l l m n n o o o o o\" \"p p q q q q r r s s t\" \"u v v w x x y y y y y\"",
    "rows": "",
    "columns": "2fr 1fr 1fr 2fr 2fr 1fr 1fr 1fr 1fr 1fr 2fr"
}, {
    "areas": "\"a b c d e f\" \"g h i i j k\" \"l l m m n n\" \"o p q q r s\" \"t u v w x y\"",
    "rows": "1fr 1fr 2fr 1fr 1fr",
    "columns": ""
}, {
    "areas": "\"a a a a b b c d\" \"a a a a b b e f\" \"a a a a g h k k\" \"a a a a i j k k\" \"l l m n q q r r\" \"l l o p q q r r\" \"s t w w x x y y\" \"u v w w x x y y\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a a b d f f\" \"a a c e g g\" \"h i j j k l\" \"m n o p q r\" \"s s t u v v\" \"w w x y v v\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k k\" \"l m n o\" \"p q r s\" \"t t u v\" \"w w x x\" \"w w y y\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\" \"y z aa\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c\" \"d e f\" \"g h i\" \"j k l\" \"m n o\" \"p q r\" \"s t u\" \"v w x\" \"y z aa\" \"ab ac ad\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\" \"ag ah ai aj\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d\" \"e f g h\" \"i j k l\" \"m n o p\" \"q r s t\" \"u v w x\" \"y z aa ab\" \"ac ad ae af\" \"ag ah ai aj\" \"ak al am an\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\" \"ao ap aq ar as\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e\" \"f g h i j\" \"k l m n o\" \"p q r s t\" \"u v w x y\" \"z aa ab ac ad\" \"ae af ag ah ai\" \"aj ak al am an\" \"ao ap aq ar as\" \"at au av aw ax\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\" \"aw ax ay az ba bb\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f\" \"g h i j k l\" \"m n o p q r\" \"s t u v w x\" \"y z aa ab ac ad\" \"ae af ag ah ai aj\" \"ak al am an ao ap\" \"aq ar as at au av\" \"aw ax ay az ba bb\" \"bc bd be bf bg bh\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g\" \"h i j k l m n\" \"o p q r s t u\" \"v w x y z aa ab\" \"ac ad ae af ag ah ai\" \"aj ak al am an ao ap\" \"aq ar as at au av aw\" \"ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\" \"bm bn bo bp bq br bs bt\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h\" \"i j k l m n o p\" \"q r s t u v w x\" \"y z aa ab ac ad ae af\" \"ag ah ai aj ak al am an\" \"ao ap aq ar as at au av\" \"aw ax ay az ba bb bc bd\" \"be bf bg bh bi bj bk bl\" \"bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb cc\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\" \"cc cd ce cf cg ch ci cj ck cl\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i\" \"j k l m n o p q r\" \"s t u v w x y z aa\" \"ab ac ad ae af ag ah ai aj\" \"ak al am an ao ap aq ar as\" \"at au av aw ax ay az ba bb\" \"bc bd be bf bg bh bi bj bk\" \"bl bm bn bo bp bq br bs bt\" \"bu bv bw bx by bz ca cb cc\" \"cd ce cf cg ch ci cj ck cl\"",
    "rows": "",
    "columns": ""
}, {
    "areas": "\"a b c d e f g h i j\" \"k l m n o p q r s t\" \"u v w x y z aa ab ac ad\" \"ae af ag ah ai aj ak al am an\" \"ao ap aq ar as at au av aw ax\" \"ay az ba bb bc bd be bf bg bh\" \"bi bj bk bl bm bn bo bp bq br\" \"bs bt bu bv bw bx by bz ca cb\" \"cc cd ce cf cg ch ci cj ck cl\" \"cm cn co cp cq cr cs ct cu cv\"",
    "rows": "",
    "columns": ""
}];
var outlineFonts = {};
var nbdApp;
var dependModules = ["angularSpectrumColorpicker", 'angular.bind.notifier', 'ui.sortable', 'ui.sortable.multiselection'];
if (!!NBDESIGNCONFIG['enable_live_chat'] && NBDESIGNCONFIG['ui_mode'] == 2) {
    dependModules.push("nbdChatApp");
}
if (NBDESIGNCONFIG['ui_mode'] != 3) {
    nbdApp = angular.module('nbd-app', dependModules);
    Promise.all([
        fetch("/templates-roles.json", {cache: "no-cache"}).then(response => response.json()),
        fetch("/clipart-roles.json", {cache: "no-cache"}).then(response => response.json()),
        fetch("/overlays-roles.json", {cache: "no-cache"}).then(response => response.json()),
    ])
        .then(([templatesRoles, clipartRoles, overlayRoles]) => {
            nbdApp.constant('CONFIG', {
                templatesRoles,
                clipartRoles,
                overlayRoles
            });
            angular.element(() => {
                angular.bootstrap(document, ['nbd-app']);
            });
        })
        .catch(() => {
            nbdApp.constant('CONFIG', {
                templatesRoles: [],
                clipartRoles: [],
                overlayRoles: []
            });
            angular.element(() => {
                angular.bootstrap(document, ['nbd-app']);
            });
        });
} else {
    nbdApp = angular.module('nbdApp', dependModules);
}
;
nbdApp.constant("_", window._);
nbdApp.config(function ($controllerProvider, $compileProvider, $filterProvider) {
    nbdApp.controller = function (name, constructor) {
        $controllerProvider.register(name, constructor);
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|blob):|data:image\//);
        return (this);
    };
    nbdApp.directive = function (name, factory) {
        $compileProvider.directive(name, factory);
        return (this);
    };
    nbdApp.filter = function (name, filter) {
        $filterProvider.register(name, filter);
        return (this);
    };
});
nbdApp.config([
    '$compileProvider', function ($compileProvider) {
        $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|blob):|data:image\/|data:img\//);
    }
]);
nbdApp.controller('designCtrl', ['$scope', 'FabricWindow', '$window', 'NBDDataFactory', 'filterFontFilter', 'filterArtFilter', '$timeout', '$http', '$document', '$interval', 'CONFIG', 'uiSortableMultiSelectionMethods',
    function ($scope, FabricWindow, $window, NBDDataFactory, filterFontFilter, filterArtFilter, $timeout, $http, $document, $interval, CONFIG, uiSortableMultiSelectionMethods) {
        $scope.stages = [];
        var d = new Date(),
            t = d.getTime();
        $scope.defaultStageStates = {
            isActiveLayer: false,
            isLayer: false,
            isGroup: false,
            isNativeGroup: false,
            isText: false,
            isImage: false,
            isPath: false,
            isShape: false,
            isEditing: false,
            isRedoable: false,
            isUndoable: false,
            elementUpload: false,
            isShowToolBox: false,
            enableRotate: true,
            enableOpacity: true,
            enableShadow: NBDESIGNCONFIG.nbdesigner_enable_cloud2print_api == 'yes' ? true : false,
            enableChangePathColor: true,
            oos: false,
            ilr: false,
            boundingObject: {},
            corners: [],
            boundingRealSize: {},
            coordinates: {lastCheck: t},
            rotate: {},
            uploadZone: {},
            opacity: 100,
            snaplines: {},
            itemId: null,
            tempParameters: null,
            usedFonts: [],
            type: null,
            text: {
                fontFamily: {
                    alias: NBDESIGNCONFIG.default_font.alias,
                    r: NBDESIGNCONFIG.default_font.file.r,
                    b: NBDESIGNCONFIG.default_font.file.b,
                    i: NBDESIGNCONFIG.default_font.file.i,
                    bi: NBDESIGNCONFIG.default_font.file.bi
                },
                fontSize: 14,
                fontFamily: NBDESIGNCONFIG.default_font.alias,
                textAlign: 'left',
                fontWeight: false,
                textDecoration: false,
                fontStyle: '',
                spacing: 0,
                lineHeight: 1.16,
                is_uppercase: false,
                fill: '#06d79c'
            },
            svg: {groupPath: {}, currentPath: null},
            image: {},
            scaleRange: [],
            currentScaleIndex: 0,
            fitScaleIndex: 0,
            fillScaleIndex: 0,
            lostCharLayers: [],
            shadow: {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                offsetX: 0,
                offsetY: 0,
                blur: 0,
                opacity: 0.75
            }
        };

        if (typeof udc_nbd_js_config != 'undefined') {
            Object.assign($scope.defaultStageStates, {isBGimage: false});
            Object.assign($scope.defaultStageStates.svg, {strokecolor: '', shadowcolor: ''});
        }
        /*advanced*/
        if (typeof hvc_app_modern_js != 'undefined') {
            $scope.defaultStageStates.enableScale = true;
        }
        if (typeof checkBox != 'undefined') {
            $scope.capital = false;
            $scope.lockFont = false;
        }
        $scope.defaultConfig = {
            name: 'Typography',
            width: 200,
            height: 200,
            cheight: 200,
            cwidth: 200,
            left: 0,
            top: 0,
            bleed_lr: 0,
            bleed_tb: 0,
            margin_lr: 0,
            margin_tb: 0,
            bgType: 'tran',
            bgColor: '#ffffff',
            bgImage: 0,
            showBleed: 0,
            showOverlay: 0,
            showSafeZone: 0
        };
        $scope.initSettings = function () {
            $scope.debugMode = appConfig.debugMode;
            $scope.the_first_time_load_page = true;
            $scope.printingOptionsAvailable = NBDESIGNCONFIG.show_nbo_option == '1' ? false : true;
            angular.copy(NBDESIGNCONFIG, $scope.settings);
            $scope.$watch('currentStage', function () {
                $scope.onTitleChanged();
            });
            angular.extend($scope.settings, {
                showRuler: checkMobileDevice() ? false : (NBDESIGNCONFIG.nbdesigner_show_ruler == 'yes' ? true : false),
                showGrid: NBDESIGNCONFIG.nbdesigner_show_grid == 'yes' ? true : false,
                showDimensions: NBDESIGNCONFIG.nbdesigner_show_product_dimensions == 'yes' ? true : false,
                bleedLine: NBDESIGNCONFIG.nbdesigner_show_bleed == 'yes' ? true : false,
                snapMode: {status: false, type: 'layer'},
                showWarning: {
                    oos: NBDESIGNCONFIG.nbdesigner_show_warning_oos == 'yes' ? true : false,
                    ilr: NBDESIGNCONFIG.nbdesigner_show_warning_ilr == 'yes' ? true : false
                }
            });
            $scope.offsetDesignWrap = NBDESIGNCONFIG.nbdesigner_show_design_border == 'yes' ? -1 : 0;
            $scope.rateConvertCm2Px96dpi = 37.795275591;
            $scope.currentStage = 0;
            $scope.showTextColorPicker = false;
            if (window.EyeDropper) {
                $scope.eyeDropper = new EyeDropper();
            }
            $scope.showBgColorPicker = false;
            $scope.__colorPalette = __colorPalette;
            /*advanced*/
            if (typeof udc_nbd_js_config != 'undefined') {
                $scope.clipboard;
                $scope.blur = 0;
                $scope.rotate = 0;
                $scope.saturation = 0;
                $scope.opacityvalue = 0;
                $scope.hue = 0;
                $scope.brightness = 0;
                $scope.contrast = 0;
                $scope.blurimg = 0;
                $scope.svgstroke = 0;
                $scope.imgstroke = 0;
                $scope.shapeBorderRadius = 0;
                $scope.imageBorderRadius = 0;
                $scope.shapeSideBorderRadius = {
                    leftTop: 0,
                    rightTop: 0,
                    rightBottom: 0,
                    leftBottom: 0
                };
                $scope.imageSideBorderRadius = {
                    leftTop: 0,
                    rightTop: 0,
                    rightBottom: 0,
                    leftBottom: 0
                };
                $scope.offsetX = 0;
                $scope.offsetY = 0;
                $scope.sortableOptions = uiSortableMultiSelectionMethods.extendOptions({
                    'multiSelectOnClick': false,
                    stop: function (e, sortable) {
                        const stage = $scope.getCurrentStage();
                        const canvas = $scope.getCurrentStageCanvas();
                        if (!stage || !canvas || !stage.layers) {
                            return;
                        }
                        stage.layers.forEach((layer, index) => {
                            const _index = $scope.getLayerById(layer.itemId);
                            const item = canvas.item(_index);
                            item.moveTo(index);
                            layer.index = index;
                        });
                        const activeItems = [...document.querySelectorAll('.menu-layer .menu-item.active')];
                        if (activeItems && activeItems.length) {
                            activeItems
                                .forEach((domItem) => domItem.classList.add('ui-sortable-selected'));
                        }
                        $scope.renderStage();
                        $scope.updateApp();
                    }
                });
                $scope.downloadOptions = {
                    format: 'png',
                    quality: 1,
                    dpi: 300,
                    size: 1,
                    pages: ['all'],
                    forceTransparency: false
                }
                $scope.gradientOne;
                $scope.gradientTwo;
                $scope.txtgradientOne;
                $scope.txtgradientTwo;
                $scope.f = fabric.Image.filters;
                $scope.shadowcolor;
            }
            $scope.layerPosition = {
                x: 0,
                y: 0,
                w: 0,
                h: 0,
                offsetX: 0.5,
                offsetY: 0.5
            };
            /*advanced*/
            if (typeof __colorPaletteHex != "undefined") {
                $scope.__colorPaletteHex = __colorPaletteHex;
            }
            //template ai to svg
            if (typeof nbptemp_all_ai_to_svg != 'undefined') {
                $scope.showglobal = false;
                $scope.product_categories = NBDESIGNCONFIG.product_categories;
            }
            $scope.currentColor = NBDESIGNCONFIG.nbdesigner_default_color;
            $scope.currentStrokeColor = NBDESIGNCONFIG.nbdesigner_default_color;
            /*advanced*/
            if (typeof ctcs_nbd_js_config_design != "undefined" || typeof bagr_background != "undefined") {
                $scope.listBackgroundColor = [];
            }
            /*advanced*/
            if (typeof cufd_nbd_js_config != "undefined") {
                $scope.dataCopy = null;
                $scope.copyLayersSelect = function () {
                    $scope.dataCopy = null;
                    var _canvas = this.stages[$scope.currentStage]['canvas'];
                    $scope.dataCopy = _canvas.getActiveObject();
                };
                $scope.paseDataCopy = function () {
                    var _canvas = this.stages[$scope.currentStage]['canvas'];
                    var activeObject = $scope.dataCopy;
                    activeObject.clone(function (cloned) {
                        var _clipboard = cloned;

                        function _clone(__clipboard, mask) {
                            $timeout(function () {
                                __clipboard.clone(function (clonedObj) {
                                    _canvas.discardActiveObject();
                                    clonedObj.set({
                                        left: clonedObj.left + 10,
                                        top: clonedObj.top + 10,
                                        evented: true
                                    });
                                    if (clonedObj.type === 'activeSelection') {
                                        clonedObj.canvas = _canvas;
                                        clonedObj.forEachObject(function (obj) {
                                            $scope.contextAddLayers = 'copy';
                                            _canvas.add(obj);
                                        });
                                        clonedObj.setCoords();
                                    } else {
                                        $scope.contextAddLayers = 'copy';
                                        _canvas.add(clonedObj);
                                        if (angular.isDefined(mask)) {
                                            clonedObj.set({
                                                clipPath: mask,
                                                maskId: mask.get('itemId'),
                                                centeredScaling: true
                                            });
                                            $scope.updateMaskLayer();
                                        }
                                    }
                                    _canvas.setActiveObject(clonedObj);
                                    _canvas.requestRenderAll();
                                });
                            }, 10);
                        }

                        if (cloned.type != 'activeSelection' && !!activeObject.get('maskId')) {
                            var maskLayer = $scope.getMaskLayer(activeObject.get('maskId'));
                            if (maskLayer) {
                                maskLayer.clone(function (cloned) {
                                    var _maskClipboard = cloned;
                                    $timeout(function () {
                                        _clone(_maskClipboard);
                                        $timeout(function () {
                                            var mask = _canvas.item(_canvas.getObjects().length - 1);
                                            mask.set({
                                                isMask: 1,
                                                absolutePositioned: true,
                                                selectable: false
                                            });
                                            _clone(_clipboard, mask);
                                        }, 10);
                                    }, 10);
                                });
                            } else {
                                _clone(_clipboard);
                            }
                        } else {
                            _clone(_clipboard);
                        }
                    });
                };
            }
            $scope.listAddedColor = [];
            $scope.tempStageDesign = null;
            /*advanced*/
            if (typeof udc_nbd_js_config != 'undefined') {
                $scope.selectedcanvasObject = null;
                /*advanced*/
                $scope.currentColorCustomizeBlend = '#00f900';
                $scope.currentColorCustomize = $scope.settings.nbdesigner_default_color;
                $scope.nameModeImage = '';
                $scope.aphaImage = 1;
                $scope.modeImageBlend = '';
                $scope.isCrop = false;
                $scope.elementpreviewImg = [];
                $scope.rootpath = '';
                $scope.prevpath = '';
                $scope.currentpath = '';
                $scope.cdnPicturesArr = [];
                $scope.cdnOverlaysArr = [];
                $scope.photouserArr = [];
                //$scope.textMasks = ['assets/textmasks/honey_im_subtle.png','assets/textmasks/nasty_fabric.png','assets/textmasks/retina_wood.png','assets/textmasks/greyfloral.png','assets/textmasks/escheresque.png','assets/textmasks/escheresque_ste.png','assets/textmasks/bedge_grunge.png','assets/textmasks/ladybug.png','assets/textmasks/dragon2.jpg','assets/textmasks/pug.jpg'];
                $scope.textMasks = [];
                $scope.gradients = [{
                    "name": "Warm Flame",
                    "color1": "#ff9a9e",
                    "color2": "#fad0c4"
                }, {"name": "Night Fade", "color1": "#a18cd1", "color2": "#fbc2eb"}, {
                    "name": "Spring Warmth",
                    "color1": "#fad0c4",
                    "color2": "#ffd1ff"
                }, {"name": "Juicy Peach", "color1": "#ffecd2", "color2": "#fcb69f"}, {
                    "name": "Lady Lips",
                    "color1": "#ff9a9e",
                    "color2": "#fecfef"
                }, {"name": "Sunny Morning", "color1": "#f6d365", "color2": "#fda085"}, {
                    "name": "Rainy Ashville",
                    "color1": "#fbc2eb",
                    "color2": "#a6c1ee"
                }, {"name": "Frozen Dreams", "color1": "#fdcbf1", "color2": "#e6dee9"}, {
                    "name": "Winter Neva",
                    "color1": "#a1c4fd",
                    "color2": "#c2e9fb"
                }, {"name": "Dusty Grass", "color1": "#d4fc79", "color2": "#96e6a1"}, {
                    "name": "Tempting Azure",
                    "color1": "#84fab0",
                    "color2": "#8fd3f4"
                }, {"name": "Heavy Rain", "color1": "#cfd9df", "color2": "#e2ebf0"}, {
                    "name": "Amy Crisp",
                    "color1": "#a6c0fe",
                    "color2": "#f68084"
                }, {"name": "Mean Fruit", "color1": "#fccb90", "color2": "#d57eeb"}, {
                    "name": "Deep Blue",
                    "color1": "#e0c3fc",
                    "color2": "#8ec5fc"
                }, {"name": "Ripe Malinka", "color1": "#f093fb", "color2": "#f5576c"}, {
                    "name": "Cloudy Knoxville",
                    "color1": "#fdfbfb",
                    "color2": "#ebedee"
                }, {"name": "Malibu Beach", "color1": "#4facfe", "color2": "#00f2fe"}, {
                    "name": "New Life",
                    "color1": "#43e97b",
                    "color2": "#38f9d7"
                }, {"name": "True Sunset", "color1": "#fa709a", "color2": "#fee140"}, {
                    "name": "Morpheus Den",
                    "color1": "#30cfd0",
                    "color2": "#330867"
                }, {"name": "Rare Wind", "color1": "#a8edea", "color2": "#fed6e3"}, {
                    "name": "Near Moon",
                    "color1": "#5ee7df",
                    "color2": "#b490ca"
                }, {"name": "Wild Apple", "color1": "#d299c2", "color2": "#fef9d7"}, {
                    "name": "Saint Petersburg",
                    "color1": "#f5f7fa",
                    "color2": "#c3cfe2"
                }, {"name": "Plum Plate", "color1": "#667eea", "color2": "#764ba2"}, {
                    "name": "Everlasting Sky",
                    "color1": "#fdfcfb",
                    "color2": "#e2d1c3"
                }, {"name": "Happy Fisher", "color1": "#89f7fe", "color2": "#66a6ff"}, {
                    "name": "Blessing",
                    "color1": "#fddb92",
                    "color2": "#d1fdff"
                }, {"name": "Sharpeye Eagle", "color1": "#9890000", "color2": "#b1f4cf"}, {
                    "name": "Ladoga Bottom",
                    "color1": "#ebc0fd",
                    "color2": "#d9ded8"
                }, {"name": "Lemon Gate", "color1": "#96fbc4", "color2": "#f9f586"}, {
                    "name": "Itmeo Branding",
                    "color1": "#2af598",
                    "color2": "#009efd"
                }, {"name": "Zeus Miracle", "color1": "#cd9cf2", "color2": "#f6f3ff"}, {
                    "name": "Deep Blue",
                    "color1": "#6a11cb",
                    "color2": "#2575fc"
                }, {"name": "Happy Acid", "color1": "#37ecba", "color2": "#72afd3"}, {
                    "name": "Awesome Pine",
                    "color1": "#ebbba7",
                    "color2": "#cfc7f8"
                }, {"name": "New York", "color1": "#fff1eb", "color2": "#ace0f9"}, {
                    "name": "Mixed Hopes",
                    "color1": "#c471f5",
                    "color2": "#fa71cd"
                }, {"name": "Fly High", "color1": "#48c6ef", "color2": "#6f86d6"}, {
                    "name": "Fresh Milk",
                    "color1": "#feada6",
                    "color2": "#f5efef"
                }, {"name": "Snow Again", "color1": "#e6e9f0", "color2": "#eef1f5"}, {
                    "name": "February Ink",
                    "color1": "#accbee",
                    "color2": "#e7f0fd"
                }, {"name": "Kind Steel", "color1": "#e9defa", "color2": "#fbfcdb"}, {
                    "name": "Soft Grass",
                    "color1": "#c1dfc4",
                    "color2": "#deecdd"
                }, {"name": "Grown Early", "color1": "#0ba360", "color2": "#3cba92"}, {
                    "name": "Sharp Blues",
                    "color1": "#00c6fb",
                    "color2": "#005bea"
                }, {"name": "Shady Water", "color1": "#74ebd5", "color2": "#9face6"}, {
                    "name": "Dirty Beauty",
                    "color1": "#6a85b6",
                    "color2": "#bac8e0"
                }, {"name": "Great Whale", "color1": "#a3bded", "color2": "#6991c7"}, {
                    "name": "Teen Notebook",
                    "color1": "#9795f0",
                    "color2": "#fbc8d4"
                }, {"name": "Polite Rumors", "color1": "#a7a6cb", "color2": "#8989ba"}, {
                    "name": "Red Salvation",
                    "color1": "#f43b47",
                    "color2": "#453a94"
                }, {"name": "Night Party", "color1": "#0250c5", "color2": "#d43f8d"}, {
                    "name": "Sky Glider",
                    "color1": "#88d3ce",
                    "color2": "#6e45e2"
                }, {"name": "Heaven Peach", "color1": "#d9afd9", "color2": "#97d9e1"}, {
                    "name": "Purple Division",
                    "color1": "#70280000",
                    "color2": "#e5b2ca"
                }, {"name": "Aqua Splash", "color1": "#13547a", "color2": "#80d0c7"}, {
                    "name": "Love Kiss",
                    "color1": "#ff0844",
                    "color2": "#ffb199"
                }, {"name": "Clean Mirror", "color1": "#93a5cf", "color2": "#e4efe9"}, {
                    "name": "Premium Dark",
                    "color1": "#434343",
                    "color2": "#0"
                }, {"name": "Cochiti Lake", "color1": "#93a5cf", "color2": "#e4efe9"}, {
                    "name": "Summer Games",
                    "color1": "#92fe9d",
                    "color2": "#00c9ff"
                }, {"name": "Passionate Bed", "color1": "#ff758c", "color2": "#ff7eb3"}, {
                    "name": "Mountain Rock",
                    "color1": "#868f96",
                    "color2": "#596164"
                }, {"name": "Desert Hump", "color1": "#c79081", "color2": "#dfa579"}, {
                    "name": "Jungle Day",
                    "color1": "#8baaaa",
                    "color2": "#ae8b9c"
                }, {"name": "Phoenix Start", "color1": "#f83600", "color2": "#f9d423"}, {
                    "name": "October Silence",
                    "color1": "#b721ff",
                    "color2": "#21d4fd"
                }, {"name": "Faraway River", "color1": "#6e45e2", "color2": "#88d3ce"}, {
                    "name": "Alchemist Lab",
                    "color1": "#d558c8",
                    "color2": "#24d292"
                }, {"name": "Over Sun", "color1": "#abecd6", "color2": "#fbed96"}, {
                    "name": "Mars Party",
                    "color1": "#5f72bd",
                    "color2": "#9b23ea"
                }, {"name": "Eternal Constance", "color1": "#09203f", "color2": "#537895"}, {
                    "name": "Japan Blush",
                    "color1": "#ddd6f3",
                    "color2": "#faaca8"
                }, {"name": "Smiling Rain", "color1": "#dcb0ed", "color2": "#99c99c"}, {
                    "name": "Cloudy Apple",
                    "color1": "#f3e7e9",
                    "color2": "#e3eeff"
                }, {"name": "Big Mango", "color1": "#c71d6f", "color2": "#d09693"}, {
                    "name": "Healthy Water",
                    "color1": "#96deda",
                    "color2": "#50c9c3"
                }, {"name": "Amour Amour", "color1": "#f77062", "color2": "#fe5196"}, {
                    "name": "Strong Stick",
                    "color1": "#a8caba",
                    "color2": "#5d4157"
                }, {"name": "Vicious Stance", "color1": "#29323c", "color2": "#485563"}, {
                    "name": "Palo Alto",
                    "color1": "#16a085",
                    "color2": "#f4d03f"
                }, {"name": "Happy Memories", "color1": "#ff5858", "color2": "#f09819"}, {
                    "name": "Midnight Bloom",
                    "color1": "#2b5876",
                    "color2": "#4e4376"
                }, {"name": "Crystalline", "color1": "#00cdac", "color2": "#8ddad5"}, {
                    "name": "Party Bliss",
                    "color1": "#4481eb",
                    "color2": "#04befe"
                }, {"name": "Confident Cloud", "color1": "#dad4ec", "color2": "#f3e7e9"}, {
                    "name": "Le Cocktail",
                    "color1": "#874da2",
                    "color2": "#c43a30"
                }, {"name": "River City", "color1": "#4481eb", "color2": "#04befe"}, {
                    "name": "Frozen Berry",
                    "color1": "#e8198b",
                    "color2": "#c7eafd"
                }, {"name": "Child Care", "color1": "#f794a4", "color2": "#fdd6bd"}, {
                    "name": "Flying Lemon",
                    "color1": "#64b3f4",
                    "color2": "#c2e59c"
                }, {"name": "Hidden Jaguar", "color1": "#0fd850", "color2": "#f9f047"}, {
                    "name": "Nega",
                    "color1": "#ee9ca7",
                    "color2": "#ffdde1"
                }, {"name": "Seashore", "color1": "#209cff", "color2": "#68e0cf"}, {
                    "name": "Marble Wall",
                    "color1": "#bdc2e8",
                    "color2": "#e6dee9"
                }, {"name": "Cheerful Caramel", "color1": "#e6b980", "color2": "#eacda3"}, {
                    "name": "Night Sky",
                    "color1": "#1e3c72",
                    "color2": "#2a5298"
                }, {"name": "Young Grass", "color1": "#9be15d", "color2": "#00e3ae"}, {
                    "name": "Colorful Peach",
                    "color1": "#ed6ea0",
                    "color2": "#ec8c69"
                }, {"name": "Gentle Care", "color1": "#ffc3a0", "color2": "#ffafbd"}, {
                    "name": "Plum Bath",
                    "color1": "#cc208e",
                    "color2": "#6713d2"
                }, {"name": "Happy Unicorn", "color1": "#b3ffab", "color2": "#12fff7"}, {
                    "name": "Solid Stone",
                    "color1": "#243949",
                    "color2": "#517fa4"
                }, {"name": "Orange Juice", "color1": "#fc6076", "color2": "#ff9a44"}, {
                    "name": "Glass Water",
                    "color1": "#dfe9f3",
                    "color2": "#ffffff"
                }, {"name": "North Miracle", "color1": "#00dbde", "color2": "#fc00ff"}, {
                    "name": "Fruit Blend",
                    "color1": "#f9d423",
                    "color2": "#ff4e50"
                }, {"name": "Millennium Pine", "color1": "#50cc7f", "color2": "#f5d100"}, {
                    "name": "High Flight",
                    "color1": "#0acffe",
                    "color2": "#495aff"
                }, {"name": "Mole Hall", "color1": "#616161", "color2": "#9bc5c3"}, {
                    "name": "Forest Inei",
                    "color1": "#df89b5",
                    "color2": "#bfd9fe"
                }, {"name": "Royal Garden", "color1": "#ed6ea0", "color2": "#ec8c69"}, {
                    "name": "Rich Metal",
                    "color1": "#d7d2cc",
                    "color2": "#304352"
                }, {"name": "Juicy Cake", "color1": "#e14fad", "color2": "#f9d423"}, {
                    "name": "Smart Indigo",
                    "color1": "#b224ef",
                    "color2": "#7579ff"
                }, {"name": "Sand Strike", "color1": "#c1c161", "color2": "#d4d4b1"}, {
                    "name": "Norse Beauty",
                    "color1": "#ec77ab",
                    "color2": "#7873f5"
                }, {"name": "Aqua Guidance", "color1": "#007adf", "color2": "#00ecbc"}, {
                    "name": "Sun Veggie",
                    "color1": "#20E2D7",
                    "color2": "#F9FEA5"
                }, {"name": "Witch Dance", "color1": "#A8BFFF", "color2": "#884D80"}, {
                    "name": "Soft Lipstick",
                    "color1": "#B6CEE8",
                    "color2": "#F578DC"
                }, {"name": "Salt Mountain", "color1": "#FFFEFF", "color2": "#D7FFFE"}, {
                    "name": "Perfect White",
                    "color1": "#E3FDF5",
                    "color2": "#FFE6FA"
                }, {"name": "Fresh Oasis", "color1": "#7DE2FC", "color2": "#B9B6E5"}, {
                    "name": "Strict November",
                    "color1": "#CBBACC",
                    "color2": "#2580B3"
                }, {"name": "Morning Salad", "color1": "#B7F8DB", "color2": "#50A7C2"}, {
                    "name": "Lily Meadow",
                    "color1": "#007adf",
                    "color2": "#00ecbc"
                }, {"name": "Omolon", "color1": "#091E3A", "color2": "#2F80ED"}, {
                    "name": "Farhan",
                    "color1": "#9400D3",
                    "color2": "#4B0082"
                }, {"name": "Purple", "color1": "#c84e89", "color2": "#F15F79"}, {
                    "name": "Ibtesam",
                    "color1": "#00F5A0",
                    "color2": "#00D9F5"
                }, {"name": "Radioactive Heat", "color1": "#F7941E", "color2": "#00A651"}, {
                    "name": "Sky And Sea",
                    "color1": "#F7941E",
                    "color2": "#004E8F"
                }, {"name": "Ice To Fire", "color1": "#72C6EF", "color2": "#004E8F"}, {
                    "name": "Blue & Orange",
                    "color1": "#FD8112",
                    "color2": "#0085CA"
                }, {"name": "Purple Dream", "color1": "#bf5ae0", "color2": "#a811da"}, {
                    "name": "Blu",
                    "color1": "#00416A",
                    "color2": "#E4E5E6"
                }, {"name": "Summer Breeze", "color1": "#fbed96", "color2": "#abecd6"}, {
                    "name": "Ver",
                    "color1": "#FFE000",
                    "color2": "#799F0C"
                }, {"name": "Ver Black", "color1": "#F7F8F8", "color2": "#ACBB78"}, {
                    "name": "Reaqua",
                    "color1": "#799F0C",
                    "color2": "#ACBB78"
                }, {"name": "Mango", "color1": "#ffe259", "color2": "#ffa751"}, {
                    "name": "Bupe",
                    "color1": "#00416A",
                    "color2": "#E4E5E6"
                }, {"name": "Rea", "color1": "#FFE000", "color2": "#799F0C"}, {
                    "name": "Windy",
                    "color1": "#acb6e5",
                    "color2": "#86fde8"
                }, {"name": "Royal Blue", "color1": "#536976", "color2": "#292E49"}, {
                    "name": "Copper",
                    "color1": "#B79891",
                    "color2": "#94716B"
                }, {"name": "Anamnisar", "color1": "#9796f0", "color2": "#fbc7d4"}, {
                    "name": "Petrol",
                    "color1": "#BBD2C5",
                    "color2": "#536976"
                }, {"name": "Sky", "color1": "#076585", "color2": "#fff"}, {
                    "name": "Sel",
                    "color1": "#00467F",
                    "color2": "#A5CC82"
                }, {"name": "Afternoon", "color1": "#000C40", "color2": "#607D8B"}, {
                    "name": "Skyline",
                    "color1": "#1488CC",
                    "color2": "#2B32B2"
                }, {"name": "DIMIGO", "color1": "#ec008c", "color2": "#fc6767"}, {
                    "name": "Purple Love",
                    "color1": "#cc2b5e",
                    "color2": "#753a88"
                }, {"name": "Sexy Blue", "color1": "#2193b0", "color2": "#6dd5ed"}, {
                    "name": "Blooker20",
                    "color1": "#e65c00",
                    "color2": "#F9D423"
                }, {"name": "Sea Blue", "color1": "#2b5876", "color2": "#4e4376"}, {
                    "name": "Nimvelo",
                    "color1": "#314755",
                    "color2": "#26a0da"
                }, {"name": "Hazel", "color1": "#77A1D3", "color2": "#79CBCA"}, {
                    "name": "Noon to Dusk",
                    "color1": "#ff6e7f",
                    "color2": "#bfe9ff"
                }, {"name": "YouTube", "color1": "#e52d27", "color2": "#b31217"}, {
                    "name": "Cool Brown",
                    "color1": "#603813",
                    "color2": "#b29f94"
                }, {"name": "Harmonic Energy", "color1": "#16A085", "color2": "#F4D03F"}, {
                    "name": "Playing with Reds",
                    "color1": "#D31027",
                    "color2": "#EA384D"
                }, {"name": "Sunny Days", "color1": "#EDE574", "color2": "#E1F5C4"}, {
                    "name": "Green Beach",
                    "color1": "#02AAB0",
                    "color2": "#00CDAC"
                }, {"name": "Intuitive Purple", "color1": "#DA22FF", "color2": "#9733EE"}, {
                    "name": "Emerald Water",
                    "color1": "#348F50",
                    "color2": "#56B4D3"
                }, {"name": "Lemon Twist", "color1": "#3CA55C", "color2": "#B5AC49"}, {
                    "name": "Horizon",
                    "color1": "#003973",
                    "color2": "#E5E5BE"
                }, {"name": "Rose Water", "color1": "#E55D87", "color2": "#5FC3E4"}, {
                    "name": "Frozen",
                    "color1": "#403B4A",
                    "color2": "#E7E9BB"
                }, {"name": "Mango Pulp", "color1": "#F09819", "color2": "#EDDE5D"}, {
                    "name": "Bloody Mary",
                    "color1": "#FF512F",
                    "color2": "#DD2476"
                }, {"name": "Aubergine", "color1": "#AA076B", "color2": "#61045F"}, {
                    "name": "Aqua Marine",
                    "color1": "#1A2980",
                    "color2": "#26D0CE"
                }, {"name": "Sunrise", "color1": "#FF512F", "color2": "#F09819"}, {
                    "name": "Purple Paradise",
                    "color1": "#1D2B64",
                    "color2": "#F8CDDA"
                }, {"name": "Sea Weed", "color1": "#4CB8C4", "color2": "#3CD3AD"}, {
                    "name": "Pinky",
                    "color1": "#DD5E89",
                    "color2": "#F7BB97"
                }, {"name": "Cherry", "color1": "#EB3349", "color2": "#F45C43"}, {
                    "name": "Mojito",
                    "color1": "#1D976C",
                    "color2": "#93F9B9"
                }, {"name": "Juicy Orange", "color1": "#FF8008", "color2": "#FFC837"}, {
                    "name": "Mirage",
                    "color1": "#16222A",
                    "color2": "#3A6073"
                }, {"name": "Steel Gray", "color1": "#1F1C2C", "color2": "#928DAB"}, {
                    "name": "Kashmir",
                    "color1": "#614385",
                    "color2": "#516395"
                }, {"name": "Electric Violet", "color1": "#4776E6", "color2": "#8E54E9"}, {
                    "name": "Venice Blue",
                    "color1": "#085078",
                    "color2": "#85D8CE"
                }, {"name": "Moss", "color1": "#134E5E", "color2": "#71B280"}, {
                    "name": "Shroom Haze",
                    "color1": "#5C258D",
                    "color2": "#4389A2"
                }, {"name": "Mystic", "color1": "#757F9A", "color2": "#D7DDE8"}, {
                    "name": "Pink Haze",
                    "color1": "#D70652",
                    "color2": "#FF025E"
                }, {"name": "Grown Early", "color1": "#0ba360", "color2": "#3cba92"}];
            }
            $scope.gradientTypes = {
                isTextBackgroundRadial: false,
                isShapeBackgroundRadial: false,
                isBackgroundRadial: false
            };
            $scope.areaDesignClipPaths = [];
            $scope.areaDesignZoomedClipPaths = [];
            $scope.areaDesignShapes = [];
            $scope.listFontSizeInPt = ['6', '8', '10', '12', '14', '16', '18', '21', '24', '28', '32', '36', '42', '48', '56', '64', '72', '80', '88', '96', '104', '120', '144', '288', '576', '1152'];
            if (angular.isDefined(NBDESIGNCONFIG.nbdesigner_default_font_sizes) && NBDESIGNCONFIG.nbdesigner_default_font_sizes != '') {
                var fontSizes = NBDESIGNCONFIG.nbdesigner_default_font_sizes.replace(/ /g, '');
                $scope.listFontSizeInPt = fontSizes.split(',');
            }
            if (angular.isDefined(NBDESIGNCONFIG.nbdesigner_min_font_size) && NBDESIGNCONFIG.nbdesigner_min_font_size != '') {
                var min = NBDESIGNCONFIG.nbdesigner_min_font_size * 1;
                $scope.listFontSizeInPt = $scope.listFontSizeInPt.filter(function (size) {
                    var size = size * 1;
                    return size >= min;
                });
            }
            if (angular.isDefined(NBDESIGNCONFIG.nbdesigner_max_font_size) && NBDESIGNCONFIG.nbdesigner_max_font_size != '') {
                var max = NBDESIGNCONFIG.nbdesigner_max_font_size * 1;
                $scope.listFontSizeInPt = $scope.listFontSizeInPt.filter(function (size) {
                    var size = size * 1;
                    return size <= max;
                });
            }
            $scope.forceMinSize = (NBDESIGNCONFIG.nbdesigner_force_min_font_size == 'yes') ? true : false;
            $scope.forceMaxSize = (NBDESIGNCONFIG.nbdesigner_force_max_font_size == 'yes') ? true : false;
            $scope.customTemplate = {
                name: '',
                type: '1',
                selectedTags: [],
                selectedColors: [],
                newColor: '#ffffff',
                showPicker: false,
                tags: [],
                tag_ids: [],
                reload: 0,
                template_thumb: null
            };
            /*advanced*/
            if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
                $scope.customTemplate.price = 0;
            }
            // advanced
            if (typeof nbd_color_clipart != 'undefined') {
                jQuery.ajax({
                    url: NBDESIGNCONFIG['ajax_url'],
                    method: "POST",
                    data: {'action': 'nbdesigner_add_clipart_color'},
                }).done(function (_data) {
                    var data = JSON.parse(_data);
                    if (data.fonts != null || data.fonts_custom != null) {
                        if (data.fonts_custom != null && data.fonts != null) {
                            var children = data.fonts.concat(data.fonts_custom);
                        }
                        if (data.fonts_custom != null && data.fonts == null) {
                            var children = data.fonts_custom;
                        }
                        if (data.fonts_custom == null && data.fonts != null) {
                            var children = data.fonts;
                        }
                        $scope.resource.font.data = children;
                        $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
                    }
                    if (NBDESIGNCONFIG['nbdesigner_hex_names'] == '' && data.color != null) {
                        var color = data.color;
                        var __colorPalette = [];
                        color = color.split(",");
                        for (var i = 0; i < color.length; ++i) {
                            var colors = color[i].split(':')[0];
                            __colorPalette.push(colors);
                        }
                        $scope.__colorPalette = __colorPalette;
                    }
                });
            }

            /*advanced*/
            if (typeof mctp_nbd_js_config_design != "undefined") {
                $scope.customTemplate.typeTemplate = '1';
            }
            if (NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template') {
                if (angular.isDefined(NBDESIGNCONFIG.product_data.template)) {
                    $scope.customTemplate.name = NBDESIGNCONFIG.product_data.template.name;
                    /*advanced*/
                    if (typeof mctp_nbd_js_config_design != "undefined") {
                        $scope.customTemplate.typeTemplate = NBDESIGNCONFIG.product_data.template.private;
                    }
                    /*advanced*/
                    if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
                        $scope.customTemplate.price = NBDESIGNCONFIG.product_data.template.price;
                    }
                    $scope.customTemplate.selectedTags = NBDESIGNCONFIG.product_data.template.tags.split(",").map(function (tag) {
                        return parseInt(tag);
                    });
                    if (NBDESIGNCONFIG.product_data.template.colors != '') {
                        $scope.customTemplate.selectedColors = NBDESIGNCONFIG.product_data.template.colors.split(",");
                    }
                }
            }
            if (angular.isDefined(NBDESIGNCONFIG.product_data.option.listFontSizeInPt)) {
                if (NBDESIGNCONFIG.product_data.option.listFontSizeInPt != '') {
                    NBDESIGNCONFIG.product_data.option.listFontSizeInPt = NBDESIGNCONFIG.product_data.option.listFontSizeInPt.replace(/ /g, '');
                    $scope.listFontSizeInPt = NBDESIGNCONFIG.product_data.option.listFontSizeInPt.split(',');
                }
            }
            ;
            // if( angular.isDefined( NBDESIGNCONFIG.product_data.config ) && NBDESIGNCONFIG.product_data.config !== null && angular.isDefined( NBDESIGNCONFIG.product_data.config.dpi ) && angular.isDefined( NBDESIGNCONFIG.product_data.config.option_dpi ) ){
            //     $scope.settings.product_data.option.dpi = NBDESIGNCONFIG.product_data.config.dpi;
            // }
            if ($scope.hasProductOption('dpi') && $scope.hasProductOption('option_dpi')) {
                $scope.settings.product_data.option.dpi = NBDESIGNCONFIG.product_data.config.dpi;
            }
            if ($scope.hasProductOption('unit')) {
                $scope.settings.nbdesigner_dimensions_unit = NBDESIGNCONFIG.product_data.config.unit;
            }
            if ($scope.hasProductOption('origin_product')) {
                $scope.settings.product_data.origin_product = NBDESIGNCONFIG.product_data.config.origin_product;
            }
            ;
            if ($scope.hasProductOption('areaDesignShapes')) {
                $scope.areaDesignShapes = NBDESIGNCONFIG.product_data.config.areaDesignShapes;
            }
            $scope.completedInsertTemplate = false;
            jQuery(document).triggerHandler('nbd_init_settings');
            $scope.changePrintingOptions(true);
            $scope.processProductSettings();
            $scope.productChangeOptions = {
                width: Number($scope.settings.product_data.product[0].product_width),
                height: Number($scope.settings.product_data.product[0].product_height),
                orientation: '0',
                unit: $scope.settings.nbdesigner_dimensions_unit,
                dpi: Number($scope.settings.product_data.option.dpi) || 300,
                applyToCurrentPage: false
            };
            $scope.resource = {
                defaultPalette: [
                    ['transparent', '#ffffff', '#000000', '#8D6E63', '#D9D9D9',
                        '#FF9800', '#FFEE58', '#66BB6A', '#26A69A', '#03A9F4',
                        '#3F51B5', '#673AB7', '#9C27B0', '#EC407A', '#FF5757',
                        '#FF66C4', '#38b6ff', '#5271ff', '#004aad', '#008037',
                        '#7ed957', '#c9e265', '#ffde59', '#ffbd59', '#ff914d'],
                ],
                brushPalette: [
                    ['#ffffff', '#000000', '#8D6E63', '#D9D9D9',
                        '#FF9800', '#FFEE58', '#66BB6A', '#26A69A', '#03A9F4',
                        '#3F51B5', '#673AB7', '#9C27B0', '#EC407A', '#FF5757',
                        '#FF66C4', '#38b6ff', '#5271ff', '#004aad', '#008037',
                        '#7ed957', '#c9e265', '#ffde59', '#ffbd59', '#ff914d'],
                ],
                backgroundPalette: [
                    /*Starter*/                                            ['#ffffff', '#D9D9D9', '#A6A6A6', '#737373', '#000000',
                        /*Red*/                                                 '#ffa2a2', '#ff8b8b', '#ff7373', '#ff5c5c', '#ff4545', '#ff2d2d', '#ff1616',
                        /*Coral-Red*/                                           '#ffbcbc', '#ffabab', '#ff9a9a', '#ff8989', '#ff7979', '#ff6868', '#ff5757',
                        /*Pink*/                                                '#ffc2e7', '#ffb3e2', '#ffa3dc', '#ff94d6', '#ff85d0', '#ff75ca', '#ff66c4',
                        /*Magenta*/                                             '#eac4f5', '#e5b6f3', '#e0a7f0', '#db98ee', '#d589eb', '#d07be9', '#cb6ce6',
                        /*Purple*/                                              '#d1baff', '#c6a9ff', '#ba97ff', '#af86ff', '#a375ff', '#9863ff', '#8c52ff',
                        /*Violet*/                                              '#bfa2f7', '#af8bf5', '#9e74f3', '#8e5df1', '#7e45ef', '#6e2eed', '#5e17eb',
                        /*Turquoise*/                                           '#9ad6d8', '#81cccf', '#68c1c5', '#4fb7bb', '#35adb1', '#1ca2a8', '#03989e',
                        /*Aqua*/                                                '#99e7ea', '#80e1e5', '#66dae0', '#4dd4db', '#33ced5', '#1ac8d0', '#00c2cb',
                        /*TBlue*/                                               '#bef3f5', '#aef0f3', '#9dedf0', '#8deaee', '#7de7eb', '#6ce4e9', '#5CE1E6',
                        /*LightBlue*/                                           '#afe2ff', '#9cdbff', '#88d3ff', '#74ccff', '#60c5ff', '#4cbdff', '#38b6ff',
                        /*RoyalBlue*/                                           '#bac6ff', '#a9b8ff', '#97aaff', '#869cff', '#758dff', '#637fff', '#5271ff',
                        /*ColbaltBlue*/                                         '#99b7de', '#80a5d6', '#6692ce', '#4d80c6', '#336ebd', '#1a5cb5', '#004aad',
                        /*Green*/                                               '#99ccaf', '#80c09b', '#66b387', '#4da673', '#33995f', '#1a8d4b', '#008037',
                        /*Grass*/                                               '#cbf0bc', '#bfecab', '#b2e89a', '#a5e489', '#98e179', '#8bdd68', '#7ed957',
                        /*Lime*/                                                '#e9f3c1', '#e4f1b2', '#dfeea3', '#d9eb93', '#d4e884', '#cee574', '#c9e265',
                        /*Yellow*/                                              '#fff2bd', '#ffefac', '#ffeb9b', '#ffe88b', '#ffe57a', '#ffe16a', '#ffde59',
                        /*Peach*/                                               '#ffe5bd', '#ffdeac', '#ffd79b', '#ffd18b', '#ffca7a', '#ffc46a', '#ffbd59',
                        /*Orange*/                                              '#ffd3b8', '#ffc8a6', '#ffbd94', '#ffb282', '#ffa771', '#ff9c5f', '#ff914d',
                        /*Brown*/                                               '#d1c5c1', '#c6b7b1', '#bba8a1', '#af9a92', '#a48b82', '#987d73', '#8d6e63'

                    ]
                ],
                social: {link: '', wa_link: '', type: '', images: [], design_link: ''},
                config: {},
                jsonDesign: {},
                usedFonts: [],
                imageFromUrl: '',
                svgCode: '',
                qrText: '',
                gapi: {},
                tempData: {template: []},
                templates: [],
                templateLimit: 24,
                myTemplates: [],
                myDesigns: [],
                cartTemplates: [],
                templateCats: [],
                templateSearch: {value: '', loading: false, focus: false},
                drawMode: {
                    status: false,
                    brushWidth: 1,
                    brushType: 'Pencil',
                    brushColor: NBDESIGNCONFIG.nbdesigner_default_color
                },
                personal: {status: false, type: ''},
                webcam: {status: false},
                typography: {filter: {perPage: 20, currentPage: 1, total: 0}, data: [], init: true, onload: false},
                photoFrame: {filter: {perPage: 20, currentPage: 0, total: 161}, data: [], init: true, onload: false},
                clipart: {
                    filter: {searchPerPage: 25, categoryPerPage: 10, perPage: 25, currentCat: {}},
                    data: [],
                    onload: false,
                    init: true,
                    filteredArts: []
                },
                clipart_all: {
                    filter: {searchPerPage: 25, categoryPerPage: 10, perPage: 25, currentCat: {}},
                    data: [],
                    onload: false,
                    init: true,
                    filteredArts: []
                },
                overlay_all: {
                    filter: {searchPerPage: 25, categoryPerPage: 10, perPage: 25, currentCat: {}},
                    data: [],
                    onload: false,
                    init: true,
                    filteredOverlays: []
                },
                font: {filter: {perPage: 10, currentPage: 1, total: 0}, data: [], filteredFonts: []},
                photo: {
                    filter: {perPage: 20, currentPage: 1, total: 0, totalPage: 1},
                    data: [],
                    init: true,
                    onload: false,
                    type: '',
                    photoSearch: '',
                    onclick: false,
                    color: null,
                    transparent: false,
                    orientation: 'all',
                    blackAndWhite: false
                },
                dropbox: {
                    filter: {perPage: 10, currentPage: 1, total: 0},
                    data: [],
                    onload: false,
                    init: true,
                    filteredPhoto: []
                },
                facebook: {
                    filter: {perPage: 20, currentPage: 1, total: 0},
                    data: [],
                    onload: false,
                    init: true,
                    nextUrl: '',
                    uid: '',
                    accessToken: ''
                },
                instagram: {
                    filter: {perPage: 24, currentPage: 1, total: 0},
                    data: [],
                    onload: false,
                    init: true,
                    token: '',
                    code: '',
                    uid: ''
                },
                upload: {
                    filter: {perPage: 20, currentPage: 1, total: 0},
                    data: [],
                    onload: false,
                    init: true,
                    ilr: false,
                    progressBar: 0
                },
                element: {onclick: false, onload: false, contentSearch: ''},
                shape: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                icon: {
                    filter: {perPage: 20, currentPage: 1, totalPage: 0, currentCat: null},
                    data: [],
                    cat: [],
                    init: true,
                    onload: false,
                    first: true
                },
                flaticon: {
                    filter: {perPage: 20, currentPage: 1, totalPage: 0},
                    data: [],
                    init: true,
                    onload: false,
                    token: '',
                    expires: ''
                },
                flaticonstickers: {
                    filter: {perPage: 20, currentPage: 1, totalPage: 0},
                    data: [],
                    init: true,
                    onload: false,
                    token: '',
                    expires: ''
                },
                storyset: {filter: {perPage: 30, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                svgrepo: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                pxillustrations: {
                    filter: {perPage: 20, currentPage: 1, totalPage: 0},
                    data: [],
                    init: true,
                    onload: false,
                    vectorOnly: false,
                    color: null,
                    transparent: false,
                    orientation: 'all',
                    blackAndWhite: false
                },
                iconscout: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                nounproject: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                iconfinder: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                line: {filter: {perPage: 20, currentPage: 1, totalPage: 0}, data: [], init: true, onload: false},
                globalTemplate: {
                    filter: {perPage: 20, currentPage: 1, totalPage: 0},
                    data: [],
                    init: true,
                    onload: false
                },
                templateType: 'custom',
                mockups: [],
                canAdd: true,
                frames: photoFrames.slice(0, 200),
                background: [],
                maps: {
                    address: '',
                    url: '',
                    loading: false,
                    zoom: '16',
                    width: 500,
                    height: 500,
                    maptype: 'roadmap',
                    format: 'jpg',
                    markers: {size: 'normal', color: '#ff5c5c', label: ''}
                },
                shareDesign: false,
                products: [],
                selectedCategoryItems: [],
                selectedOverlayCategoryItems: []
            };
            $scope.showPhotokitEditor = false;
            $scope.imageToOpenInPhotokit = null;
            if (typeof bagr_background != 'undefined') {
                /*advanced*/
                $scope.resource.background = {
                    filter: {perPage: 20, currentPage: 1, total: 0, currentCat: {}},
                    data: [],
                    onload: false,
                    init: true,
                    filteredBackgrounds: []
                }
                $scope.listBackgroundColor = $scope.resource.defaultPalette[0];
                if (angular.isDefined($scope.settings.nbes_settings.background_colors)) {
                    if ($scope.settings.nbes_settings.background_colors.codes.length > 0) {
                        $scope.listBackgroundColor = $scope.settings.nbes_settings.background_colors.codes;
                    }
                }
            }
            /*advanced*/
            if (typeof udc_nbd_js_config != "undefined") {
                $scope.resource.overlay = {
                    filter: {
                        searchPerPage: 25,
                        categoryPerPage: 10,
                        perPage: 25,
                        currentCat: {}
                    }, data: [], onload: false, init: true, filteredOverlays: []
                };
                $scope.settings.elementCustomize = NBDESIGNCONFIG.elementCustomize;
            }
            /*advanced*/
            if (typeof ssnb_nbd_js_config != 'undefined') {
                $scope.resource.block = {
                    filter: {perPage: 20, currentPage: 1, total: 0, currentCat: {}},
                    data: [],
                    onload: false,
                    init: true,
                    filteredBlocks: []
                }
            }
            if (angular.isDefined($scope.settings.template_tags) && $scope.settings.template_tags.length > 0) {
                $scope.resource.customTemplates = [];
                $scope.settings.template_tags.forEach(function (tag) {
                    $scope.resource.customTemplates[tag.id] = {
                        limit: 0,
                        total: tag.templates.length
                    }
                });
            }
            if ($scope.hasProductOption('qty')) {
                $scope.resource.config.qty = parseInt(NBDESIGNCONFIG.product_data.config.qty);
            }
            if ($scope.hasProductOption('fold')) {
                $scope.resource.config.fold = NBDESIGNCONFIG.product_data.config.fold;
                $scope.resource.config.foldClass = NBDESIGNCONFIG.product_data.config.foldClass;
                $scope.resource.config.numberPanel = NBDESIGNCONFIG.product_data.config.numberPanel;
            }
            $scope.cuzIncludeExport = ['first_name', 'last_name', 'full_name', 'company', 'address', 'postcode', 'city', 'phone', 'email', 'mobile', 'website', 'vcard', 'title', 'date', 'avatar'];
            $scope.includeExport = ['objectCaching', 'itemId', 'selectable', 'editable', 'lockMovementX', 'lockMovementY', 'lockScalingX', 'lockScalingY', 'lockRotation', 'rtl', 'elementUpload', 'forceLock', 'isBg', 'isBgImg', 'is_uppercase', 'available_color', 'available_color_list', 'color_link_group', 'isOverlay', 'isAlwaysOnTop', 'ilr', 'oos', 'evented', 'ptFontSize', 'origin_src', 'reverse', 'spacing', 'radius', 'field_mapping', 'isQrcode', 'qrContent', 'isBarcode', 'barCodeContent', 'v_card', 'isMask', 'maskId', 'strokeWidth', 'absolutePositioned', 'perPixelTargetFind', 'centeredScaling', 'origin_url', 'origin_width', 'origin_height', 'cropped', 'layerName', 'origin_pdf', 'isTemMask', 'srcChanged', 'isEmptyMask', 'lockMask', 'isList', 'offsetX', 'offsetY', 'crop', 'strokeWidthImage', 'strokeImage', 'subTargetCheck', 'linearGradientAngle', 'borderRadius'];
            //add oj checkBox
            if (typeof checkBox != 'undefined') {
                $scope.includeExport.push('valueOfinput', 'temporary', 'checkTexBox', 'lockFontEdit');
            }
            /*advanced*/
            if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                $scope.includeExport.push("lengthLimit", "sampleText", "termCodition");
            }

            if (appConfig.isCuz) {
                $scope.includeExport = $scope.includeExport.concat($scope.cuzIncludeExport);
            }
            if (angular.isDefined(NBDESIGNCONFIG.product_data.option.font_cats)) {
                $scope.settings.fonts = $scope.settings.fonts.filter(function (font) {
                    if (font.cat.length == 0) font.cat = ["0"];
                    return !font.cat.some(function (val) {
                        return NBDESIGNCONFIG.product_data.option.font_cats.indexOf(val) === -1 && val != "99"
                    });
                });
            }
            ;
            if (angular.isDefined($scope.settings.nbes_enable_settings) && $scope.settings.nbes_enable_settings.font == 1
                && angular.isDefined($scope.settings.nbes_settings) && angular.isDefined($scope.settings.nbes_settings.font_cats)) {
                $scope.settings.fonts = $scope.settings.fonts.filter(function (font) {
                    if (font.cat.length == 0) font.cat = ["0"];
                    return !font.cat.some(function (val) {
                        return $scope.settings.nbes_settings.font_cats.indexOf(val) === -1 && val != "99"
                    });
                });
            }
            $scope.resource.font.data = $scope.settings.fonts;
            if (!_.filter($scope.resource.font.data, ['alias', $scope.settings.default_font.alias]).length) {
                $scope.resource.font.data.push($scope.settings.default_font);
            }
            ;
            if (angular.isDefined($scope.settings.nbes_enable_settings) && angular.isDefined($scope.settings.nbes_settings)
                && $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined($scope.settings.nbes_settings.combination_colors)) {
                if (angular.isDefined(NBDESIGNCONFIG.product_data.config) && angular.isDefined(NBDESIGNCONFIG.product_data.config.combinationColor)) {
                    var colorIndex = NBDESIGNCONFIG.product_data.config.combinationColor;
                    if (angular.isDefined($scope.settings.nbes_settings.combination_colors.bg_codes[colorIndex])) {
                        $scope.currentCombinationColor = colorIndex;
                    }
                }
            }
            $scope.resource.templates = $scope.settings.templates;
            /*advanced*/
            if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
                if (angular.isDefined(NBDESIGNCONFIG['template_id'])) {
                    $scope.resource.templates.forEach(temp => {
                        if (temp.id == NBDESIGNCONFIG['template_id']) {
                            $scope.currentTemp = temp;
                        }
                    });
                }
            }
            if (($scope.resource.templates.length == 0 || NBDESIGNCONFIG.product_data.option.admindesign != "1" || (!$scope.isTemplateMode && $scope.settings.nbdesigner_hide_template_tab == 'yes')) && $scope.settings.nbdesigner_enable_text == 'yes') {
                $scope.getResource('typography', '#tab-typography');
            }
            if (NBDESIGNCONFIG.product_data.option.admindesign != "1" && $scope.settings.nbdesigner_enable_text == 'no' && $scope.settings.nbdesigner_enable_clipart == 'yes') {
                $scope.getResource('clipart', '#tab-svg', true);
            }
            ;
            if (typeof bagr_background != 'undefined') {
                /*advanced*/
                if (NBDESIGNCONFIG.product_data.option.admindesign != "1" && $scope.settings.nbdesigner_enable_text == 'no') {
                    $scope.getResource('background', '#tab-background', true);
                }
                ;
                $scope.$watchCollection('resource.background.filter', function (newVal, oldVal) {
                    $scope.resource.background.filteredBackgrounds = filterArtFilter($scope.resource.background.data.backgrounds, $scope.resource.background.filter);
                    if (newVal.search != oldVal.search) {
                        $timeout(function () {
                            jQuery("#tab-background .tab-scroll").stop().animate({
                                scrollTop: 0
                            }, 100);
                        });
                    }
                    $scope.onEndRepeat('background');
                }, true);
            }
            /*advanced*/
            if (typeof ssnb_nbd_js_config != 'undefined') {
                if (NBDESIGNCONFIG.product_data.option.admindesign != "1" && $scope.settings.nbdesigner_enable_text == 'no') {
                    $scope.getResource('block', '#tab-block', true);
                }
                ;
                $scope.$watchCollection('resource.block.filter', function (newVal, oldVal) {
                    $scope.resource.block.filteredBlocks = filterArtFilter($scope.resource.block.data.blocks, $scope.resource.block.filter);
                    if (newVal.search != oldVal.search) {
                        $timeout(function () {
                            jQuery("#tab-block .tab-scroll").stop().animate({
                                scrollTop: 0
                            }, 100);
                        });
                    }
                    $scope.onEndRepeat('block');
                }, true);
            }
            /*advanced*/
            if (typeof udc_nbd_js_config != "undefined") {
                if (NBDESIGNCONFIG.product_data.option.admindesign != "1" && $scope.settings.nbdesigner_enable_text == 'no') {
                    $scope.getResource('overlay', '#tab-overlay', true);
                }
                ;
                $scope.$watchCollection('resource.overlay.filter', function (newVal, oldVal) {
                    $scope.resource.overlay.filteredOverlays = filterArtFilter($scope.resource.overlay.data.overlays, $scope.resource.overlay.filter);
                    if (newVal.search != oldVal.search) {
                        $timeout(function () {
                            //     jQuery("#tab-overlay .tab-scroll").stop().animate({
                            //        scrollTop: 0
                            //    }, 100);
                        });
                    }
                    $scope.onEndRepeat('overlay');
                }, true);
                $scope.$watchCollection('resource.overlay_all.filter', function (newVal, oldVal) {
                    $scope.resource.overlay_all.filteredOverlays = filterArtFilter($scope.resource.overlay_all.data.overlays, $scope.resource.overlay_all.filter);
                    $scope.resource.overlay_all.filteredOverlaysCats = $scope.resource.overlay_all.filteredOverlays
                        .reduce((categories, overlay) => {
                            const category2 = overlay.cat[0];
                            if (!categories[category2]) {
                                categories[category2] = [];
                            }
                            categories[category2].push(overlay);
                            return categories;
                        }, {});
                }, true);
            }
            $scope.getOverlay();
            $scope.getClipart();
            if (NBDESIGNCONFIG.show_nbo_option) {
                $timeout(function () {
                    $scope.getPrintingOptions();
                }, 100);
            }
            if ($scope.settings.task != 'create_template' && NBDESIGNCONFIG.product_data.option.admindesign == "1"
                && NBDESIGNCONFIG.product_data.option.global_template == "1"
                && NBDESIGNCONFIG.product_data.option.global_template_cat != "") {
                var cid = parseInt(NBDESIGNCONFIG.product_data.option.global_template_cat);
                $scope.templateCat = cid;
                $scope.loadGlobalTemplate(cid, true);
            }
            $scope.resource.font.filter.total = $scope.resource.font.data.length;
            $scope.$watchCollection('resource.font.filter', function (newVal, oldVal) {
                if (newVal.search != oldVal.search) {
                    $timeout(function () {
                        jQuery("#toolbar-font-familly-dropdown").stop().animate({
                            scrollTop: 0
                        }, 100);
                    });
                }
                $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
            }, true);
            $scope.$watchCollection('resource.clipart.filter', function (newVal, oldVal) {
                $scope.resource.clipart.filteredArts = filterArtFilter($scope.resource.clipart.data.arts, $scope.resource.clipart.filter);
                if (newVal.search != oldVal.search) {
                    $timeout(function () {
                        jQuery("#tab-svg .tab-scroll").stop().animate({
                            scrollTop: 0
                        }, 100);
                    });
                }
                $scope.onEndRepeat('clipart');
            }, true);
            if ((NBDESIGNCONFIG.ui_mode == '2' && NBDESIGNCONFIG.task2 == 'update' && NBDESIGNCONFIG.nbdesigner_hide_print_option_in_editor == 'yes') || angular.isDefined(NBDESIGNCONFIG.force_hide_print_option)) {
                $scope.autoApplyOptions = false;
                $scope.$watch('printingOptionsAvailable', function (newVal, oldVal) {
                    if (newVal === true && !$scope.autoApplyOptions) {
                        $scope.autoApplyOptions = true;
                        $scope.applyOptions();
                    }
                }, true);
            }
            ;
            if (appConfig.autoSave && NBDESIGNCONFIG.is_logged == 1) {
                $timeout(function () {
                    $interval(function () {
                        if (!$scope.onloadTemplate && !$scope.onLoadPrintingOptions) $scope.saveData('save_draft');
                    }, 18E4);
                }, 6E4);
            }
            $scope.settings.dynamicStage = (angular.isDefined($scope.settings.product_data.option.dynamic_side) && $scope.settings.product_data.option.dynamic_side == "1" && !$scope.isTemplateMode) ? true : false;
            $scope.settings.maxNoOfStage = 999;
            $scope.settings.minNoOfStage = 1;
            $scope.settings.canSwapStage = true;
            $scope.settings.gridViewMode = false;
            $scope.settings.enableImageFilter = (NBDESIGNCONFIG.nbdesigner_modern_layout_image_filter == 'yes' && NBDESIGNCONFIG.nbdesigner_enable_cloud2print_api == 'yes') ? true : false;
            $scope.availableFilters = ['blur', 'desaturate', 'contrast', 'sepiatone', 'hue', 'luminance', 'colorize', 'posterize', 'darken', 'lighten', 'invert'];
            $scope.initSearchTempalte();
        };

        $scope.hasProductOption = function (option) {
            if (!NBDESIGNCONFIG) {
                return false;
            }
            return NBDESIGNCONFIG.product_data.config !== null && angular.isDefined(NBDESIGNCONFIG.product_data.config) && angular.isDefined(NBDESIGNCONFIG.product_data.config[option]);
        }
        $scope.loadMoreCustomTemplates = function () {
            if ($scope.resource.templateType == 'custom' && angular.isDefined($scope.resource.currentTemTagId)) {
                if (angular.isDefined($scope.resource.customTemplates[$scope.resource.currentTemTagId])) {
                    if ($scope.resource.customTemplates[$scope.resource.currentTemTagId].limit < $scope.resource.customTemplates[$scope.resource.currentTemTagId].total) {
                        $scope.resource.customTemplates[$scope.resource.currentTemTagId].limit += 24;
                    }
                }
            }
        };

        $scope.backTemplate = function () {
            jQuery("#tab-template .tab-scroll").stop().animate({
                scrollTop: 0
            }, 100);
        }
        $scope.searchTemplate = function () {
            if ($scope.resource.templateSearch.value == '') {
                $scope.activeTag = false;
                if (!($scope.settings.nbdesigner_display_template_mode == '2' && $scope.settings.template_tags.length)) {
                    $scope.resource.templates = $scope.resource._templates || $scope.resource.templates;
                    $timeout(function () {
                        jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
                    });
                }
                return;
            }
            $scope.resource.templateSearch.loading = true;
            NBDDataFactory.get('nbd_search_template', {
                product_id: NBDESIGNCONFIG['product_id'],
                variation_id: NBDESIGNCONFIG['variation_id'],
                search: $scope.resource.templateSearch.value
            }, function (data) {
                var _data = JSON.parse(data);

                if (angular.isDefined(_data.tag)) {
                    if ($scope.settings.nbdesigner_display_template_mode == '2' && $scope.settings.template_tags.length) {
                        if (_data.tag != '') {
                            $scope.activeTemplateTag(_data.tag);
                        } else if (_data.templates.length) {
                            var issetUnTag = false, wait = 0;
                            $scope.settings.template_tags.forEach(function (tag) {
                                if (tag.id == 0) issetUnTag = true;
                            });

                            if (issetUnTag) {
                                $scope.resource._unTagTemplates = $scope.resource._unTagTemplates || $scope.settings.template_tags[0].templates;
                                $scope.settings.template_tags[0].templates = _data.templates;
                            } else {
                                $scope.settings.template_tags.unshift({
                                    id: 0,
                                    templates: _data.templates,
                                    thumb: NBDESIGNCONFIG.assets_url + 'images/template.png',
                                    name: NBDESIGNCONFIG.nbdlangs.templates
                                });
                                $scope.resource.customTemplates[0] = {
                                    limit: 24,
                                    total: _data.templates.length
                                };

                                if (jQuery('#tab-template .result-loaded').hasClass('loaded')) {
                                    wait = 100;
                                    jQuery('[data-type="tags-0"]').click();
                                }

                                $timeout(function () {
                                    var itemInRow = 3, itemDistance = 10,
                                        $items = jQuery('#tab-template').find('.items'),
                                        $item = jQuery('#tab-template').find('.item'),
                                        $resultLoaded = jQuery('#tab-template').find('.result-loaded'),
                                        $mainItems = jQuery('#tab-template').find('.main-items'),
                                        $contentItem = jQuery('#tab-template').find('.result-loaded .content-item'),
                                        $galleryItem = jQuery('#tab-template').find('.nbdesigner-gallery'),
                                        $contentItem = jQuery('#tab-template').find('.result-loaded .content-item'),
                                        noItem = $item.length,
                                        noItemRow = parseInt(noItem / itemInRow),
                                        itemHeight = $item.outerHeight() + itemDistance;

                                    if (jQuery('#tab-template .result-loaded').hasClass('loaded')) {
                                        wait = 100;
                                        jQuery('[data-type="tags-0"]').click();
                                    }

                                    function initPositionItem() {
                                        var leftItem = $items.width() / itemInRow;
                                        var topItem = $item.height() + itemDistance;
                                        $item.show();

                                        $item.each(function () {
                                            var index = jQuery(this).index();
                                            var indexMod = index % itemInRow;
                                            var indexI = parseInt(index / itemInRow);
                                            jQuery(this).css({
                                                'left': leftItem * indexMod + 'px',
                                                'top': topItem * indexI + 'px'
                                            });
                                        });
                                    }

                                    initPositionItem();

                                    jQuery($item[0]).on('click', function () {
                                        var indexItem = jQuery(this).index();
                                        var indexItemRow = parseInt(indexItem / itemInRow) + 1;
                                        var widthItem = jQuery(this).outerWidth();
                                        var dataType = jQuery(this).attr('data-type');

                                        $mainItems.css({
                                            'height': indexItemRow * (itemHeight - 15) + 'px'
                                        });
                                        $mainItems.find('.pointer').css({
                                            'left': ((widthItem) * (indexItem % itemInRow + 1) - widthItem / 2) + 'px'
                                        });

                                        $resultLoaded.show().addClass('overflow-visible');
                                        $contentItem.filter(function (index) {
                                            return jQuery(this).attr('data-type') === dataType;
                                        }).show().find('input[type="text"]').first().focus();
                                        $galleryItem.hide();
                                        if (!$mainItems.hasClass('active-expanded')) {
                                            jQuery(this).siblings().css({
                                                'opacity': '0.5'
                                            });
                                            $mainItems.addClass('active-expanded');
                                            $resultLoaded.addClass('loaded');
                                            var nextAllItem = $items.find('.item:nth-child(' + indexItemRow * itemInRow + ')').nextAll();
                                            jQuery(nextAllItem).each(function () {
                                                jQuery(this).hide();
                                            });
                                        } else {
                                            jQuery(this).css({
                                                'opacity': '1'
                                            });
                                            jQuery(this).siblings().css({
                                                'opacity': '1'
                                            });
                                            $mainItems.removeClass('active-expanded');
                                            initPositionItem();
                                            $resultLoaded.hide();
                                            $contentItem.hide();
                                            $resultLoaded.removeClass('loaded');
                                        }
                                    });
                                });
                            }

                            $timeout(function () {
                                $scope.activeTemplateTag(0);
                            }, wait);
                        } else {
                            $scope.resource.templateSearch.loading = false;
                        }
                    } else {
                        $scope.resource._templates = $scope.resource._templates || $scope.resource.templates;
                        $scope.resource.templates = _data.templates;
                        $scope.resource.templateLimit = 24;
                        $timeout(function () {
                            jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
                        });
                        $scope.resource.templateSearch.loading = false;
                    }
                } else {
                    $scope.resource.templateSearch.loading = false;
                }
            });
        };
        $scope.activeTemplateTag = function (tagId) {
            if ($scope.settings.nbdesigner_display_template_mode == '2' && $scope.settings.template_tags.length) {
                $timeout(function () {
                    if (jQuery('#tab-template .result-loaded').hasClass('loaded')) {
                        jQuery('[data-type="tags-' + tagId + '"]').click();
                        $timeout(function () {
                            jQuery('[data-type="tags-' + tagId + '"]').click();
                            $scope.resource.templateSearch.loading = false;
                        }, 300);
                    } else {
                        jQuery('[data-type="tags-' + tagId + '"]').click();
                        $scope.resource.templateSearch.loading = false;
                    }
                });
            } else {
                $scope.activeTag = true;
                $scope.searchTemplate();
            }
        };
        /*advanced*/
        if (typeof kcnb_nbd_js_config != "undefined") {
            $scope.popupTextSaveDesign = function () {
                jQuery('.nbd-popup.popup-nba-text').nbShowPopup();
            }
        }
        /*advanced*/
        if (typeof ssnb_nbd_js_config != "undefined") {
            $scope.popupNameSaveForLate = function () {
                jQuery('.nbd-popup.popup-nba-name-save-for-late').nbShowPopup();
            }
        }
        $scope.prepareSearchTemplate = function ($event) {
            // if( $event.keyCode == 13 ){
            //     // $scope.activeTag = true;
            //     // $scope.searchTemplate();
            // }else{
            //     if( $scope.resource.templateSearch.value == '' ) {
            //     $scope.activeTag = true;
            //         $timeout(function() {
            //             $scope.resource.templateSearch.focus = true;
            //             if( $scope.settings.nbdesigner_display_template_mode == '2' && $scope.settings.template_tags.length ){
            //                 $scope.settings.template_tags[0].templates = $scope.resource._unTagTemplates || $scope.settings.template_tags[0].templates;
            //             }else{
            //                 $scope.resource.templates = $scope.resource._templates || $scope.resource.templates;
            //                 $scope.resource.templateLimit = 24;
            //                 $timeout(function() {
            //                     jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
            //                 });
            //             }
            //         });
            //     }else{
            //         $scope.resource.templateSearch.focus = false;
            //     }
            // }
        };
        $scope.handleSearchTemplateQueryChanged = function (e) {
            if ($scope.resource.templateSearch.value) {
                $scope.activeTag = true;
                $scope.searchTemplate();
            } else {
                $scope.searchTemplate();
            }
        }
        $scope.backToAllTemplates = function () {
            $scope.activeTag = false;
            $scope.resource.templateSearch.value = '';
            $scope.searchTemplate();
            $scope.backTemplate();
        }
        $scope.initSearchTempalte = function () {
            if (angular.isDefined($scope.settings.template_tags) && $scope.settings.template_tags.length) {
                source = $scope.settings.template_tags.map(function (tag) {
                    return {
                        label: tag.name,
                        value: tag.id
                    };
                });

                jQuery("#nbd-search-template").autocomplete({
                    source: source,
                    select: function (event, ui) {
                        event.preventDefault();
                        $scope.resource.templateSearch.value = ui.item.label;
                        $scope.activeTemplateTag(ui.item.value);
                    },
                    focus: function (event, ui) {
                        event.preventDefault();
                        $scope.resource.templateSearch.value = ui.item.label;
                    }
                });
            }

            jQuery(document).on("click", function (event) {
                var suggetTagEl = jQuery('.nbd-suggest-tag');
                var searchTagEl = jQuery('#nbd-search-template');
                if (suggetTagEl.has(event.target).length == 0 && !suggetTagEl.is(event.target) && searchTagEl.has(event.target).length == 0 && !searchTagEl.is(event.target)) {
                    if ($scope.resource.templateSearch.focus) $scope.resource.templateSearch.focus = false;
                }
            });
        };
        $scope.updateQtys = function () {
            $scope.resource.config.qty = _.sumBy($scope.resource.config.qtys, function (qty) {
                return qty;
            });
            var hasVariation = false;
            if (!!$scope.resource.config.variations) {
                angular.forEach($scope.resource.config.variations, function (variation, key) {
                    variation.qty = 0;
                });
                hasVariation = true;
            }
            angular.forEach($scope.resource.config.qtys, function (qty, key) {
                if (qty.variation > -1) {
                    $scope.resource.config.variations[qty.variation] += qty.value;
                }
            });
            if (NBDESIGNCONFIG.ui_mode == 1) {
                if (hasVariation) {
                    nbd_window.NBDESIGNERPRODUCT.updateQty($scope.resource.config.qty, $scope.resource.config.variations);
                } else {
                    nbd_window.NBDESIGNERPRODUCT.updateQty($scope.resource.config.qty);
                }
            }
        };
        /*advanced*/
        if (typeof ctcs_nbd_js_config_design != "undefined" || typeof bagr_background != "undefined") {
            $scope.addColorBackground = function (color) {
                var _color = angular.isDefined(color) ? color : $scope.backgroundColor;
                $scope.listBackgroundColor.push(_color);
                $scope.listBackgroundColor = _.uniq($scope.listBackgroundColor);
            }
        }
        $scope.addColor = function (color) {
            var _color = angular.isDefined(color) ? color : $scope.currentColor;
            $scope.listAddedColor.push(_color);
            $scope.listAddedColor = _.uniq($scope.listAddedColor);
            jQuery('.nbd-perfect-scroll').perfectScrollbar('update');
        };
        $scope.showCanvasBackgroundPalette = function () {
            $scope.showCanvasBackgroundColorPicker = !$scope.showCanvasBackgroundColorPicker;
        }
        $scope.showShadowPalette = function () {
            $scope.showBrushShadowColorPicker = !$scope.showBrushShadowColorPicker;
        };
        $scope.showShadowPaletteText = function () {
            $scope.showBrushShadowTextColorPicker = !$scope.showBrushShadowTextColorPicker;
        };
        $scope.showStrokePalette = function () {
            $scope.showBrushStrokeColorPicker = !$scope.showBrushStrokeColorPicker;
        };
        $scope.onPathColorPalleteClick = function (index, color) {
            $scope.stages[$scope.currentStage].states.svg.currentPath = index;
            $scope.applySpectrumColor($scope.stages[$scope.currentStage].states.safeGradientValue || color);
        };
        $scope.applySpectrumColor = function (color = '#ffffff') {
            $scope.currentColor = color;
        };

        $scope.applySpectrumStrokeColor = function (color = '#ffffff') {
            $scope.currentStrokeColor = color;
        };

        $scope.applySpectrumShadowColor = function (color = '#ffffff') {
            $scope.currentShadowColor = color;
        }

        $scope.applyStrokeWidth = function (width = 0) {
            $scope.svgstroke = width;
        }

        $scope.applyShapeBorderRadius = function (borderRadius = {
            radius: 0,
            leftTop: 0,
            rightTop: 0,
            rightBottom: 0,
            leftBottom: 0
        }) {
            const {radius, leftTop, rightTop, rightBottom, leftBottom} = borderRadius;
            $scope.shapeBorderRadius = radius || 0;
            $scope.shapeSideBorderRadius = {leftTop, rightTop, rightBottom, leftBottom};
        }

        $scope.applyImageBorderRadius = function (borderRadius = {
            radius: 0,
            leftTop: 0,
            rightTop: 0,
            rightBottom: 0,
            leftBottom: 0
        }) {
            const {radius, leftTop, rightTop, rightBottom, leftBottom} = borderRadius;
            $scope.imageBorderRadius = radius || 0;
            $scope.imageSideBorderRadius = {leftTop, rightTop, rightBottom, leftBottom};
        }

        $scope.applyStrokeColor = function (color = '#ffffff') {
            if ($scope.stages[$scope.currentStage].states.svgobj) {
                $scope.stages[$scope.currentStage].states.svgobj.stroke = color;
            } else {
                $scope.stages[$scope.currentStage].states.svgobj = {
                    stroke: color
                };
            }
            $scope.applySpectrumStrokeColor(color);
        }

        $scope.applyShadowColor = function (shadow) {
            if (!shadow) {
                return;
            }
            jQuery('.shadowcolor').css('background', shadow.color);
            $scope.offsetX = shadow.offsetX || 0;
            $scope.offsetY = shadow.offsetY || 0;
            $scope.blur = shadow.blur || 0;
            $scope.applySpectrumShadowColor(shadow.color);
        }

        $scope.showTextColorPalette = function () {
            $scope.showTextColorPicker = !$scope.showTextColorPicker;
        };
        $scope.showBgColorPalette = function () {
            $scope.showBgColorPicker = !$scope.showBgColorPicker;
        };
        $scope.hasGetUserMedia = function () {
            return !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia || navigator.msGetUserMedia);
        };
        $scope.settings = {};
        $scope.init = function () {
            appConfig.init();
            document.addEventListener("mousedown", ({clientX, clientY}) => {
                $scope.lastClick = {
                    clientX,
                    clientY
                };
            });
            document.addEventListener("mouseup", () => {
                $scope.lastClick = null;
            })
            $scope.movableMasks = [];
            $scope.localStore.init();
            if (typeof nbd_window.NBDESIGNERPRODUCT != 'undefined') {
                nbd_window.NBDESIGNERPRODUCT.hide_loading_iframe();
            }
            ;
            $scope.isTemplateMode = NBDESIGNCONFIG.task === 'create' || (NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template');
            $scope.initSettings();
            $scope.contextAddLayers = 'normal';
            $scope.workBenchHeight = $window.innerHeight;
            $scope.workBenchWidth = $window.innerWidth;
            $timeout(function () {
                jQuery('.nbd-load-page').hide();
                if (appConfig.isModern) {
                    window.initModernLayout();
                } else if (appConfig.isVisual) {
                    window.initVisualLayout();
                }
                ;
                $scope.initDropboxChooser();
            });
            var _window = angular.element($window);
            _window.bind('resize', function () {
                /* to do: resize design */
                $scope.reCalcViewPort();
            });
            $scope.fullScreenMode = false;
            var _document = angular.element($document);
            _document.bind('webkitfullscreenchange mozfullscreenchange fullscreenchange MSFullscreenChange', function () {
                $scope.fullScreenMode = !$scope.fullScreenMode;
                jQuery("body").toggleClass("fullScreenMode");
                $timeout(function () {
                    $scope.toggleStageFullScreenMode();
                });
            });
            /* real time update printing option */
            var _intervalOptions = $interval(function () {
                if ($scope.awaitInsertTemplate) {
                    if (typeof nbd_customize_option_color != 'undefined') {
                        $scope.getPrintingOptions();
                    }
                    $scope.changePrintingOptions();
                }
            }, 100);
            var log = "c" + "o" + "n" + "s" + "o" + "l" + "e.i" + "n" + "f" + "o('%cP" + "o" + "we" + "r" + "e" + "d b" + "y %cP" + "L" + "A" + "S" + "F" + "Y%cT" + "E" + "A" + "M', 'color: orange; font-size: 20px;', 'color: red; font-size: 20px;', 'color: green; font-size: 20px;')";
            []["filter"]["constructor"](log)();
            if ($scope.settings.valid_license == '0') {
                (function (url) {
                    var image = new Image();
                    image.onload = function () {
                        var style = [
                            'font-size: 1px;',
                            'line-height: ' + this.height + 'px;',
                            'padding: ' + 0 * .5 + 'px ' + this.width * .5 + 'px;',
                            'background-size: ' + this.width + 'px ' + this.height + 'px;',
                            'background: url(' + url + ');'
                        ].join(' ');
                        console.group('%c' + 'W' + 'e' + 'l' + 'c' + 'o' + 'm' + 'e' + '! \ud83d\ude4c', 'font-size: 20px;');
                        console.log('%c ', style);
                        console.log('%ch' + 't' + 't' + 'p' + 's' + ':' + '/' + '/' + 'p' + 'l' + 'a' + 's' + 'f' + 'y' + '.' + 'c' + 'o' + 'm', 'font-size: 20px;');
                        console.groupEnd();
                    };
                    image.src = url;
                })('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiPgogIDxwYXRoIHN0eWxlPSJzdHJva2U6bm9uZTtmaWxsLXJ1bGU6bm9uemVybztmaWxsOiMwMDA7ZmlsbC1vcGFjaXR5OjEiIGQ9Ik0xMiAyNGExMS45MiAxMS45MiAwIDAgMS04LjQ4NC0zLjUxNkExMS45MiAxMS45MiAwIDAgMSAwIDEyYTExLjkyIDExLjkyIDAgMCAxIDMuNTE2LTguNDg0QTExLjkyIDExLjkyIDAgMCAxIDEyIDBhMTEuOTIgMTEuOTIgMCAwIDEgOC40ODQgMy41MTZBMTEuOTIgMTEuOTIgMCAwIDEgMjQgMTJhMTEuOTIgMTEuOTIgMCAwIDEtMy41MTYgOC40ODRBMTEuOTIgMTEuOTIgMCAwIDEgMTIgMjRabTAtMjIuMTI1QzYuNDE4IDEuODc1IDEuODc1IDYuNDE4IDEuODc1IDEyUzYuNDE4IDIyLjEyNSAxMiAyMi4xMjUgMjIuMTI1IDE3LjU4MiAyMi4xMjUgMTIgMTcuNTgyIDEuODc1IDEyIDEuODc1Wm00LjkzOCAxNS4wNjMtMS4zMjUtMS4zMjVhNS4xMTYgNS4xMTYgMCAwIDEtNy4yMjYgMCA1LjExNiA1LjExNiAwIDAgMSAwLTcuMjI2IDUuMTE2IDUuMTE2IDAgMCAxIDcuMjI2IDBsMS4zMjUtMS4zMjVhNi45OSA2Ljk5IDAgMCAwLTkuODc1IDAgNi45OSA2Ljk5IDAgMCAwIDAgOS44NzVBNi45NDkgNi45NDkgMCAwIDAgMTIgMTguOThhNi45NSA2Ljk1IDAgMCAwIDQuOTM4LTIuMDQzWm0wIDAiLz4KPC9zdmc+Cg==');
            }
            jQuery(document).triggerHandler('nbd_app_loaded');
            // NBD template ai to svg
            if (typeof nbptemp_ai_to_svg != "undefined") {
                var paramsString = window.location.href;
                var searchParams = new URLSearchParams(paramsString);
                var url = searchParams.get("src");
                if (searchParams.has("src")) {
                    $http({
                        method: "GET",
                        url: url
                    }).then(function mySuccess(response) {
                        var result = response.data;
                        $scope.addSvgFromString(result);
                    });
                }
            }
        };
        /*advanced*/
        if (typeof udc_nbd_js_config != "undefined") {
            $scope.imageupload = '';
            $scope.filterUserUpload = function (e) {
                var value = e.target.value.toLowerCase();
                angular.forEach($scope.resource.upload.data, function (e) {
                    if (e.name.toLowerCase().indexOf(value) === -1) {
                        e.show = false;
                    } else {
                        e.show = true;
                    }
                });
                $scope.renderMasonryList('upload', '#nbd-upload-wrap .mansory-wrap', '.mansory-item', '#nbd-upload-wrap', $scope.resource['upload'].init);
            };
        }
        /* Util */
        $scope.initDropboxChooser = function () {
            var options = {
                success: function (files) {
                    $scope.getPersonalPhoto('dropbox', files);
                    $scope.updateApp();
                },
                linkType: "direct",
                multiselect: true,
                extensions: ['.jpg', '.jpeg', '.png']
            };
            if (NBDESIGNCONFIG['enable_dropbox'] && $scope.settings.nbdesigner_enable_image == 'yes') {
                var button = Dropbox.createChooseButton(options);
                document.getElementById("nbdesigner_dropbox").appendChild(button);
            }
            ;
        };
        $scope.localStore = {
            db: null,
            ready: false,
            existed: true,
            numberOfRecords: 0,
            init: function () {
                var self = this;
                var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;
                if (indexedDB) {
                    var open = indexedDB.open("NBDesigner", 1);
                    if (open == null) return;
                    open.onsuccess = function (e) {
                        self.db = e.target.result;
                        self.ready = true;
                    };
                    open.onupgradeneeded = function (event) {
                        var db = event.target.result;
                        var objectStore = db.createObjectStore("designs", {keyPath: "id"});
                        self.existed = false;
                    };
                    open.onerror = function (event) {
                        console.log(event);
                    };
                }
            },
            add: function (pid, data, callback) {
                if (this.ready) {
                    var request = this.db.transaction(["designs"], "readwrite").objectStore("designs").add({
                        id: pid,
                        data: data
                    });
                    request.onsuccess = function (event) {
                        if (typeof callback == 'function') callback();
                    };
                }
            },
            update: function (pid, data, callback) {
                if (this.ready) {
                    var objectStore = this.db.transaction(["designs"], "readwrite").objectStore("designs");
                    var request = objectStore.get(pid);
                    request.onsuccess = function (event) {
                        var _data = event.target.result;
                        if (_data) {
                            _data.data = data;
                        } else {
                            _data = {id: pid, data: data};
                        }
                        var requestUpdate = objectStore.put(_data);
                        requestUpdate.onsuccess = function (event) {
                            if (typeof callback == 'function') callback();
                        };
                    };
                    request.onerror = function (event) {
                        console.log(event);
                    };
                }
            },
            count: function () {
                var self = this;
                if (this.ready) {
                    var transaction = this.db.transaction(["designs"]);
                    var objectStore = transaction.objectStore("designs");
                    var countRequest = objectStore.count();
                    countRequest.onsuccess = function () {
                        self.numberOfRecords = countRequest.result;
                    };
                }
            },
            get: function (pid, callback) {
                if (this.ready) {
                    var transaction = this.db.transaction(["designs"]);
                    var objectStore = transaction.objectStore("designs");
                    var request = objectStore.get(pid);
                    request.onsuccess = function (event) {
                        if (typeof callback == 'function') {
                            callback(event.target.result);
                        }
                    };
                    request.onerror = function (event) {
                        console.log(event);
                    };
                }
            },
            delete: function (pid, callback) {
                if (this.ready) {
                    var request = this.db.transaction(["designs"], "readwrite").objectStore("designs").delete(pid);
                    request.onsuccess = function (event) {
                        callback();
                    };
                }
            }
        };
        $scope._localStorage = {
            save: function (type, value) {
                if (type == 'nbduploaded') {
                    value = JSON.stringify($scope.resource.upload.data);
                }
                localStorage.setItem(type, value);
            },
            get: function (type) {
                var data = localStorage.getItem(type);
                if (data) {
                    return JSON.parse(data);
                } else {
                    return [];
                }
            },
            delete: function (type) {
                if (type == 'nbduploaded') {
                    $scope.resource.upload.data = [];
                    $scope.updateApp();
                }
                localStorage.setItem(type, JSON.stringify([]));
            }
        };
        $scope.generateUniqueId = function () {
            return '_' + Math.random().toString(36).substr(2, 9);
        };
        /* Get Data */
        $scope.getResource = function (type, container, callback) {
            if (type == 'typography' && $scope.settings.nbdesigner_hide_typo_section == 'yes') return;
            if ($scope.resource[type].data.length || angular.isUndefined($scope.resource[type].data.length)) return;
            jQuery(container + ' .loading-photo').show();
            NBDDataFactory.get('nbd_get_resource', {type: type, task: $scope.settings.task}, function (data) {
                var worker = new Worker('/wp-content/plugins/plasfy/assets/js/jsonParser.js');
                worker.addEventListener('message', function (e) {
                    if (e.data.success) {
                        const _data = e.data.result;
                        jQuery(container + ' .loading-photo').hide();
                        if (type === 'overlay') {
                            _data.data.cat = $scope.turnObjectIntoArray(_data.data.cat);
                        }
                        $scope.resource[type].data = _data.data;
                        $scope.resource[type].filter.total = $scope.resource[type].data.length;
                        if (callback) $scope.afterGetResource(type);
                    } else {
                        console.error('Error parsing JSON: ' + e.data.error);
                    }
                }, false);

                worker.postMessage(data);
            });
        };

        $scope.turnObjectIntoArray = function (object) {
            if (!object || Array.isArray(object)) {
                return object;
            }

            return Object.values(object);
        }

        $scope.getOverlay = function (type = 'overlay_all') {
            $scope.toggleStageLoading();
            if ($scope.resource[type].data.length || angular.isUndefined($scope.resource[type].data.length)) return;
            NBDDataFactory.get('nbd_get_resource', {type: type, task: $scope.settings.task}, function (data) {
                var _data = JSON.parse(data);
                if (_data.data.cat) {
                    _data.data.cat = $scope.turnObjectIntoArray(_data.data.cat);
                }
                $scope.resource[type].data = _data.data;
                $scope.resource[type].filter.total = $scope.resource[type].data.length;
                $scope.afterGetResource(type);
                $scope.toggleStageLoading();
            });
        };
        $scope.getClipart = function (type = 'clipart_all') {
            $scope.toggleStageLoading();
            if ($scope.resource[type].data.length || angular.isUndefined($scope.resource[type].data.length)) return;
            NBDDataFactory.get('nbd_get_resource', {type: type, task: $scope.settings.task}, function (data) {
                var _data = JSON.parse(data);
                $scope.resource[type].data = _data.data;
                $scope.resource[type].filter.total = $scope.resource[type].data.length;
                $scope.afterGetResource(type);
                $scope.toggleStageLoading();
            });
        };
        $scope.onClickTab = function (type, tab, ignoreDisableOnClick = true, isBgTab = false) {
            const onClickName = isBgTab ? 'bgonclick' : 'onclick';
            if ((ignoreDisableOnClick && !DUPLICATED_PHOTOS_TABS.includes(type)) || (!ignoreDisableOnClick && DUPLICATED_PHOTOS_TABS.includes(type))) {
                $scope.resource[tab][onClickName] = !$scope.resource[tab][onClickName];
            }
            if (!$scope.resource.photo[onClickName]) jQuery('#tab-' + tab + ' .loading-photo').hide();
            $scope.disableDrawMode();
            switch (type) {
                case 'dropbox':
                case 'facebook':
                case 'instagram':
                case 'upload':
                case 'url':
                    $scope.resource.element.type = null;
                    if (type == 'upload') {
                        if ($scope.settings.nbdesigner_cache_uploaded_image == 'yes' && $scope.resource.upload.data.length == 0) {
                            $scope.resource.upload.data = $scope._localStorage.get('nbduploaded');
                            $scope.resource.upload.filter.total = $scope.resource.upload.data.length;
                            /*advanced*/
                            if (typeof udc_nbd_js_config != "undefined") {
                                if ($scope.settings.nbod_image_customize == null && $scope.settings.is_logged != '1') {
                                    $scope.resource.upload.data = $scope._localStorage.get('nbduploaded');
                                    $scope.resource.upload.filter.total = $scope.resource.upload.data.length;
                                } else {
                                    $scope.resource.upload.data = $scope.settings.nbod_image_customize ? $scope.settings.nbod_image_customize : [];
                                }
                            }
                        }
                        ;
                    }
                    ;
                    $timeout(function () {
                        if (type != 'url' && $scope.resource[tab].onclick) {
                            $scope.renderMasonryList(type, '#nbd-' + type + '-wrap .mansory-wrap', '.mansory-item', '#nbd-' + type + '-wrap', $scope.resource[type].init);
                        }
                    });
                    $scope.resource.personal = {status: true, type: type};
                    break;
                case 'Pixabay':
                case 'Unsplash':
                case 'Pexels':
                case 'Freepik':
                    $scope.resource.element.type = null;
                    $scope.resource.personal.status = false;
                    if (
                        ($scope.resource[tab][onClickName] && $scope.resource[tab].type != type) ||
                        ($scope.resource[tab][onClickName] && $scope.resource[tab].type === type && $scope.resource[tab]['onclick'] && $scope.resource[tab]['bgonclick'])) {
                        $scope.getPhoto(type);
                    } else {
                        $scope.resource.photo.type = null;
                        if (tab === 'photo') {
                            $scope.resource[tab].type = null;
                        }
                    }
                    break;
                case 'shape':
                case 'icon':
                case 'line':
                case 'flaticon':
                case 'flaticonstickers':
                case 'svgrepo':
                case 'iconscout':
                case 'pxillustrations':
                case 'nounproject':
                case 'iconfinder':
                case 'storyset':
                    $scope.resource.element.type = null;
                    if ($scope.resource[tab].onclick) {
                        $scope.renderMasonryList(type, '#nbd-' + type + '-wrap .mansory-wrap', '.mansory-item', '#nbd-' + type + '-wrap', $scope.resource[type].init);
                    }
                    if ($scope.resource[tab].onclick && $scope.resource[tab].type != type) $scope.getMedia(type);
                    break;
                case 'draw':
                    if ($scope.resource[tab].onclick) {
                        $scope.enableDrawMode();
                    }
                    $scope.resource.element.type = type;
                    break;
                case 'qrcode':
                    $scope.resource.element.type = type;
                    break;
                case 'overlay-test':
                    $scope.resource.element.type = type;
                    jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    break;
                case 'overlay-typo':
                    $scope.resource.element.type = type;
                    jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    break;
                case 'category-example':
                    $scope.resource.element.type = type;
                    jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    break;
                case 'bg-patterns':
                    $scope.resource.element.type = type;
                    jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    break;
                case 'avatars':
                    $scope.resource.element.type = type;
                    jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    break;
                case 'cutout':
                    $scope.resource.element.type = type;
                    jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    break;
                case 'brandlogos':
                    $scope.resource.element.type = type;
                    jQuery('#tab-element .tab-scroll').perfectScrollbar('update');
                    break;
                case 'shapesnew':
                    $scope.resource.element.type = type;
                    jQuery('#tab-element .tab-scroll').perfectScrollbar('update');
                    break;
                case 'emojis':
                    $scope.resource.element.type = type;
                    jQuery('#tab-element .tab-scroll').perfectScrollbar('update');
                    break;
                case 'bg-cliparts':
                    $scope.resource.element.type = type;
                    jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    break;
                case 'vcard':
                    $scope.resource.element.type = type;
                    break;
                case 'photoFrame':
                    $scope.resource.element.type = type;
                    if (!$scope.resource[type].filter.currentPage) {
                        $scope.resource[type].filter.currentPage = 1;
                    }
                    break;
                default:
                    $scope.resource.element.type = type;
                    break;
            }
            ;
            /*advanced*/
            if (typeof dpc_nbd_js_config_design != "undefined") {
                if (type == "Deposit") {
                    $scope.resource.personal.status = false;
                    if ($scope.resource[tab].onclick && $scope.resource[tab].type != type) {
                        $scope.getPhoto(type);
                    }
                } else {
                    $scope.offsetPhoto = 0;
                }
            }

            if (typeof ggct_nbd_js_config_design != "undefined") {
                if (type == "Product_photo") {
                    $scope.resource.personal.status = false;
                    if ($scope.resource[tab].onclick && $scope.resource[tab].type != type) {
                        $scope.getPhoto(type);
                    }
                }
            }
            /*advanced*/
            if (typeof ssnb_nbd_js_config != "undefined") {
                if (type == "clipart") {
                    if ($scope.resource[tab].onclick) {
                        $scope.getResource('clipart', '#tab-cliparts', true);
                    }
                }
            }
        };
        $scope.onBackgroundTabClicked = function (type) {
            if ($scope.selectedBackgroundTab) {
                $scope.selectedBackgroundTab = null;
                return;
            }
            $scope.selectedBackgroundTab = type;
        }
        $scope.uploadSvgFile = function () {
            var input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/svg+xml|application/svg+xml';
            input.style.display = 'none';
            input.addEventListener('change', onChange.bind(input), false);
            document.body.appendChild(input);
            input.click();

            function onChange() {
                if (this.files.length > 0) {
                    var file = this.files[0],
                        reader = new FileReader();
                    reader.onload = function (event) {
                        if (event.target.readyState === 2) {
                            var result = reader.result;
                            $scope.addSvgFromString(result);
                            destroy();
                        }
                    };
                    reader.readAsText(file);
                }
            }

            function destroy() {
                input.removeEventListener('change', onChange.bind(input), false);
                document.body.removeChild(input);
            }
        };
        $scope.templateName = '';
        $scope.loadTemplateCat = function (callback) {
            var dataObj = {
                source: 'media',
                type: 'get_template_cat'
            };
            NBDDataFactory.get('nbd_get_resource', dataObj, function (data) {
                data = JSON.parse(data);
                if (data.flag == 1) {
                    $scope.templateCats = data.data;
                    $scope.templateCat = parseInt($scope.templateCats[0].id);
                }
                ;
                jQuery('.nbd-popup.popup-template').find('.overlay-main').removeClass('active');
                if (typeof callback == 'function') callback();
            });
        };
        $scope._loadTemplateCat = function () {
            $scope.toggleStageLoading();
            $scope.resource.globalTemplate = {
                filter: {perPage: 50, currentPage: 1, totalPage: 0},
                data: [],
                init: false,
                onload: false
            };
            $scope.loadTemplateCat(function () {
                $scope.loadGlobalTemplate($scope.templateCat);
            });
        };
        $scope.changeGlobalTemplate = function () {
            $scope.toggleStageLoading();
            $scope.resource.globalTemplate = {
                filter: {perPage: 20, currentPage: 1, totalPage: 0},
                data: [],
                init: false,
                onload: false
            }
            $scope.loadGlobalTemplate($scope.templateCat);
        };
        $scope.templateSize = {
            width: 200,
            height: 200
        };
        $scope.changeTemplateDimension = function () {
            var width = 200, height = 200;
            $scope.templateSize.width = $scope.templateSize.width != '' ? $scope.templateSize.width : 200;
            $scope.templateSize.height = $scope.templateSize.height != '' ? $scope.templateSize.height : 200;
            if ($scope.templateSize.width > $scope.templateSize.height) {
                height = Math.round($scope.templateSize.height / $scope.templateSize.width * 200);
            } else {
                width = Math.round($scope.templateSize.width / $scope.templateSize.height * 200);
            }
            $scope.templateSize.width = width;
            $scope.templateSize.height = height;
            _.each($scope.stages, function (stage, index) {
                stage.config.width = width;
                stage.config.cwidth = width;
                stage.config.height = height;
                stage.config.cheight = height;
                $scope.setStageDimension(index);
            });
        };
        $scope.globalTemplateLoaded = false;
        $scope.loadGlobalTemplate = function (cid, withoutLoading) {
            var search = '';
            $http({
                method: 'GET',
                url: appConfig.mediaUrl + '/template?limit=' + $scope.resource.globalTemplate.filter.perPage + '&category=' + cid + '&search=' + search + '&start=' + ($scope.resource.globalTemplate.filter.currentPage - 1) * $scope.resource.globalTemplate.filter.perPage
            }).then(function successCallback(response) {
                var data = response.data.templates;
                $scope.globalTemplateLoaded = true;
                _.each(data.items, function (item, key) {
                    $scope.resource.globalTemplate.data.push({
                        thumbnail: item.thumbnail,
                        name: item.name,
                        id: item.id
                    });
                });
                if (angular.isUndefined(withoutLoading)) $scope.toggleStageLoading();
                $scope.resource.globalTemplate.filter.totalPage = data.pagesTotal > 10 ? 10 : data.pagesTotal;
                $scope.resource.globalTemplate.onload = false;
                $timeout(function () {
                    jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
                }, 1000);
            }, function errorCallback(response) {
                console.log('Fail to load: globalTemplate');
            });
            // NBD template ai to svg

            if (typeof nbptemp_all_ai_to_svg != 'undefined') {
                $scope.resource.globalTemplate.checkai = false;
                if (cid == 10000) {
                    $scope.showglobal = true;
                    var dataObj = {
                        type: 'get_ai_template',
                        id: cid
                    };
                    $scope.resource.globalTemplate.checkai = true;
                    NBDDataFactory.get('nbd_get_resource', dataObj, function (data) {
                        data = JSON.parse(data);
                        $scope.globalTemplateLoaded = true;
                        _.each(data, function (item, key) {
                            _.each(item, function (items, keys) {
                                $scope.resource.globalTemplate.data.push({
                                    thumbnail: items.thumbnail,
                                    name: items.name,
                                    id: items.id,
                                    checkcate: false
                                });
                            });
                        });
                    });
                }
                if (cid = 10001) {
                    $scope.showglobal = true;
                    var dataObj = {
                        type: 'get_cate_ai_template',
                        id: cid
                    };
                    NBDDataFactory.get('nbd_get_resource', dataObj, function (data) {
                        data = JSON.parse(data);
                        $scope.globalTemplateLoaded = true;
                        _.each(data, function (item, key) {
                            _.each(item, function (items, keys) {
                                $scope.resource.globalTemplate.data.push({
                                    thumbnail: items.thumbnail,
                                    name: items.name,
                                    id: items.id,
                                    cate_id: items.cate_id,
                                    checkcate: true
                                });
                            });
                        });
                    });
                }
            }
        };
        // NBD template ai to svg
        if (typeof nbptemp_all_ai_to_svg != 'undefined') {
            jQuery('select#category_template_gol').change(function (event) {
                $scope.golbalecate = jQuery('select#category_template_gol').val();
            });
        }
        $scope.getGlobalTemplate = function (id, callback) {
            var dataObj = {
                source: 'media',
                type: 'get_template',
                id: id
            };
            NBDDataFactory.get('nbd_get_resource', dataObj, function (data) {
                data = JSON.parse(data);
                if (data.flag == 1 && data.data.design) {
                    if (typeof callback == 'function') callback(data.data);
                } else {
                    $scope.toggleStageLoading();
                    console.log('Error load global template!');
                }
                ;
            });
        };
        $scope.insertGlobalTemplate = function (id, $index) {
            if (angular.isDefined($index) && $scope.settings.valid_license == '0' && $index > 4) {
                alert($scope.settings.nbdlangs.pro_license_alert);
                return;
            }
            $scope.showDesignTab();
            $scope.clearHistory();
            $scope.toggleStageLoading();
            $scope.getGlobalTemplate(id, function (data) {
                var fonts = JSON.parse(data.used_font);
                var design = JSON.parse(data.design);
                if (angular.isUndefined(design.canvas)) design.canvas = {width: 200, height: 200};
                if (fonts.length) {
                    _.each(fonts, function (font, index) {
                        if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                            $scope.resource.font.data.push(font);
                        }
                        ;
                        var font_id = font.name.replace(/\s/gi, '').toLowerCase();
                        if (!jQuery('#' + font_id).length) {
                            jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family=' + font.name.replace(/\s/gi, '+') + ':400,400i,700,700i" rel="stylesheet" type="text/css">');
                        }
                    });
                }
                $scope.onloadTemplate = true;
                $scope.contextAddLayers = 'template';
                var stageIndex = 0;

                function afterLoadStage() {
                    $scope.onloadTemplate = false;
                    $scope.contextAddLayers = 'normal';
                    $scope.toggleStageLoading();
                    $scope.afterInsertTemplate();
                }

                function loadStage(stageIndex) {
                    if (angular.isUndefined($scope.stages[stageIndex]) || stageIndex >= $scope.stages.length) {
                        if (stageIndex >= $scope.stages.length) afterLoadStage();
                        return;
                    }
                    var _index = 'frame_' + stageIndex,
                        stage = $scope.stages[stageIndex],
                        _canvas = stage['canvas'],
                        layerIndex = 0;
                    if (angular.isUndefined(design[_index])) {
                        stageIndex++;
                        loadStage(stageIndex);
                        return;
                    }
                    stage.states.usedFonts = [];
                    _canvas.clear();
                    var objects = design[_index].objects;
                    if (objects.length == 0) {
                        stageIndex++;
                        loadStage(stageIndex);
                        return;
                    }
                    var stageLayers = [];

                    function loadLayer(layerIndex) {
                        function continueLoadLayer() {
                            layerIndex++;
                            if (layerIndex < objects.length) {
                                loadLayer(layerIndex);
                            } else {
                                fitTemplateWithStage();
                                stageIndex++;
                                if (stageIndex < $scope.stages.length) {
                                    loadStage(stageIndex);
                                } else {
                                    afterLoadStage();
                                }
                            }
                        }

                        function fitTemplateWithStage() {
                            var rec = $scope.fitRectangle(stage.config.width, stage.config.height, design.canvas.width, design.canvas.height, true),
                                factor = rec.width / design.canvas.width;
                            _.each(stageLayers, function (obj) {
                                var scaleX = obj.get('scaleX'),
                                    scaleY = obj.get('scaleY'),
                                    top = obj.get('top'),
                                    left = obj.get('left');
                                obj.set({
                                    scaleX: scaleX * factor,
                                    scaleY: scaleY * factor,
                                    left: left * factor + rec.left,
                                    top: top * factor + rec.top
                                });
                                obj.setCoords();
                            });
                            $scope.deactiveAllLayer(stageIndex);
                            $scope.renderStage(stageIndex);
                        }

                        function addLayer(_item, callback) {
                            _canvas.add(_item);
                            var __item = _canvas.item(_canvas.getObjects().length - 1);
                            if (typeof callback === 'function') callback(__item);
                            stageLayers.push(__item);
                            continueLoadLayer();
                        }

                        var item = objects[layerIndex],
                            type = item.type;
                        if (type === 'image' || type === 'custom-image') {
                            fabric.Image.fromObject(item, function (_image) {
                                addLayer(_image);
                            });
                        } else {
                            var klass = fabric.util.getKlass(type);
                            var is_text = false;
                            if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(type) > -1) {
                                if (!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length) {
                                    var layerFont = $scope.getFontInfo(item.fontFamily);
                                    stage.states.usedFonts.push(layerFont);
                                }
                                ;
                                is_text = true;
                            }
                            ;
                            klass.fromObject(item, function (item) {
                                if (is_text) {
                                    var fontFamily = item.fontFamily,
                                        fontWeight = angular.isDefined(item.fontWeight) ? item.fontWeight : '',
                                        fontStyle = angular.isDefined(item.fontStyle) ? item.fontStyle : '',
                                        _font = $scope.getFontInfo(fontFamily);
                                    item.set({objectCaching: false});
                                    var font = new FontFaceObserver(fontFamily, {weight: fontWeight, style: fontStyle});
                                    font.load($scope.settings.subsets[_font.subset]['preview_text']).then(function () {
                                        fabric.util.clearFabricFontCache();
                                        addLayer(item, function (__item) {
                                            __item.initDimensions();
                                            __item.setCoords();
                                        });
                                    }, function () {
                                        console.log('Error load font: ' + fontFamily);
                                        addLayer(item);
                                    });
                                } else {
                                    addLayer(item);
                                }
                            });
                        }
                    }

                    loadLayer(layerIndex);
                }

                loadStage(stageIndex);
            });
        };

        $scope.handlePixabayIllustrationsVectorOnlyChanged = function (e) {
            $scope.resource['pxillustrations'].vectorOnly = e;
            $scope.getMedia('pxillustrations', 'search')
        }

        $scope.handlePixabayIllustrationsColorChanged = function (e) {
            $scope.resource['pxillustrations'].color = e;
            $scope.getMedia('pxillustrations', 'search');
        }

        $scope.handlePixabayIllustrationsOrientationChanged = function (e) {
            $scope.resource['pxillustrations'].orientation = e;
            $scope.getMedia('pxillustrations', 'search');
        }

        $scope.handlePixabayIllustrationsTransparentChanged = function (e) {
            $scope.resource['pxillustrations'].transparent = e;
            $scope.getMedia('pxillustrations', 'search');
        }

        $scope.handlePixabayIllustrationsBlackAndWhiteChanged = function (e) {
            $scope.resource['pxillustrations'].blackAndWhite = e;
            $scope.getMedia('pxillustrations', 'search');
        }

        $scope.handlePixabayPhotosColorChanged = function (e) {
            $scope.resource.photo.color = e;
            $scope.getPhoto('Pixabay', 'search');
        }

        $scope.handlePixabayPhotosOrientationChanged = function (e) {
            $scope.resource.photo.orientation = e;
            $scope.getPhoto('Pixabay', 'search');
        }

        $scope.handlePixabayPhotosTransparentChanged = function (e) {
            $scope.resource.photo.transparent = e;
            $scope.getPhoto('Pixabay', 'search');
        }

        $scope.handlePixabayPhotosBlackAndWhiteChanged = function (e) {
            $scope.resource.photo.blackAndWhite = e;
            $scope.getPhoto('Pixabay', 'search');
        }

        $scope.handleShapeBorderRadiusChanged = function () {
            const object = $scope.getActiveObject();
            if (object) {
                const canvas = $scope.getCurrentStageCanvas();

                $timeout(() => {
                    object.set({
                        rx: $scope.shapeBorderRadius,
                        ry: $scope.shapeBorderRadius,
                        borderRadius: {
                            radius: $scope.shapeBorderRadius || 0,
                            leftTop: $scope.shapeBorderRadius || 0,
                            rightTop: $scope.shapeBorderRadius || 0,
                            rightBottom: $scope.shapeBorderRadius || 0,
                            leftBottom: $scope.shapeBorderRadius || 0,
                        }
                    });
                    $scope.shapeSideBorderRadius = {
                        leftTop: $scope.shapeBorderRadius || 0,
                        rightTop: $scope.shapeBorderRadius || 0,
                        rightBottom: $scope.shapeBorderRadius || 0,
                        leftBottom: $scope.shapeBorderRadius || 0
                    };
                    canvas.renderAll();
                });
            }
        }

        $scope.handleShapeSideBorderRadiusChanged = function () {
            const object = $scope.getActiveObject();
            if (object) {
                const canvas = $scope.getCurrentStageCanvas();
                $timeout(() => {
                    object.set({
                        rx: $scope.shapeSideBorderRadius.leftTop,
                        ry: $scope.shapeSideBorderRadius.rightBottom,
                        borderRadius: {
                            radius: 0,
                            leftTop: $scope.shapeSideBorderRadius.leftTop || 0,
                            rightTop: $scope.shapeSideBorderRadius.rightTop || 0,
                            rightBottom: $scope.shapeSideBorderRadius.rightBottom || 0,
                            leftBottom: $scope.shapeSideBorderRadius.leftBottom || 0,
                        }
                    });
                    $scope.shapeBorderRadius = 0;
                    canvas.renderAll();
                });
            }
        }

        $scope.handleImageBorderRadiusChanged = function () {
            const object = $scope.getActiveObject();
            if (object) {
                const canvas = $scope.getCurrentStageCanvas();

                $timeout(() => {
                    if (!$scope.imageHasTransparency(object)) {
                        object.set({
                            borderRadius: {
                                radius: $scope.imageBorderRadius || 0,
                                leftTop: $scope.imageBorderRadius || 0,
                                rightTop: $scope.imageBorderRadius || 0,
                                rightBottom: $scope.imageBorderRadius || 0,
                                leftBottom: $scope.imageBorderRadius || 0,
                            }
                        });
                    } else {
                        object.set({
                            borderRadius: {
                                radius: 0,
                                leftTop: 0,
                                rightTop: 0,
                                rightBottom: 0,
                                leftBottom: 0,
                            }
                        });
                    }
                    $scope.imageSideBorderRadius = {
                        leftTop: $scope.imageBorderRadius || 0,
                        rightTop: $scope.imageBorderRadius || 0,
                        rightBottom: $scope.imageBorderRadius || 0,
                        leftBottom: $scope.imageBorderRadius || 0
                    };
                    canvas.renderAll();
                });
            }
        }

        $scope.handleImageSideBorderRadiusChanged = function () {
            const object = $scope.getActiveObject();
            if (object) {
                const canvas = $scope.getCurrentStageCanvas();
                $timeout(() => {
                    if (!$scope.imageHasTransparency(object)) {
                        object.set({
                            borderRadius: {
                                radius: 0,
                                leftTop: $scope.imageSideBorderRadius.leftTop || 0,
                                rightTop: $scope.imageSideBorderRadius.rightTop || 0,
                                rightBottom: $scope.imageSideBorderRadius.rightBottom || 0,
                                leftBottom: $scope.imageSideBorderRadius.leftBottom || 0,
                            }
                        });
                    } else {
                        object.set({
                            borderRadius: {
                                radius: 0,
                                leftTop: 0,
                                rightTop: 0,
                                rightBottom: 0,
                                leftBottom: 0,
                            }
                        });
                    }
                    $scope.imageBorderRadius = 0;
                    canvas.renderAll();
                });
            }
        }

        $scope.getMedia = function (type, context) {
            jQuery('#tab-element .loading-photo').show();
            $scope.resource.element.type = type;
            if ($scope.resource.element.type != type || context == 'search') {
                $scope.resource[type].data = [];
                $scope.resource[type].filter.total = 0;
                $scope.resource[type].filter.currentPage = 1;
            }
            ;
            $scope.resource.element.type = type;
            var category = type == 'shape' ? 66 : (type == 'line' ? 78 : 73);
            var search = (type == 'icon' || type == 'flaticon' || type == 'flaticonstickers' || type == 'svgrepo' || type == 'iconscout' || type == 'nounproject' || type == 'iconfinder' || type == 'storyset' || type == 'pxillustrations') ? $scope.resource.element.contentSearch : '';
            if (type == 'icon') {
                if ($scope.resource.icon.filter.currentCat != null) {
                    category = $scope.resource.icon.filter.currentCat.id;
                }
                if (search != '') {
                    category = '';
                }
            }
            /*advanced*/
            if (typeof mcnb_nbd_js_config_design != "undefined") {
                $http({
                    method: 'GET',
                    url: appConfig.mediaUrl + '/clipart?limit=20&category=' + category + '&search=' + search + '&start=' + ($scope.resource[type].filter.currentPage - 1) * 20
                }).then(function successCallback(response) {
                    if (angular.isDefined(response.data.cliparts)) {
                        var data = response.data.cliparts;
                        _.each(data.items, function (item, key) {
                            $scope.resource[type].data.push({
                                url: item.file,
                                name: item.name
                            });
                        });
                        //$scope.resource[type].filter.totalPage = data.pagesTotal > 10 ? 10 : data.pagesTotal;
                        $scope.resource[type].filter.totalPage = data.pagesTotal;
                        if (type == 'icon' && $scope.resource[type].first) {
                            $scope.resource[type].cat = data.categories;
                            $scope.resource[type].first = false;
                            $scope.resource.icon.filter.currentCat = _.filter($scope.resource.icon.cat, {id: '' + category})[0];
                        }
                    }
                }, function errorCallback(response) {
                    console.log('Fail to load: ' + type);
                });
                return;
            }
            switch (type) {
                case 'flaticon':

                function getFlaticon() {
                    $http({
                        method: "GET",
                        url: 'https://api.flaticon.com/v3/search/icons/priority?q=icon%20' + encodeURIComponent(search) + '&page=' + $scope.resource.flaticon.filter.currentPage + '&limit=' + $scope.resource.flaticon.filter.perPage,
                        headers: {
                            'Authorization': 'Bearer ' + $scope.resource.flaticon.token,
                            'Accept': 'application/json'
                        }
                    }).then(function successCallback(response) {
                        var data = response.data;
                        _.each(data.data, function (item, key) {
                            $scope.resource[type].data.push({
                                url: item.images['512'],
                                preview: item.images['128'],
                                name: item.description
                            });
                        });
                        $scope.resource.flaticon.filter.totalPage = Math.ceil(data.metadata.total / $scope.resource.flaticon.filter.perPage);
                    }, function errorCallback(response) {
                        console.log('Fail to load: ' + type);
                    });
                }

                    if ($scope.resource.flaticon.token == '') {
                        NBDDataFactory.get('nbd_get_resource', {type: 'get_flaticon_token'}, function (data) {
                            data = JSON.parse(data);
                            if (data.flag == 1) {
                                $scope.resource.flaticon.token = data.data.token;
                                $scope.resource.flaticon.expires = data.data.expires;
                                getFlaticon();
                            } else {
                                console.log('Fail to load: ' + type);
                            }
                        });
                    } else {
                        getFlaticon();
                    }
                    break;
                case 'flaticonstickers':

                function getFlaticonstickers() {
                    $http({
                        method: "GET",
                        url: 'https://api.flaticon.com/v3/search/icons/priority?q=%20' + encodeURIComponent(search) + '&iconType=sticker' + '&page=' + $scope.resource.flaticonstickers.filter.currentPage + '&limit=' + $scope.resource.flaticonstickers.filter.perPage,
                        headers: {
                            'Authorization': 'Bearer ' + $scope.resource.flaticon.token,
                            'Accept': 'application/json'
                        }
                    }).then(function successCallback(response) {
                        var data = response.data;
                        _.each(data.data, function (item, key) {
                            $scope.resource[type].data.push({
                                url: item.images['512'],
                                preview: item.images['128'],
                                name: item.description
                            });
                        });
                        $scope.resource.flaticonstickers.filter.totalPage = Math.ceil(data.metadata.total / $scope.resource.flaticonstickers.filter.perPage);
                    }, function errorCallback(response) {
                        console.log('Fail to load: ' + type);
                    });
                }

                    if ($scope.resource.flaticon.token == '') {
                        NBDDataFactory.get('nbd_get_resource', {type: 'get_flaticon_token'}, function (data) {
                            data = JSON.parse(data);
                            if (data.flag == 1) {
                                $scope.resource.flaticon.token = data.data.token;
                                $scope.resource.flaticon.expires = data.data.expires;
                                getFlaticon();
                            } else {
                                console.log('Fail to load: ' + type);
                            }
                        });
                    } else {
                        getFlaticonstickers();
                    }
                    break;
                case 'storyset':
                    $http({
                        method: "GET",
                        url: 'https://stories.freepiklabs.com/api/vectors?order=recent&page=' + $scope.resource[type].filter.currentPage + '&query=' + encodeURIComponent(search),
                    }).then(function successCallback(response) {
                        var data = response.data;
                        _.each(data.data, function (item, key) {
                            $scope.resource[type].data.push({
                                url: item.src,
                                preview: item.preview,
                                name: item.illustration.name
                            });
                        });
                        $scope.resource.storyset.filter.totalPage = data.meta.last_page;
                    }, function errorCallback(response) {
                        console.log('Fail to load: ' + type);
                    });
                    break;
                case 'svgrepo':
                    NBDDataFactory.get('nbd_get_svg_api_icons', {
                        search,
                        limit: 20,
                        offset: $scope.resource[type].filter.currentPage * 20
                    }, function (response) {
                        const data = JSON.parse(response);
                        if (data) {
                            _.each(data.icons, function (item, key) {
                                $scope.resource[type].data.push({
                                    url: item.url,
                                    preview: item.url,
                                    title: item.title
                                });
                            });
                            $scope.resource.svgrepo.filter.totalPage = Math.ceil(data.count / $scope.resource.iconscout.filter.perPage);
                        }
                        $scope.resource['element'].onload = false;
                    });
                    break;
                case 'pxillustrations':
                    $http({
                        method: 'GET',
                        url: 'https://pixabay.com/api/?safesearch=true&key=' + NBDESIGNCONFIG['nbdesigner_pixabay_api_key'] + $scope.constructPixabayQueryString($scope.resource['pxillustrations']) + '&per_page=' + $scope.resource.pxillustrations.filter.perPage + '&page=' + $scope.resource.pxillustrations.filter.currentPage + '&q=' + encodeURIComponent(search)
                    }).then(function successCallback(response) {
                        const data = response.data;
                        if (data) {
                            _.each(data.hits, function (val, key) {
                                $scope.resource[type].data.push({
                                    url: angular.isDefined(val.vectorURL) ? val.vectorURL : (angular.isDefined(val.largeImageURL) ? val.largeImageURL : val.imageURL),
                                    preview: val.previewURL,
                                    title: `@${val.user}`
                                });
                            });
                            $scope.resource.pxillustrations.filter.totalPage = Math.ceil(data.totalHits / $scope.resource.photo.filter.perPage);
                        }
                        $scope.resource['element'].onload = false;
                    });
                    break;
                case 'nounproject':
                    NBDDataFactory.get('nbd_get_noun_project_icons', {
                        search: search || 'icon',
                        limit: 20
                    }, function (response) {
                        var data = JSON.parse(response);
                        if (data) {
                            _.each(data.icons, function (item, key) {
                                $scope.resource[type].data.push({
                                    url: item.icon_url,
                                    preview: item.preview_url,
                                    name: item.attribution
                                });
                            });
                            $scope.resource.nounproject.filter.totalPage = $scope.resource.iconscout.filter.totalPage + 20;
                        }
                        $scope.resource['element'].onload = false;
                    });
                    break;
                case 'iconscout':
                    NBDDataFactory.get('nbd_get_iconscout_icons', {
                        search: search || 'icon',
                        limit: 20,
                        offset: $scope.resource[type].filter.currentPage * 20
                    }, function (response) {
                        let data = JSON.parse(response);
                        if (data) {
                            data = data.response.items;
                            _.each(data.data, function (item, key) {
                                $scope.resource[type].data.push({
                                    url: item.urls.original,
                                    preview: item.urls.png_256,
                                    name: item.name
                                });
                            });
                            $scope.resource.iconscout.filter.totalPage = Math.ceil(data.total / $scope.resource.iconscout.filter.perPage);
                        }
                        $scope.resource['element'].onload = false;
                    });
                    break;
                case 'iconfinder':
                    NBDDataFactory.get('nbd_get_iconfinder_icons', {
                        search: search || 'icon',
                        limit: 20,
                        offset: $scope.resource[type].filter.currentPage * 20
                    }, function (response) {
                        var data = JSON.parse(response);
                        if (data) {
                            _.each(data.icons, function (item, key) {
                                $scope.resource[type].data.push({
                                    url: item.vector_sizes[0].formats[0].download_url,
                                    preview: item.raster_sizes[7].formats[0].preview_url
                                });
                            });
                            $scope.resource.iconfinder.filter.totalPage = Math.ceil(data.total_count / $scope.resource.iconscout.filter.perPage);
                        }
                        $scope.resource['element'].onload = false;
                    });
                    break;
                default:
                    $http({
                        method: 'GET',
                        url: appConfig.mediaUrl + '/clipart?limit=20&category=' + category + '&search=' + search + '&start=' + ($scope.resource[type].filter.currentPage - 1) * 20
                    }).then(function successCallback(response) {
                        if (angular.isDefined(response.data.cliparts)) {
                            var data = response.data.cliparts;
                            _.each(data.items, function (item, key) {
                                $scope.resource[type].data.push({
                                    url: item.file,
                                    name: item.name
                                });
                            });
                            $scope.resource[type].filter.totalPage = data.pagesTotal;
                            if (type == 'icon' && $scope.resource[type].first) {
                                $scope.resource[type].cat = data.categories;
                                $scope.resource[type].first = false;
                                $scope.resource.icon.filter.currentCat = _.filter($scope.resource.icon.cat, {id: '' + category})[0];
                            }
                        }
                    }, function errorCallback(response) {
                        console.log('Fail to load: ' + type);
                    });
                    break;
            }
        };

        $scope.constructPixabayQueryString = function (resource = {}, format = 'illustration') {
            let query = '&image_type=';
            const {vectorOnly, color, transparent, orientation, blackAndWhite} = resource;
            query += vectorOnly ? 'vector' : format;
            query += '&colors=' + (transparent ? 'transparent,' : '');
            query += blackAndWhite ? 'grayscale,' : '';
            query += color ? color : '';
            query += '&orientation=' + orientation;
            return query;
        }
        /*advanced*/
        if (typeof udc_nbd_js_config != 'undefined') {
            $scope.searchuserPhotos = function () {
                /*var photoimg = $scope.photouserArr;
           var imgName = jQuery('#searchuserphoto').val();
           var filteredImage = photoimg.filter(function(img) {
              return img === imgName;
           });

           $scope.photouserArr = filteredImage;
           console.log(filteredImage);*/
                var imgName = jQuery('#searchuserphoto').val();
                imgName = imgName.toLowerCase();
                jQuery.ajax({
                    url: 'https://wordpress-556461-1809452.cloudwaysapps.com/wp-content/plugins/addonupdate/views/editor_components/searchPhotos.php',
                    type: 'post',
                    cache: false,
                    data: {imgname: imgName},
                    success: function (response) {
                        var data = JSON.parse(response);
                        $scope.photouserArr = data;
                    },
                    error: function (err) {
                        console.log(err);
                    }
                });
            };

            $scope.generateLayers = function () {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                var layersarray = [];
                var objects = _canvas.getObjects().filter(function (o) {
                    return o.custype != 'gridline';
                });
                for (var i = 0; i < objects.length; i++) {
                    (function (index) {
                        console.log(objects);
                        var img = new Image();
                        img.onload = function () {
                            layersarray[index] = new Object();
                            layersarray[index].src = img.src;
                            if (objects.length == layersarray.length) {
                                for (var j = 0; j < layersarray.length; j++) {
                                    if (objects[j].type == 'image') {
                                        console.log(objects[j].type);
                                        if (layersarray[j]) layer = $scope.textMasks.push(layersarray[j].src);
                                    }
                                }

                            }
                        }
                        img.src = objects[index].toDataURL("image/png");
                    })(i);
                }
            };

            $scope.getCDNPictures = function (path) {
                $scope.cdnPicturesArr = [];
                jQuery('#tab-photo .loading-photo').show();

                jQuery.ajax({
                    type: "get",
                    url: 'https://wordpress-556461-1809452.cloudwaysapps.com/wp-content/plugins/addonupdate/views/editor_components/getPicturesJSON.php',
                    cache: false,
                    data: {
                        path: path
                    },
                    success: function (data) {
                        var data = JSON.parse(data);
                        $scope.rootpath = data.rootpath;
                        $scope.currentpath = data.currentpath;
                        $scope.prevpath = data.prevpath;
                        $scope.cdnPicturesArr = data.pictures;
                        jQuery('#tab-photo .loading-photo').hide();
                    },
                    error: function (err) {
                        console.log(err);
                    }

                })
            };

            function urlencode(str) {
                str = (str + '').toString();
                return encodeURIComponent(str)
                    .replace('#', '%23');
            }

            $scope.getImagefile = function (imgUrl) {
                $scope.addImagetocanvas(imgUrl);
            }

            $scope.loaduserPhotos = function (photoUrl) {
                var photoPath = 'https://wordpress-556461-1809452.cloudwaysapps.com/wp-content/plugins/addonupdate/assets/userphotos/' + photoUrl;
                if (photoPath.indexOf("svg") > -1) {
                    //$scope.addSvgFromString(photoPath, false);
                    var _canvas = this.stages[$scope.currentStage]['canvas'];
                    $scope.toggleStageLoading();
                    if (_canvas) {
                        if (!photoPath) return false;
                        fabric.loadSVGFromURL(photoPath, (objects) => {
                            var loadedObject = fabric.util.groupSVGElements(objects);
                            loadedObject.set({
                                opacity: 1,
                            });
                            loadedObject.scaleToWidth(400);
                            loadedObject.src = photoPath;
                            loadedObject.hasRotatingPoint = true;
                            _canvas.add(loadedObject);
                            _canvas.setActiveObject(loadedObject);
                            loadedObject.center();
                            loadedObject.setCoords();
                            _canvas.renderAll();
                            $scope.toggleStageLoading();
                        });
                    }
                } else {
                    $scope.addImagetocanvas(photoPath);
                }
            }

            $scope.addImagetocanvas = function (imgUrl) {

                var _canvas = this.stages[$scope.currentStage]['canvas'];
                $scope.toggleStageLoading();
                if (_canvas) {
                    if (!imgUrl) return false;
                    fabric.Image.fromURL(imgUrl, (image) => {
                        var object = image.set({
                            left: _canvas.getWidth() / 2,
                            top: _canvas.getHeight() / 2,
                        });
                        object.src = imgUrl;
                        object.scaleToWidth(400);
                        _canvas.add(object);
                        _canvas.setActiveObject(object);
                        object.center();
                        object.setCoords();
                        _canvas.renderAll();
                        $scope.toggleStageLoading();
                    }, {
                        crossOrigin: "anonymous"
                    });
                }

            };

            $scope.getelementPhoto = function () {
                jQuery('#nbdesigner-gallery').css('display', 'none');
                jQuery('#tab-photo .loading-photo').hide();
                jQuery('.tab-load-more').show();
                $scope.getCDNPictures();
            }
        }
        $scope.getPhoto = function (type, context) {
            if ($scope.resource.photo.type != type || context == 'search') {
                $scope.resource.photo.data = [];
                $scope.resource.photo.filter.total = 0;
                $scope.resource.photo.filter.currentPage = 1;
                jQuery("#tab-photo .tab-scroll").stop().animate({
                    scrollTop: jQuery('#tab-photo .main-items').height()
                }, 100);
                jQuery('#nbdesigner-gallery').css('height', 0);
                /*advanced*/
                if (typeof ggct_nbd_js_config_design != "undefined") {
                    jQuery("#tab-gallery .tab-scroll").stop().animate({
                        scrollTop: jQuery('#tab-gallery .main-items').height()
                    }, 100);
                    jQuery('.nbdesigner-gallery').css('height', 0);
                }
            }
            ;
            $scope.resource.photo.type = type;
            if ($scope.resource.photo.type == '') return;
            jQuery('#tab-photo .loading-photo').show();
            if ($scope.resource.photo.filter.totalPage == 0 || $scope.resource.photo.filter.currentPage <= $scope.resource.photo.filter.totalPage) {
                switch (type) {
                    case 'Pixabay':
                        $http({
                            method: 'GET',
                            url: 'https://pixabay.com/api/?safesearch=true&key=' + NBDESIGNCONFIG['nbdesigner_pixabay_api_key'] + $scope.constructPixabayQueryString($scope.resource.photo, 'photo') + '&response_group=high_resolution&per_page=' + $scope.resource.photo.filter.perPage + '&page=' + $scope.resource.photo.filter.currentPage + '&q=' + encodeURIComponent($scope.resource.photo.photoSearch)
                        }).then(function successCallback(response) {
                            var data = response.data,
                                totalPage = Math.ceil(data.totalHits / $scope.resource.photo.filter.perPage);
                            $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                            _.each(data.hits, function (val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: angular.isDefined(val.fullHDURL) ? val.fullHDURL : (angular.isDefined(val.largeImageURL) ? val.largeImageURL : val.imageURL),
                                    preview: val.previewURL,
                                    des: '@ ' + val.user,
                                    credit: 'https://pixabay.com/users/' + val.user + '-' + val.user_id
                                });
                                // get the photo id
                                if (typeof PixabayId != 'undefined') {
                                    $scope.resource.photo.data[$scope.resource.photo.data.length - 1].id = val.id;
                                    $scope.resource.photo.data[$scope.resource.photo.data.length - 1].type = type;
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "FullHD") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.imageURL;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "HD") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.fullHDURL;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "large") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.largeImageURL;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "medium") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.webformatURL;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "low") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.previewURL;
                                    }
                                }
                            });
                            $scope.afterGetResource('photo');
                        }, function errorCallback(response) {
                            console.log('Pixabay');
                            jQuery('#tab-photo .loading-photo').hide();
                        });
                        break;
                    case 'pxillustrations':
                        $http({
                            method: 'GET',
                            url: 'https://pixabay.com/api/?safesearch=true&key=' + NBDESIGNCONFIG['nbdesigner_pixabay_api_key'] + '&image_type=illustration&per_page=' + $scope.resource.photo.filter.perPage + '&page=' + $scope.resource.photo.filter.currentPage + '&q=' + encodeURIComponent($scope.resource.photo.photoSearch)
                        }).then(function successCallback(response) {
                            var data = response.data,
                                totalPage = Math.ceil(data.totalHits / $scope.resource.photo.filter.perPage);
                            $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                            _.each(data.hits, function (val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: angular.isDefined(val.vectorURL) ? val.vectorURL : (angular.isDefined(val.largeImageURL) ? val.largeImageURL : val.imageURL),
                                    preview: val.previewURL,
                                    des: '@ ' + val.user
                                });
                                // get the photo id
                                if (typeof PixabayId != 'undefined') {
                                    $scope.resource.photo.data[$scope.resource.photo.data.length - 1].id = val.id;
                                    $scope.resource.photo.data[$scope.resource.photo.data.length - 1].type = type;
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "FullHD") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.imageURL;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "HD") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.fullHDURL;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "large") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.largeImageURL;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "medium") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.webformatURL;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pixabay_confix'] == "low") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.previewURL;
                                    }
                                }
                            });
                            $scope.afterGetResource('photo');
                        }, function errorCallback(response) {
                            console.log('PixabayIllustrations');
                            jQuery('#tab-photo .loading-photo').hide();
                        });
                        break;
                    case 'Unsplash':
                        var url = $scope.resource.photo.photoSearch != '' ? 'https://api.unsplash.com/search/photos/?client_id=' + NBDESIGNCONFIG['nbdesigner_unsplash_api_key'] + '&per_page=' + $scope.resource.photo.filter.perPage + '&page=' + $scope.resource.photo.filter.currentPage + '&query=' + encodeURIComponent($scope.resource.photo.photoSearch) : 'https://api.unsplash.com/photos/?client_id=' + NBDESIGNCONFIG['nbdesigner_unsplash_api_key'] + '&per_page=20&page=' + $scope.resource.photo.filter.currentPage + '&order_by=latest';
                        $http({
                            method: 'GET',
                            url: url
                        }).then(function successCallback(response) {
                            var data = response.data;
                            if ($scope.resource.photo.photoSearch != '') {
                                $scope.resource.photo.filter.totalPage = data.total_pages > 10 ? 10 : data.total_pages;
                                var results = data.results;
                            } else {
                                $scope.resource.photo.filter.totalPage = 10;
                                var results = data;
                            }
                            _.each(results, function (val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: val.urls.regular,
                                    preview: val.urls.thumb,
                                    des: 'by ' + val.user.name,
                                    download: val.links.download_location,
                                    credit: val.user.links.html + '?utm_source=plasfy&utm_medium=referral'
                                });
                                // get the photo id by raito
                                if (typeof PixabayId != 'undefined') {
                                    $scope.resource.photo.data[$scope.resource.photo.data.length - 1].id = val.id;
                                    $scope.resource.photo.data[$scope.resource.photo.data.length - 1].type = type;
                                    if (NBDESIGNCONFIG['nbdesigner_size_unsplash_confix'] == "Full") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.urls.full;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_unsplash_confix'] == "Raw") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.urls.raw;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_unsplash_confix'] == "Regular") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.urls.regular;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_unsplash_confix'] == "Small") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.urls.small;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_unsplash_confix'] == "Thumb") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.urls.thumb;
                                    }
                                }
                            });
                            $scope.afterGetResource('photo');
                        }, function errorCallback(response) {
                            console.log('Unsplash');
                            jQuery('#tab-photo .loading-photo').hide();
                        });
                        break;
                    case 'Pexels':
                        var url = $scope.resource.photo.photoSearch != '' ? 'https://api.pexels.com/v1/search?query=' + encodeURIComponent($scope.resource.photo.photoSearch) + '&per_page=' + $scope.resource.photo.filter.perPage + '&page=' + $scope.resource.photo.filter.currentPage : 'https://api.pexels.com/v1/curated?' + 'per_page=' + $scope.resource.photo.filter.perPage + '&page=' + $scope.resource.photo.filter.currentPage;
                        $http({
                            method: 'GET',
                            url: url,
                            headers: {
                                'Authorization': NBDESIGNCONFIG['nbdesigner_pexels_api_key']
                            }
                        }).then(function successCallback(response) {
                            var data = response.data,
                                totalPage = angular.isDefined(data.total_results) ? Math.ceil(data.total_results / $scope.resource.photo.filter.perPage) : 1;
                            $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                            _.each(data.photos, function (val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: val.src.large,
                                    preview: val.src.tiny,
                                    des: '@ ' + val.photographer,
                                    credit: val.photographer_url
                                });
                                // get the photo id by raito
                                if (typeof PixabayId != 'undefined') {
                                    $scope.resource.photo.data[$scope.resource.photo.data.length - 1].id = val.id;
                                    $scope.resource.photo.data[$scope.resource.photo.data.length - 1].type = type;
                                    if (NBDESIGNCONFIG['nbdesigner_size_pexels_confix'] == "Landscape") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.src.landscape;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pexels_confix'] == "Large") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.src.large;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pexels_confix'] == "Large2x") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.src.large2x;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pexels_confix'] == "Medium") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.src.medium;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pexels_confix'] == "Original") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.src.original;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pexels_confix'] == "Portrait") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.src.portrait;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pexels_confix'] == "Small") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.src.small;
                                    }
                                    if (NBDESIGNCONFIG['nbdesigner_size_pexels_confix'] == "Tiny") {
                                        $scope.resource.photo.data[$scope.resource.photo.data.length - 1].url = val.src.tiny;
                                    }
                                }
                            });
                            $scope.afterGetResource('photo');
                        }, function errorCallback(response) {
                            console.log('Pexels');
                            jQuery('#tab-photo .loading-photo').hide();
                        });
                        break;
                    case 'Freepik':
                        var src = 'https://wepik.com/api/images/freepik?query=' + encodeURIComponent($scope.resource.photo.photoSearch) + '&page=' + $scope.resource.photo.filter.currentPage;

                        NBDDataFactory.get('test_free_pick', {'src': src}, function (data) {
                            var data = JSON.parse(data);
                            totalPage = data.data.length;
                            $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                            _.each(data.data, function (val, key) {
                                $scope.resource.photo.data.push({
                                    extenal: 1,
                                    url: val.url,
                                    preview: val.preview,
                                    des: 'Freepik'
                                });
                            });
                            $scope.afterGetResource('photo');
                        });
                        break;
                }
                /*advanced*/
                if (typeof dpc_nbd_js_config_design != "undefined" && type == "Deposit") {
                    if (angular.isDefined(context)) {
                        $scope.onClickDepositePhoto(context);
                    } else {
                        $scope.onClickDepositePhoto('get');
                    }
                }
                /*advanced*/
                if (typeof ggct_nbd_js_config_design != "undefined" && type == "Product_photo") {
                    NBDDataFactory.get('nbdesigner_get_product_photo_info', {
                        product_id: NBDESIGNCONFIG['product_id'],
                        cat: $scope.photo_cate
                    }, function (data) {
                        var _data = JSON.parse(data);
                        var totalPage = angular.isDefined(_data.total_results) ? Math.ceil(_data.total_results / $scope.resource.photo.filter.perPage) : 1;
                        $scope.resource.photo.filter.totalPage = totalPage > 10 ? 10 : totalPage;
                        _.each(_data.photos, function (val, key) {
                            $scope.resource.photo.data.push({
                                extenal: 1,
                                url: val.src,
                                preview: val.src_tiny,
                                des: '@ ' + val.des
                            });
                        });
                        $scope.afterGetResource('photo');
                    });
                }
            }
            ;
            $scope.updateApp();
        };
        if (typeof ggct_nbd_js_config_design != "undefined") {
            $scope.curentCat = function (cat) {
                $scope.photo_cate = cat;
            }
        }
        $scope.getPersonalPhoto = function (type, dataObj) {
            jQuery('#tab-photo .loading-photo').show();
            switch (type) {
                case 'dropbox':
                    _.each(dataObj, function (file, index) {
                        $scope.resource.dropbox.data.push({
                            extenal: 1,
                            id: file.id,
                            preview: file.link,
                            url: file.link,
                            des: file.name
                        });
                    });
                    $scope.resource.dropbox.data = _.uniqBy($scope.resource.dropbox.data, 'id');
                    $scope.resource.dropbox.filter.total = $scope.resource.dropbox.data.length;
                    jQuery('#tab-photo .loading-photo').hide();
                    break;
                case 'instagram':
                    var endpointUrl = 'https://graph.instagram.com/me/media/?fields=id,media_type,media_url' + '&access_token=' + $scope.resource.instagram.token;
                    $http({method: 'GET', url: endpointUrl}).then(function successCallback(response) {
                        _.each(response.data.data, function (file, index) {
                            if (file.media_type == 'IMAGE') {
                                $scope.resource.instagram.data.push({
                                    extenal: 1,
                                    id: file.id,
                                    preview: file.media_url,
                                    url: file.media_url,
                                    des: ''
                                });
                            }
                        });
                        $scope.resource.instagram.filter.total = $scope.resource.instagram.data.length;
                        jQuery('#tab-photo .loading-photo').hide();
                    }, function errorCallback(response) {
                        jQuery('#tab-photo .loading-photo').hide();
                    });
                    break;
                case 'facebook':
                    $scope.resource.facebook.uid = angular.isDefined(dataObj) ? dataObj[0] : $scope.resource.facebook.uid;
                    $scope.resource.facebook.accessToken = angular.isDefined(dataObj) ? dataObj[1] : $scope.resource.facebook.accessToken;
                    $scope.resource.facebook.nextUrl = $scope.resource.facebook.nextUrl == '' ? "https://graph.facebook.com/v5.0/" + $scope.resource.facebook.uid + "/photos/uploaded/?limit=" + $scope.resource.facebook.filter.perPage + "&fields=source,images,link&access_token=" + $scope.resource.facebook.accessToken : $scope.resource.facebook.nextUrl;
                    /*advanced*/
                    if (typeof mcnb_nbd_js_config_design != "undefined") {
                        $scope.resource.facebook.nextUrl = $scope.resource.facebook.nextUrl == '' ? "https://graph.facebook.com/" + $scope.resource.facebook.uid + "/photos/uploaded/?limit=" + $scope.resource.facebook.filter.perPage + "&fields=source,images,link&access_token=" + $scope.resource.facebook.accessToken : $scope.resource.facebook.nextUrl;
                    }
                    $http({
                        method: 'GET',
                        url: $scope.resource.facebook.nextUrl
                    }).then(function successCallback(response) {
                        var data = response.data;
                        _.each(data.data, function (file, index) {
                            $scope.resource.facebook.data.push({
                                extenal: 1,
                                id: file.id,
                                preview: file.images[file.images.length - 1].source,
                                url: file.source,
                                des: '@ Facebook'
                            });
                        });
                        $scope.resource.facebook.data = _.uniqBy($scope.resource.facebook.data, 'id');
                        $scope.resource.facebook.filter.total = $scope.resource.facebook.data.length;
                        if (data.paging && data.paging.next) {
                            $scope.resource.facebook.nextUrl = data.paging.next;
                            $scope.resource.facebook.filter.total += 1;
                        }
                        ;
                        jQuery('#tab-photo .loading-photo').hide();
                    }, function errorCallback(response) {
                        console.log('loadFacebookPhotos');
                        jQuery('#tab-photo .loading-photo').hide();
                    });
                    break;
            }
        };
        $scope.getInstagramAccessToken = function () {
            $scope.toggleStageLoading();
            NBDDataFactory.get('nbd_get_instagram_token', {code: $scope.resource.instagram.code}, function (data) {
                var data = JSON.parse(data);
                if (data.flag == 1) {
                    $scope.resource.instagram.token = data.access_token;
                    $scope.resource.instagram.uid = data.user_id;
                    $scope.getPersonalPhoto('instagram');
                    setCookie('nbd_instagram_token', $scope.resource.instagram.token, 1 / 25);
                }
                $scope.toggleStageLoading();
            });
        };
        $scope.authenticateInstagram = function () {
            $scope.resource.instagram.token = getCookie('nbd_instagram_token');
            if ($scope.resource.instagram.token != '') {
                $scope.getPersonalPhoto('instagram');
            } else {
                var popupLeft = (window.screen.width - 700) / 2,
                    popupTop = (window.screen.height - 500) / 2;
                var url = 'https://api.instagram.com/oauth/authorize?client_id=' + NBDESIGNCONFIG['nbdesigner_instagram_app_id'] + '&scope=user_profile,user_media&redirect_uri=' + NBDESIGNCONFIG['instagram_redirect_uri'] + '&response_type=code';
                var popup = window.open(url, '_blank', 'width=700,height=500,left=' + popupLeft + ',top=' + popupTop + '');
                popup.onload = new function () {
                    if (window.location.hash.length == 0) {
                        popup.open(url, '_self');
                    }
                    ;
                    var interval = setInterval(function () {
                        try {
                            var url = new URL(popup.location.href),
                                code = url.searchParams.get("code");
                            if (code) {
                                clearInterval(interval);
                                $scope.resource.instagram.code = code;
                                popup.close();
                                $scope.getInstagramAccessToken();
                            }
                        } catch (evt) {
                        }
                    }, 100);
                }
            }
        };
        $scope.logoutInstagram = function () {
            setCookie('nbd_instagram_token', '', -1 / 25);
            $scope.resource.instagram.token = '';
            $scope.resource.instagram.data = [];
            $scope.resource.instagram.filter.currentPage = 1;
            $scope.resource.instagram.filter.total = 0;
            jQuery("#tab-photo .tab-scroll").stop().animate({
                scrollTop: jQuery('.main-items').height()
            }, 100);
        };
        $scope.afterGetResource = function (type) {
            switch (type) {
                case 'clipart':
                    if ($scope.resource.clipart.data.cat.length == 0) $scope.resource.clipart.data.cat = [{
                        id: "0",
                        name: NBDESIGNCONFIG.nbdlangs.cliparts
                    }];
                    if (angular.isDefined(NBDESIGNCONFIG.product_data.option.art_cats)) {
                        $scope.resource.clipart.data.cat = $scope.resource.clipart.data.cat.filter(function (cat) {
                            var cid = cat.id;
                            return NBDESIGNCONFIG.product_data.option.art_cats.indexOf(cid) > -1 || NBDESIGNCONFIG.product_data.option.art_cats.indexOf("" + cid) > -1;
                        });
                    }
                    ;
                    if (angular.isDefined($scope.settings.nbes_enable_settings) && $scope.settings.nbes_enable_settings.clipart == 1
                        && angular.isDefined($scope.settings.nbes_settings) && angular.isDefined($scope.settings.nbes_settings.clipart_cats)) {
                        $scope.resource.clipart.data.cat = $scope.resource.clipart.data.cat.filter(function (cat) {
                            var cid = cat.id;
                            return $scope.settings.nbes_settings.clipart_cats.indexOf(cid) > -1 || $scope.settings.nbes_settings.clipart_cats.indexOf("" + cid) > -1;
                        });
                    }
                    $scope.resource.clipart.data.cat = _.sortBy($scope.resource.clipart.data.cat, 'name');
                    if ($scope.resource.clipart.data.cat.length) {
                        // $scope.resource.clipart.filter.currentCat = $scope.resource.clipart.data.cat[0];
                        $scope.resource[type].filter.total = $scope.resource.clipart.filter.currentCat.amount || 0;
                    } else {
                        $scope.resource.clipart.filter.currentCat = -1;
                        $scope.resource.clipart.filter.currentPage = 0;
                        $scope.resource[type].filter.total = 0;
                    }
                    $scope.resource.clipart.filteredArts = filterArtFilter($scope.resource.clipart.data.arts, $scope.resource.clipart.filter);
                    $scope.resource.clipart.filteredArtsCats = $scope.resource.clipart.filteredArts
                        .reduce((categories, art) => {
                            const category = art.cat[0];
                            if (!categories[category]) {
                                categories[category] = [];
                            }
                            categories[category].push(art);
                            return categories;
                        }, {});
                    $scope.detectSelectedCategoryItems(null);
                    jQuery('#tab-svg').removeClass('nbd-onload');
                    break;
                case 'clipart_all':
                    if ($scope.resource.clipart_all.data.cat.length == 0) $scope.resource.clipart_all.data.cat = [{
                        id: "0",
                        name: NBDESIGNCONFIG.nbdlangs.cliparts
                    }];
                    if (angular.isDefined(NBDESIGNCONFIG.product_data.option.art_cats)) {
                        $scope.resource.clipart_all.data.cat = $scope.resource.clipart_all.data.cat.filter(function (cat) {
                            var cid = cat.id;
                            return NBDESIGNCONFIG.product_data.option.art_cats.indexOf(cid) > -1 || NBDESIGNCONFIG.product_data.option.art_cats.indexOf("" + cid) > -1;
                        });
                    }
                    ;
                    if (angular.isDefined($scope.settings.nbes_enable_settings) && $scope.settings.nbes_enable_settings.clipart == 1
                        && angular.isDefined($scope.settings.nbes_settings) && angular.isDefined($scope.settings.nbes_settings.clipart_cats)) {
                        $scope.resource.clipart_all.data.cat = $scope.resource.clipart_all.data.cat.filter(function (cat) {
                            var cid = cat.id;
                            return $scope.settings.nbes_settings.clipart_cats.indexOf(cid) > -1 || $scope.settings.nbes_settings.clipart_cats.indexOf("" + cid) > -1;
                        });
                    }
                    $scope.resource.clipart_all.data.cat = _.sortBy($scope.resource.clipart_all.data.cat, 'name');
                    if ($scope.resource.clipart_all.data.cat.length) {
                        // $scope.resource.clipart.filter.currentCat = $scope.resource.clipart.data.cat[0];
                        $scope.resource.clipart_all.filter.total = $scope.resource.clipart_all.filter.currentCat.amount || 0;
                    } else {
                        $scope.resource.clipart_all.filter.currentCat = -1;
                        $scope.resource.clipart_all.filter.currentPage = 0;
                        $scope.resource.clipart_all.filter.total = 0;
                    }
                    $scope.resource.clipart_all.filteredArts = filterArtFilter($scope.resource.clipart_all.data.arts, $scope.resource.clipart_all.filter);
                    $scope.resource.clipart_all.filteredArtsCats = $scope.resource.clipart_all.filteredArts
                        .reduce((categories, art) => {
                            const category = art.cat[0];
                            if (!categories[category]) {
                                categories[category] = [];
                            }
                            categories[category].push(art);
                            return categories;
                        }, {});
                    jQuery('#tab-svg').removeClass('nbd-onload');
                    break;
                case 'overlay_all':
                    if ($scope.resource.overlay_all.data.cat.length == 0) $scope.resource.overlay_all.data.cat = [{
                        id: "0",
                        name: NBDESIGNCONFIG.nbdlangs.overlays
                    }];
                    if (angular.isDefined(NBDESIGNCONFIG.product_data.option.overlay_cats)) {
                        $scope.resource.overlay_all.data.cat = $scope.resource.overlay_all.data.cat.filter(function (cat) {
                            var cid = cat.id;
                            return NBDESIGNCONFIG.product_data.option.overlay_cats.indexOf(cid) > -1 || NBDESIGNCONFIG.product_data.option.overlay_cats.indexOf("" + cid) > -1;
                        });
                    }
                    ;
                    if (angular.isDefined($scope.settings.nbes_enable_settings) && $scope.settings.nbes_enable_settings.clipart == 1
                        && angular.isDefined($scope.settings.nbes_settings) && angular.isDefined($scope.settings.nbes_settings.clipart_cats)) {
                        $scope.resource.overlay_all.data.cat = $scope.resource.overlay_all.data.cat.filter(function (cat) {
                            var cid = cat.id;
                            return $scope.settings.nbes_settings.overlay_cats.indexOf(cid) > -1 || $scope.settings.nbes_settings.overlay_cats.indexOf("" + cid) > -1;
                        });
                    }
                    $scope.resource.overlay_all.data.cat.sort(function (a, b) {
                        return a.name.localeCompare(b.name, undefined, {
                            numeric: true,
                            sensitivity: 'base'
                        });
                    });
                    if ($scope.resource.overlay_all.data.cat.length) {
                        // $scope.resource.overlay.filter.currentCat = $scope.resource.overlay.data.cat[0];
                        $scope.resource.overlay_all.filter.total = $scope.resource.overlay_all.filter.currentCat.amount || 0;
                    } else {
                        $scope.resource.overlay_all.filter.currentCat = -1;
                        $scope.resource.overlay_all.filter.currentPage = 0;
                        $scope.resource.overlay_all.filter.total = 0;
                    }
                    $scope.resource.overlay_all.filteredArts = filterArtFilter($scope.resource.overlay_all.data.arts, $scope.resource.overlay_all.filter);
                    $scope.resource.overlay_all.filteredOverlaysCats = $scope.resource.overlay_all.filteredOverlays
                        .reduce((categories, overlay) => {
                            const category2 = overlay.cat[0];
                            if (!categories[category2]) {
                                categories[category2] = [];
                            }
                            categories[category2].push(overlay);
                            return categories;
                        }, {});
                    jQuery('#tab-overlay').removeClass('nbd-onload');
                    break;
                case 'photo':
                    if ($scope.resource.photo.data.length == 0) jQuery('#tab-photo .loading-photo').hide();
                    $scope.resource.photo.filter.total = $scope.resource.photo.filter.totalPage * $scope.resource.photo.filter.perPage;
                    break;
            }
            if (typeof bagr_background != 'undefined') {
                /*advanced*/
                if (type == 'background') {
                    if ($scope.resource.background.data.cat.length == 0) $scope.resource.background.data.cat = [{
                        id: "0",
                        name: NBDESIGNCONFIG.nbdlangs.backgrounds
                    }];
                    _.each($scope.resource.background.data.cat, function (cat, key) {
                        cat.amount = 0;
                        _.each($scope.resource.background.data.backgrounds, function (background, k) {
                            background.url = background.url.indexOf("http") > -1 ? background.url : NBDESIGNCONFIG['background_url'] + background.url;
                            if (background.cat.length == 0) background.cat = ["0"];
                            if (_.includes(background.cat, cat.id)) cat.amount++
                        });
                    });
                    $scope.resource.background.data.cat = _.sortBy($scope.resource.background.data.cat, 'name');
                    if ($scope.resource.background.data.cat.length) {
                        $scope.resource.background.filter.currentCat = $scope.resource.background.data.cat[0];
                        $scope.resource[type].filter.total = $scope.resource.background.filter.currentCat.amount;
                    } else {
                        $scope.resource.background.filter.currentCat = -1;
                        $scope.resource.background.filter.currentPage = 0;
                        $scope.resource[type].filter.total = 0;
                    }
                    jQuery('#tab-background').removeClass('nbd-onload');
                }
            }
            /*advanced*/
            if (typeof ssnb_nbd_js_config != 'undefined') {
                if (type == 'block') {
                    if ($scope.resource.block.data.cat.length == 0) $scope.resource.block.data.cat = [{
                        id: "0",
                        name: NBDESIGNCONFIG.nbdlangs.blocks
                    }];
                    _.each($scope.resource.block.data.cat, function (cat, key) {
                        cat.amount = 0;
                        _.each($scope.resource.block.data.blocks, function (block, k) {
                            block.url = block.url.indexOf("http") > -1 ? block.url : NBDESIGNCONFIG['block_url'] + block.url;
                            if (block.cat.length == 0) block.cat = ["0"];
                            if (_.includes(block.cat, cat.id)) cat.amount++
                        });
                    });
                    $scope.resource.block.data.cat = _.sortBy($scope.resource.block.data.cat, 'name');
                    if ($scope.resource.block.data.cat.length) {
                        $scope.resource.block.filter.currentCat = $scope.resource.block.data.cat[0];
                        $scope.resource[type].filter.total = $scope.resource.block.filter.currentCat.amount;
                    } else {
                        $scope.resource.block.filter.currentCat = -1;
                        $scope.resource.block.filter.currentPage = 0;
                        $scope.resource[type].filter.total = 0;
                    }
                    jQuery('#tab-block').removeClass('nbd-onload');
                }
            }
            /*advanced*/
            if (typeof udc_nbd_js_config != "undefined") {
                if (type == 'overlay') {
                    if ($scope.resource.overlay.data.cat.length == 0) $scope.resource.overlay.data.cat = [{
                        id: "0",
                        name: NBDESIGNCONFIG.nbdlangs.overlays
                    }];
                    _.each($scope.resource.overlay.data.cat, function (cat, key) {
                        cat.amount = 0;
                        _.each($scope.resource.overlay.data.overlays, function (overlay, k) {
                            overlay.url = overlay.url.indexOf("http") > -1 ? overlay.url : NBDESIGNCONFIG['overlay_url'] + overlay.preview;
                            overlay.file_url = overlay.file.indexOf("http") > -1 ? overlay.file : NBDESIGNCONFIG['overlay_url'] + overlay.file;
                            if (overlay.cat.length == 0) overlay.cat = ["0"];
                            if (_.includes(overlay.cat, cat.id)) cat.amount++
                        });
                    });
                    $scope.resource.overlay.data.cat = _.sortBy($scope.resource.overlay.data.cat, 'name');
                    $scope.resource.overlay.data.cat.sort(function (a, b) {
                        return a.name.localeCompare(b.name, undefined, {
                            numeric: true,
                            sensitivity: 'base'
                        });
                    });
                    if ($scope.resource.overlay.data.cat.length) {
                        //    $scope.resource.overlay.filter.currentCat = $scope.resource.overlay.data.cat[0];
                        $scope.resource[type].filter.total = $scope.resource.overlay.filter.currentCat.amount || 0;
                    } else {
                        $scope.resource.overlay.filter.currentCat = -1;
                        $scope.resource.overlay.filter.currentPage = 0;
                        $scope.resource[type].filter.total = 0;
                    }
                    $scope.resource.overlay.filteredOverlays = filterArtFilter($scope.resource.overlay.data.overlays, $scope.resource.overlay.filter);
                    $scope.resource.overlay.filteredOverlaysCats = $scope.resource.overlay.filteredOverlays
                        .reduce((categories, overlay) => {
                            const category2 = overlay.cat[0];
                            if (!categories[category2]) {
                                categories[category2] = [];
                            }
                            categories[category2].push(overlay);
                            return categories;
                        }, {});
                    $scope.detectSelectedOverlayCategoryItems(null);
                    jQuery('#tab-overlay').removeClass('nbd-onload');
                }
            }
        };

        $scope.handleClipartBackClick = function () {
            const parentId = Number($scope.resource.clipart.filter.currentCat.parent_id);
            if (parentId) {
                const parent = $scope.resource.clipart.data.cat
                    .filter((cat) => Number(cat.id) === parentId)[0];
                if (!parent) {
                    $scope.resetCat('clipart')
                    return;
                }
                $scope.changeCat('clipart', parent);
            } else {
                $scope.resetCat('clipart')
            }
        }
        $scope.handleOverlayBackClick = function () {
            const parentId = Number($scope.resource.overlay.filter.currentCat.parent_id);
            if (parentId) {
                const parent = $scope.resource.overlay.data.cat
                    .filter((cat) => Number(cat.id) === parentId)[0];
                if (!parent) {
                    $scope.resetCat2('overlay')
                    return;
                }
                $scope.changeCat2('overlay', parent);
            } else {
                $scope.resetCat2('overlay')
            }
        }
        $scope.changeCat2 = function (type, cat) {
            const overlayTab = document.querySelector('.tab-scroll-overlay');
            if (overlayTab) {
                overlayTab.scrollTop = 0;
            }
            $scope.detectSelectedOverlayCategoryItems(cat);
            $scope.resource[type].filter.search = '';
            $scope.resource[type].filter.currentPage = 1;
            $scope.resource[type].filter.currentCat = cat;
            $scope.resource[type].filter.total = cat.hasOwnProperty('amount') ? (cat.amount || 0) : (cat.total || 0);
            if (type === 'overlay') {
                $scope.resource['overlay'].filter.categoryPerPage = 10;
                $scope.resource['overlay'].filter.searchPerPage = 25;
                $scope.resource['overlay'].filter.perPage = 25;
            }
            $scope.updateApp();
        };
        $scope.changeCatIcon = function (type, cat) {
            $scope.resource[type].filter.search = '';
            $scope.resource[type].filter.currentPage = 1;
            $scope.resource[type].filter.currentCat = cat;
            $scope.resource[type].filter.total = cat.amount ? cat.amount : cat.total;
            $scope.updateApp();
            switch (type) {
                case 'clipart':
                    jQuery("#tab-svg .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);
                    break;
                case 'icon':
                    $scope.resource.element.contentSearch = '';
                    jQuery("#tab-element .tab-scroll .content-item .type-icons").stop().animate({
                        scrollTop: 0
                    }, 100);
                    jQuery("#tab-element .tab-scroll .content-item .type-icons").perfectScrollbar('update');
                    jQuery("#tab-element .tab-scroll ./*advanced*/ .type-icons .mansory-wrap").css('height', 0);
                    $scope.getMedia('icon', 'search');
                    break;
            }
            ;
        }
        $scope.changeCat = function (type, cat) {
            if (typeof nbd_color_clipart != "undefined") {
                if (cat.color != '' || cat.color != 'undefined') {
                    __colorPalette = [];
                    var _colors = cat.color.split(',');
                    for (var i = 0; i < _colors.length; ++i) {
                        color = _colors[i].split(':')[0];
                        __colorPalette.push(color);
                    }
                    $scope.__colorPalette = __colorPalette;
                }
                if (cat.fonts != '' || cat.fonts != 'undefined') {
                    if (cat.fonts_custom != null && cat.fonts != null) {
                        var children = cat.fonts.concat(cat.fonts_custom);
                    }
                    if (cat.fonts_custom != null && cat.fonts == null) {
                        var children = cat.fonts_custom;
                    }
                    if (cat.fonts_custom == null && cat.fonts != null) {
                        var children = cat.fonts;
                    }
                    $scope.resource.font.data = children;
                    $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
                }
            }
            const clipartTab = document.querySelector('.tab-scroll-clipart');
            if (clipartTab) {
                clipartTab.scrollTop = 0;
            }
            $scope.detectSelectedCategoryItems(cat);
            $scope.resource[type].filter.search = '';
            $scope.resource[type].filter.currentPage = 1;
            $scope.resource[type].filter.currentCat = cat;
            $scope.resource[type].filter.total = cat.hasOwnProperty('amount') ? (cat.amount || 0) : (cat.total || 0);
            if (type === 'clipart') {
                $scope.resource['clipart'].filter.categoryPerPage = 10;
                $scope.resource['clipart'].filter.searchPerPage = 25;
                $scope.resource['clipart'].filter.perPage = 25;
            }
            $scope.updateApp();
            switch (type) {
                case 'icon':
                    $scope.resource.element.contentSearch = '';
                    jQuery("#tab-element .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);
                    jQuery("#tab-element .tab-scroll").perfectScrollbar('update');
                    jQuery("#tab-element .tab-scroll .result-loaded .type-icons .mansory-wrap").css('height', 0);
                    $scope.getMedia('icon', 'search');
                    break;
                default:
                    break;
            }
            ;
            if (typeof bagr_background != 'undefined') {
                /*advanced*/
                if (type == 'background') {
                    jQuery("#tab-background .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);
                }
            }
            /*advanced*/
            if (typeof ssnb_nbd_js_config != 'undefined') {
                if (type == 'block') {
                    jQuery("#tab-block .tab-scroll").stop().animate({
                        scrollTop: 0
                    }, 100);
                }
            }

        };
        $scope.detectSelectedCategoryItems = function (cat) {
            if (!cat) {
                const rootCategories = $scope.resource.clipart.data.cat
                    .filter((c) => !c.parent_id);
                rootCategories.forEach((c) => {
                    const subcategories = $scope.resource.clipart.data.cat.filter(
                        (category) => Number(category.parent_id) === Number(c.id)
                    );
                    if (subcategories.length < 3) {
                        $scope.resource.selectedCategoryItems = [
                            ...$scope.resource.selectedCategoryItems,
                            ...$scope.resource.clipart.filteredArts.filter((item) =>
                                item.cat.includes(String(c.id))
                            )
                        ];
                    } else {
                        const subcategoriesItems = subcategories
                            .map((subcategory) =>
                                $scope.resource.clipart.filteredArtsCats[subcategory.id]
                                    ? $scope.resource.clipart.filteredArtsCats[subcategory.id]
                                    : null
                            )
                            .filter((item) => !!item);
                        $scope.resource.selectedCategoryItems = [...$scope.resource.selectedCategoryItems, ..._.flatten(subcategoriesItems)];
                    }
                });
            } else {
                const subcategories = $scope.resource.clipart.data.cat.filter(
                    (category) => Number(category.parent_id) === Number(cat.id)
                );
                if (subcategories.length < 3) {
                    $scope.resource.selectedCategoryItems =
                        $scope.resource.clipart.filteredArts.filter((item) =>
                            item.cat.includes(String(cat.id))
                        );
                } else {
                    const subcategoriesItems = subcategories
                        .map((subcategory) =>
                            $scope.resource.clipart.filteredArtsCats[subcategory.id]
                                ? $scope.resource.clipart.filteredArtsCats[subcategory.id]
                                : null
                        )
                        .filter((item) => !!item);
                    $scope.resource.selectedCategoryItems = [..._.flatten(subcategoriesItems)];
                }
            }
            $scope.updateApp();
        };
        $scope.detectSelectedOverlayCategoryItems = function (cat) {
            if (!cat) {
                const rootCategories2 = $scope.resource.overlay.data.cat
                    .filter((c) => !c.parent_id);
                rootCategories2.forEach((c) => {
                    const subcategories = $scope.resource.overlay.data.cat.filter(
                        (category2) => Number(category2.parent_id) === Number(c.id)
                    );
                    if (subcategories.length < 3) {
                        $scope.resource.selectedOverlayCategoryItems = [
                            ...$scope.resource.selectedOverlayCategoryItems,
                            ...$scope.resource.overlay.filteredOverlays.filter((item) =>
                                item.cat.includes(String(c.id))
                            )
                        ];
                    } else {
                        const subcategoriesItems2 = subcategories
                            .map((subcategory) =>
                                $scope.resource.overlay.filteredOverlaysCats[subcategory.id]
                                    ? $scope.resource.overlay.filteredOverlaysCats[subcategory.id]
                                    : null
                            )
                            .filter((item) => !!item);
                        $scope.resource.selectedOverlayCategoryItems = [...$scope.resource.selectedOverlayCategoryItems, ..._.flatten(subcategoriesItems2)];
                    }
                });
            } else {
                const subcategories = $scope.resource.overlay.data.cat.filter(
                    (category2) => Number(category2.parent_id) === Number(cat.id)
                );
                if (subcategories.length < 3) {
                    $scope.resource.selectedOverlayCategoryItems =
                        $scope.resource.overlay.filteredOverlays.filter((item) =>
                            item.cat.includes(String(cat.id))
                        );
                } else {
                    const subcategoriesItems2 = subcategories
                        .map((subcategory) =>
                            $scope.resource.overlay.filteredOverlaysCats[subcategory.id]
                                ? $scope.resource.overlay.filteredOverlaysCats[subcategory.id]
                                : null
                        )
                        .filter((item) => !!item);
                    $scope.resource.selectedOverlayCategoryItems = [..._.flatten(subcategoriesItems2)];
                }
            }
            $scope.updateApp();
        };
        $scope.resetCat = function (type) {
            $scope.resource.selectedCategoryItems = [];
            $scope.detectSelectedCategoryItems();
            $scope.resource[type].filter.currentCat = {};
            $scope.updateApp();
            jQuery("#tab-svg .tab-scroll").stop().animate({
                scrollTop: 0
            }, 100);
        }
        $scope.resetCat2 = function (type) {
            $scope.resource.selectedOverlayCategoryItems = [];
            $scope.detectSelectedOverlayCategoryItems();
            $scope.resource[type].filter.currentCat = {};
            $scope.updateApp();
            jQuery("#tab-overlay .tab-scroll").stop().animate({
                scrollTop: 0
            }, 100);
        }
        /* Change printing options */
        $scope.onLoadPrintingOptions = false;
        $scope.firstTimeLoadPrintingOptions = true;
        $scope.awaitInsertTemplate = false;
        $scope.awaitSubmitForm = false;
        $scope.lastPrintingOptions = {};
        $scope.onChangePrintingOptions = false;
        $scope.applyOptions = function () {
            jQuery('.nbd-popup.popup-nbo-options .close-popup').triggerHandler('click');
            if (angular.isDefined(NBDESIGNCONFIG.force_hide_option) && NBDESIGNCONFIG.nbdesigner_display_product_option == '1') {
                $scope.awaitSubmitForm = true;
                if (angular.isDefined(nbd_window.nbOption)) {
                    var hasOdOption = false;
                    angular.forEach(nbd_window.nbOption.odOption, function (option) {
                        hasOdOption = true;
                    });
                    if (!hasOdOption) {
                        $scope.saveData();
                    }
                } else {
                    $scope.saveData();
                }
            }
            ;
            $scope.changePrintingOptions();
        };
        $scope.changePrintingOptions = function (first, initVariationSetting) {
            /*advanced*/
            if (typeof abst_check_design_visual != "undefined" && appConfig.isVisual) {
                return;
            }
            if ($scope.onloadVariation) return;
            jQuery('.cannot-start-design-notice').removeClass('nbd-show');
            if (angular.isDefined(nbd_window.nbOption)) {
                if ($scope.firstTimeLoadPrintingOptions) {
                    //if( NBDESIGNCONFIG['ui_mode'] == 1 || $scope.settings.nbdesigner_display_product_option == '2' ){
                    if ($scope.completedInsertTemplate) {
                        $scope.firstTimeLoadPrintingOptions = false;
                        $scope.awaitInsertTemplate = false;
                    } else {
                        $scope.awaitInsertTemplate = true;
                        return;
                    }
                    //} else {
                    //    $scope.firstTimeLoadPrintingOptions = false;
                    //}
                }
                if (angular.equals(nbd_window.nbOption.odOption, $scope.lastPrintingOptions)) {
                    if (!initVariationSetting) {
                        if (angular.isUndefined(first) && angular.isDefined(nbd_window.nbOption.extraOdOption)) {
                            $scope.changeExtraOdOptions();
                            $scope.updateApp();
                        }
                        return;
                    }
                } else {
                    angular.copy(nbd_window.nbOption.odOption, $scope.lastPrintingOptions);
                }
                var data = nbd_window.nbOption.odOption;
                if (angular.isUndefined($scope.stored_product) || initVariationSetting) {
                    $scope.stored_product = [];
                    angular.copy($scope.settings.product_data.product, $scope.stored_product);
                } else {
                    $scope.settings.product_data.product = [];
                    angular.copy($scope.stored_product, $scope.settings.product_data.product);
                }
                ;
                $scope.settings.product_data.option.option_dpi = false;
                if (angular.isDefined(data.dpi)) {
                    $scope.settings.product_data.option.dpi = data.dpi;
                    $scope.settings.product_data.option.option_dpi = true;
                }
                if (angular.isDefined(data.unit)) {
                    $scope.settings.product_data.option.unit = data.unit;
                }
                if (angular.isDefined(data.page)) {
                    $scope.currentStage = 0;
                    var number_side = $scope.settings.product_data.product.length;
                    if (angular.isDefined(data.page.list_page)) {
                        if (data.page.list_page.length > 0) {
                            $scope.settings.product_data.product = [];
                            angular.forEach(data.page.list_page, function (side, key) {
                                if (angular.isDefined($scope.stored_product[side])) {
                                    $scope.settings.product_data.product.push($scope.stored_product[side])
                                } else if (angular.isDefined($scope.settings.product_data.product[number_side - 1])) {
                                    var temp = angular.copy($scope.settings.product_data.product[number_side - 1], temp);
                                    $scope.settings.product_data.product.push(temp);
                                }
                            });
                            if ($scope.settings.product_data.product.length == 0) {
                                angular.copy($scope.stored_product, $scope.settings.product_data.product);
                            }
                        } else {
                            jQuery('.cannot-start-design-notice').addClass('nbd-show');
                            return;
                        }
                    } else {
                        var number_side = $scope.settings.product_data.product.length;
                        var src_side_index = number_side - 1,
                            insert_side_index = number_side - 1,
                            dst_number_side = data.page.number,
                            lastJsonDesign = {},
                            _canvas = $scope.stages[src_side_index]['canvas'];
                        _canvas.requestRenderAll();
                        lastJsonDesign = _canvas.toJSON($scope.includeExport);
                        angular.copy($scope.stored_product, $scope.settings.product_data.product);
                        if (data.page.page_display == '1') {
                            if (data.page.exclude_page == '2') {
                                if (number_side > 2) {
                                    src_side_index = number_side - 2;
                                    insert_side_index = number_side - 2;
                                }
                                dst_number_side += 2;
                            }
                        } else {
                            if (data.page.exclude_page == '2') {
                                dst_number_side = Math.ceil(dst_number_side / 2) + 1;
                            } else {
                                dst_number_side = Math.ceil(dst_number_side / 2);
                            }
                        }
                        if (dst_number_side < number_side) {
                            $scope.settings.product_data.product.splice(dst_number_side - 1, number_side - dst_number_side);
                            for (i = dst_number_side; i < number_side; i++) {
                                delete $scope.resource.jsonDesign['frame_' + dst_number_side];
                            }
                        } else if (dst_number_side > number_side) {
                            var i;
                            for (i = 0; i < dst_number_side - number_side; i++) {
                                var temp = {};
                                angular.copy($scope.settings.product_data.product[src_side_index], temp);
                                if (data.page.page_display == '1' && data.page.exclude_page == '2') temp.orientation_name = NBDESIGNCONFIG.nbdlangs.page + ' ' + insert_side_index;
                                $scope.settings.product_data.product.splice(insert_side_index, 0, temp);
                                insert_side_index++;
                            }
                        }
                        $scope.stored_product = [];
                        angular.copy($scope.settings.product_data.product, $scope.stored_product);
                    }
                }
                if (angular.isDefined(data.color)) {
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        delete side.pattern;
                        if (data.color.bg_type == 'c') {
                            side.bg_type = 'color';
                            side.bg_color_value = data.color.bg_color;
                        } else {
                            side.bg_type = 'image';
                            if (angular.isDefined(data.page) && angular.isDefined(data.page.list_page)) {
                                if (angular.isDefined(data.page.list_page[key])) {
                                    var _key = data.page.list_page[key];
                                    if (angular.isDefined(data.color.bg_image[_key])) side.img_src = data.color.bg_image[_key];
                                }
                            } else {
                                if (angular.isDefined(data.color.bg_image[key])) side.img_src = data.color.bg_image[key];
                            }
                        }
                    });
                }
                if (angular.isDefined(data.size)) {
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        /*advanced*/
                        if (typeof rrco_nbd_js_config_design != "undefined") {
                            if (angular.isDefined(data.size.overlay_url) && data.size.overlay_url != "") {
                                if (data.size.overlay != 0) {
                                    side.img_overlay = data.size.overlay_url;
                                    side.show_overlay = 1;
                                }
                            }
                        }
                        side.product_height = data.size.product_height;
                        side.product_width = data.size.product_width;
                        side.real_width = data.size.real_width;
                        side.real_height = data.size.real_height;
                        side.real_left = data.size.real_left;
                        side.real_top = data.size.real_top;
                        /*advanced*/
                        if (typeof ncdp_nbd_js_config != "undefined") {
                            side.img_src = data.size.image_link;
                            side.product_height = data.size.sides[key].product_height;
                            side.product_width = data.size.sides[key].product_width;
                            side.real_width = data.size.sides[key].real_width;
                            side.real_height = data.size.sides[key].real_height;
                            side.real_left = data.size.sides[key].real_left;
                            side.real_top = data.size.sides[key].real_top;
                        }
                        ['bleed_top_bottom', 'bleed_left_right', 'margin_top_bottom', 'margin_left_right'].map(function (att) {
                            if (angular.isDefined(data.size[att])) {
                                side[att] = data.size[att];
                            }
                        });
                        var ratio = side.product_width / side.product_height;
                        side.img_src_top = side.img_src_left = 0;
                        if (ratio > 1) {
                            side.img_src_width = 500;
                            side.area_design_width = side.real_width / side.product_width * 500;
                            side.area_design_height = side.real_height / side.product_width * 500;
                            side.img_src_height = 500 / ratio;
                            side.img_src_top = (500 - side.img_src_height) / 2;
                            side.area_design_left = side.real_left / side.product_width * 500;
                            side.area_design_top = side.real_top / side.product_width * 500 + side.img_src_top;
                        } else {
                            side.img_src_height = 500;
                            side.area_design_height = side.real_height / side.product_height * 500;
                            side.area_design_width = side.real_width / side.product_height * 500;
                            side.img_src_width = 500 * ratio;
                            side.img_src_left = (500 - side.img_src_width) / 2;
                            side.area_design_left = side.real_left / side.product_height * 500 + side.img_src_left;
                            side.area_design_top = side.real_top / side.product_height * 500;
                        }
                    });
                }
                if (angular.isDefined(data.dimension)) {
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        side.product_height = data.dimension.height;
                        side.product_width = data.dimension.width;
                        side.real_width = data.dimension.width;
                        side.real_height = data.dimension.height;
                        side.real_left = side.real_top = side.img_src_top = side.img_src_left = side.area_design_left = side.area_design_top = 0;
                        var ratio = side.product_width / side.product_height;
                        if (ratio > 1) {
                            side.img_src_width = 500;
                            side.area_design_width = 500;
                            side.img_src_height = 500 / ratio;
                            side.area_design_height = 500 / ratio;
                            side.img_src_top = (500 - side.img_src_height) / 2;
                            side.area_design_top = side.img_src_top;
                        } else {
                            side.img_src_height = 500;
                            side.area_design_height = 500;
                            side.img_src_width = 500 * ratio;
                            side.area_design_width = 500 * ratio;
                            side.img_src_left = (500 - side.img_src_width) / 2;
                            side.area_design_left = side.img_src_left;
                        }
                    });
                }
                if (angular.isDefined(data.orientation)) {
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        var productWidth = parseFloat(side.product_width),
                            productHeight = parseFloat(side.product_height);
                        if ((data.orientation == 1 && productWidth < productHeight) || (data.orientation == 0 && productHeight < productWidth)) {
                            var tem = 1 * side.product_width;
                            side.product_width = 1 * side.product_height;
                            side.product_height = tem;
                            tem = 1 * side.img_src_width;
                            side.img_src_width = 1 * side.img_src_height;
                            side.img_src_height = tem;
                            tem = 1 * side.real_width;
                            side.real_width = 1 * side.real_height;
                            side.real_height = tem;
                            tem = 1 * side.img_src_top;
                            side.img_src_top = 1 * side.img_src_left;
                            side.img_src_left = tem;
                            tem = 1 * side.area_design_width;
                            side.area_design_width = 1 * side.area_design_height;
                            side.area_design_height = tem;
                            tem = 1 * side.bleed_top_bottom;
                            side.bleed_top_bottom = 1 * side.bleed_left_right;
                            side.bleed_left_right = tem;
                            tem = 1 * side.margin_top_bottom;
                            side.margin_top_bottom = 1 * side.margin_left_right;
                            side.margin_left_right = tem;
                            if (data.orientation == 1) {
                                tem = side.real_left;
                                side.real_left = side.real_top;
                                side.real_top = side.product_height - side.real_height - tem;
                            } else {
                                tem = side.real_top;
                                side.real_top = side.real_left;
                                side.real_left = side.product_width - side.real_width - tem;
                            }
                            side.area_design_top = side.img_src_top + side.real_top / side.product_width * side.img_src_width;
                            side.area_design_left = side.img_src_left + side.real_left / side.product_width * side.img_src_width;
                        }
                    });
                }
                if (angular.isDefined(data.area)) {
                    /*                 angular.forEach($scope.settings.product_data.product, function(side, key){
                    side.area_design_type = data.area;
                }); */
                    $timeout(function () {
                        var _canvas = $scope.stages[0].canvas,
                            width = _canvas.width,
                            height = _canvas.height;
                        if (data.area == 2) {
                            nbd_window.nbOption.extraOdOption.shape = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 ' + width + ' ' + height + '" ><path fill="rgba(0,0,0,0.001)" d="M0 ' + height / 2 + 'A ' + width / 2 + ' ' + height / 2 + ' 0 0 0 ' + width + ' ' + height / 2 + ' A ' + width / 2 + ' ' + height / 2 + ' 0 0 0 0 ' + height / 2 + 'z"/></svg>';
                        } else {
                            nbd_window.nbOption.extraOdOption.shape = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 ' + width + ' ' + height + '" ><path fill="rgba(0,0,0,0.001)" d="M0 0 H' + width + ' V' + height + ' H0 V0z"/></svg>';
                        }
                        $scope.changeExtraOdOptions();
                    }, 1000);
                }
                if (angular.isDefined(data.padding)) {
                    var padding = parseFloat(data.padding);
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        side.product_height = 2 * padding + parseFloat(side.product_height);
                        side.product_width = 2 * padding + parseFloat(side.product_width);
                        side.real_left = padding + parseFloat(side.real_left);
                        side.real_top = padding + parseFloat(side.real_top);
                        var ratio = side.product_width / side.product_height;
                        if (ratio > 1) {
                            side.img_src_width = 500;
                            side.area_design_width = side.real_width / side.product_width * 500;
                            side.area_design_height = side.real_height / side.product_width * 500;
                            side.img_src_height = 500 / ratio;
                            side.img_src_left = 0;
                            side.img_src_top = (500 - side.img_src_height) / 2;
                            side.area_design_left = side.real_left / side.product_width * 500;
                            side.area_design_top = side.real_top / side.product_width * 500 + side.img_src_top;
                        } else {
                            side.img_src_height = 500;
                            side.area_design_height = side.real_height / side.product_height * 500;
                            side.area_design_width = side.real_width / side.product_height * 500;
                            side.img_src_width = 500 * ratio;
                            side.img_src_top = 0;
                            side.img_src_left = (500 - side.img_src_width) / 2;
                            side.area_design_left = side.real_left / side.product_height * 500 + side.img_src_left;
                            side.area_design_top = side.real_top / side.product_height * 500;
                        }
                    });
                }
                if (angular.isUndefined(first)) {
                    $scope.saveDesign();
                    if (angular.isDefined(data.page) && angular.isUndefined(data.page.list_page) && data.page.page_display == '1' && data.page.exclude_page == '2') {
                        if (angular.isDefined($scope.resource.jsonDesign['frame_' + (number_side - 1)])) {
                            $scope.resource.jsonDesign['frame_' + (number_side - 1)] = {
                                objects: [],
                                version: lastJsonDesign.version
                            };
                        }
                        $scope.resource.jsonDesign['frame_' + (dst_number_side - 1)] = {};
                        angular.copy(lastJsonDesign, $scope.resource.jsonDesign['frame_' + (dst_number_side - 1)]);
                    }
                    appConfig.ready = false;
                    /*nbdesigne advanced*/
                    if (typeof mcnb_nbd_js_config_design != "undefined") {
                        $scope.forceInitStage = false;
                        if (data.color.bg_type == 'c' || angular.isDefined(data.area)) {
                            $scope.forceInitStage = true;
                        }
                    }
                    // Dubois Julien Custom for NBDesigner Advanced
                    if (typeof nbd_customize_option_color != 'undefined') {
                        $scope.forceInitStage = false;
                    }
                    /*                 if( angular.isDefined( data.area ) ){
                    $scope.forceInitStage = true;
                }else{ */
                    $scope.settings.product_data.config = {};
                    $scope.settings.product_data.config.viewport = $scope.viewPort;
                    $scope.settings.product_data.fonts = $scope.resource.usedFonts;
                    $scope.preventChangeCurrentDesign = true;
                    $scope.needLoadVariationDesign();
                    if (!$scope.forceLoadVariationDesign) $scope.settings.product_data.design = $scope.resource.jsonDesign;
                    //};
                    $scope.currentStage = 0;
                    $scope.onChangePrintingOptions = true;
                    $scope.processProductSettings();
                    $scope.changeExtraOdOptions();
                    $scope.updateApp();
                }
            }
        };
        $scope.changePagesPrintingOptions = function (first, initVariationSetting, handleOrientation = true) {
            if (angular.isDefined(nbd_window.nbOption)) {
                var data = nbd_window.nbOption.odOption;
                if (!$scope.productChangeOptions.applyToCurrentPage) {
                    $scope.settings.product_data.option.option_dpi = false;
                    if (angular.isDefined(data.dpi)) {
                        $scope.settings.product_data.option.dpi = data.dpi;
                        $scope.settings.product_data.option.option_dpi = true;
                    }
                } else {
                    angular.forEach($scope.settings.product_data.product, function (side, index) {
                        if (index !== $scope.currentStage) {
                            return;
                        }
                        side.dpi = data.dpi;
                    });
                }
                if (angular.isDefined(data.unit)) {
                    if (!$scope.productChangeOptions.applyToCurrentPage) {
                        $scope.settings.product_data.option.unit = data.unit;
                        angular.forEach($scope.settings.product_data.product, function (side, index) {
                            side.unit = data.unit;
                        });
                    } else {
                        angular.forEach($scope.settings.product_data.product, function (side, index) {
                            if (index !== $scope.currentStage) {
                                return;
                            }
                            side.unit = data.unit;
                        });
                    }
                }
                if (angular.isDefined(data.size)) {
                    angular.forEach($scope.settings.product_data.product, function (side, index) {
                        if ($scope.productChangeOptions.applyToCurrentPage && index !== $scope.currentStage) {
                            return;
                        }
                        side.product_height = data.size.product_height;
                        side.product_width = data.size.product_width;
                        side.real_width = data.size.real_width;
                        side.real_height = data.size.real_height;
                        side.real_left = data.size.real_left;
                        side.real_top = data.size.real_top;
                        ['bleed_top_bottom', 'bleed_left_right', 'margin_top_bottom', 'margin_left_right'].map(function (att) {
                            if (angular.isDefined(data.size[att])) {
                                side[att] = data.size[att];
                            }
                        });
                        var ratio = side.product_width / side.product_height;
                        side.img_src_top = side.img_src_left = 0;
                        if (ratio > 1) {
                            side.img_src_width = 500;
                            side.area_design_width = side.real_width / side.product_width * 500;
                            side.area_design_height = side.real_height / side.product_width * 500;
                            side.img_src_height = 500 / ratio;
                            side.img_src_top = (500 - side.img_src_height) / 2;
                            side.area_design_left = side.real_left / side.product_width * 500;
                            side.area_design_top = side.real_top / side.product_width * 500 + side.img_src_top;
                        } else {
                            side.img_src_height = 500;
                            side.area_design_height = side.real_height / side.product_height * 500;
                            side.area_design_width = side.real_width / side.product_height * 500;
                            side.img_src_width = 500 * ratio;
                            side.img_src_left = (500 - side.img_src_width) / 2;
                            side.area_design_left = side.real_left / side.product_height * 500 + side.img_src_left;
                            side.area_design_top = side.real_top / side.product_height * 500;
                        }
                    });
                }
                if (angular.isDefined(data.dimension)) {
                    angular.forEach($scope.settings.product_data.product, function (side, index) {
                        if ($scope.productChangeOptions.applyToCurrentPage && index !== $scope.currentStage) {
                            return;
                        }
                        side.product_height = data.dimension.height;
                        side.product_width = data.dimension.width;
                        side.real_width = data.dimension.width;
                        side.real_height = data.dimension.height;
                        side.real_left = side.real_top = side.img_src_top = side.img_src_left = side.area_design_left = side.area_design_top = 0;
                        var ratio = side.product_width / side.product_height;
                        if (ratio > 1) {
                            side.img_src_width = 500;
                            side.area_design_width = 500;
                            side.img_src_height = 500 / ratio;
                            side.area_design_height = 500 / ratio;
                            side.img_src_top = (500 - side.img_src_height) / 2;
                            side.area_design_top = side.img_src_top;
                        } else {
                            side.img_src_height = 500;
                            side.area_design_height = 500;
                            side.img_src_width = 500 * ratio;
                            side.area_design_width = 500 * ratio;
                            side.img_src_left = (500 - side.img_src_width) / 2;
                            side.area_design_left = side.img_src_left;
                        }
                    });
                }
                if (angular.isDefined(data.orientation) && handleOrientation) {
                    angular.forEach($scope.settings.product_data.product, function (side, index) {
                        if ($scope.productChangeOptions.applyToCurrentPage && index !== $scope.currentStage) {
                            return;
                        }
                        var productWidth = parseFloat(side.product_width),
                            productHeight = parseFloat(side.product_height);
                        if ((data.orientation == 1 && productWidth < productHeight) || (data.orientation == 0 && productHeight < productWidth)) {
                            var tem = 1 * side.product_width;
                            side.product_width = 1 * side.product_height;
                            side.product_height = tem;
                            tem = 1 * side.img_src_width;
                            side.img_src_width = 1 * side.img_src_height;
                            side.img_src_height = tem;
                            tem = 1 * side.real_width;
                            side.real_width = 1 * side.real_height;
                            side.real_height = tem;
                            tem = 1 * side.img_src_top;
                            side.img_src_top = 1 * side.img_src_left;
                            side.img_src_left = tem;
                            tem = 1 * side.area_design_width;
                            side.area_design_width = 1 * side.area_design_height;
                            side.area_design_height = tem;
                            tem = 1 * side.bleed_top_bottom;
                            side.bleed_top_bottom = 1 * side.bleed_left_right;
                            side.bleed_left_right = tem;
                            tem = 1 * side.margin_top_bottom;
                            side.margin_top_bottom = 1 * side.margin_left_right;
                            side.margin_left_right = tem;
                            if (data.orientation == 1) {
                                tem = side.real_left;
                                side.real_left = side.real_top;
                                side.real_top = side.product_height - side.real_height - tem;
                            } else {
                                tem = side.real_top;
                                side.real_top = side.real_left;
                                side.real_left = side.product_width - side.real_width - tem;
                            }
                            side.area_design_top = side.img_src_top + side.real_top / side.product_width * side.img_src_width;
                            side.area_design_left = side.img_src_left + side.real_left / side.product_width * side.img_src_width;
                        }
                    });
                }
                if (angular.isUndefined(first)) {
                    $scope.saveDesign();
                    if (angular.isDefined(data.page) && angular.isUndefined(data.page.list_page) && data.page.page_display == '1' && data.page.exclude_page == '2') {
                        if (angular.isDefined($scope.resource.jsonDesign['frame_' + (number_side - 1)])) {
                            $scope.resource.jsonDesign['frame_' + (number_side - 1)] = {
                                objects: [],
                                version: lastJsonDesign.version
                            };
                        }
                        $scope.resource.jsonDesign['frame_' + (dst_number_side - 1)] = {};
                        angular.copy(lastJsonDesign, $scope.resource.jsonDesign['frame_' + (dst_number_side - 1)]);
                    }
                    appConfig.ready = false;
                    /*                 if( angular.isDefined( data.area ) ){
                    $scope.forceInitStage = true;
                }else{ */
                    $scope.settings.product_data.config = {};
                    $scope.settings.product_data.config.viewport = $scope.viewPort;
                    $scope.settings.product_data.fonts = $scope.resource.usedFonts;
                    $scope.preventChangeCurrentDesign = true;
                    $scope.needLoadVariationDesign();
                    if (!$scope.forceLoadVariationDesign) $scope.settings.product_data.design = $scope.resource.jsonDesign;
                    //};
                    // $scope.currentStage = 0;
                    $scope.onChangePrintingOptions = true;
                    if ($scope.productChangeOptions.applyToCurrentPage) {
                        $scope.reprocessProductSettings();
                    } else {
                        $scope.processProductSettings(true);
                    }
                    $scope.changeExtraOdOptions();
                    $scope.updateApp();
                }
            }
        };
        $scope.changeExtraOdOptions = function () {
            if ($scope.onloadVariation) return;
            if (angular.isDefined(nbd_window.nbOption) && angular.isDefined(nbd_window.nbOption.extraOdOption)) {
                var data = nbd_window.nbOption.extraOdOption;
                if (angular.isDefined(data.rounded_corner)) {
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        side.bleed_radius = parseFloat(data.rounded_corner);
                        side.safezone_radius = parseFloat(data.rounded_corner) - side.margin_left_right;
                        if (side.safezone_radius < 0) side.safezone_radius = 0;
                        if (side.bleed_radius != 0) {
                            $scope.stages[key].config.bleed_radius = $scope.stages[key].config.cwidth * side.bleed_radius / side.product_width;
                            $scope.stages[key].config.safezone_radius = $scope.stages[key].config.cwidth * side.safezone_radius / side.product_width;
                        } else {
                            delete $scope.stages[key].config.bleed_radius;
                            delete $scope.stages[key].config.safezone_radius;
                        }
                    });
                }
                if (angular.isDefined(data.overlay)) {
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        if (angular.isDefined(data.overlay[key]) && data.overlay[key] != '') {
                            side.img_overlay = data.overlay[key];
                            $scope.stages[key].config.img_overlay = data.overlay[key];
                        }
                        if (typeof nbod_addon_side_thumbnail != "undefined" || typeof kvlc_js_cusom != "undefined") {
                            //nbdesigner advanced
                            if (angular.isDefined(data.thumbnail[key]) && data.thumbnail[key] != '') {
                                side.img_thumbnail = data.overlay[key];
                                $scope.stages[key].config.img_thumbnail = data.thumbnail[key];
                            }
                        }
                    });
                }
                if (angular.isDefined(data.fold)) {
                    var foldClass = '',
                        fold = false,
                        numberPanel = 1;
                    switch (data.fold) {
                        case 'n':
                            fold = false;
                            break;
                        case 'h':
                            foldClass = 'single f2';
                            numberPanel = 2;
                            fold = true;
                            break;
                        case 't':
                            foldClass = 'single f3';
                            numberPanel = 3;
                            fold = true;
                            break;
                        case 'z':
                            foldClass = 'single f3';
                            numberPanel = 3;
                            fold = true;
                            break;
                        case 's':
                            foldClass = 'single f3_2';
                            numberPanel = 3;
                            fold = true;
                            break;
                        case 'd':
                            foldClass = 'single f4';
                            numberPanel = 4;
                            fold = true;
                            break;
                        case 'dp':
                            foldClass = 'single f4';
                            numberPanel = 4;
                            fold = true;
                            break;
                        case 'dr':
                            foldClass = 'single f4';
                            numberPanel = 4;
                            fold = true;
                            break;
                        case 'r':
                            foldClass = 'single f4';
                            numberPanel = 4;
                            fold = true;
                            break;
                        case 'a':
                            foldClass = 'single f4';
                            numberPanel = 4;
                            fold = true;
                            break;
                        case 'hh':
                            foldClass = 'double f2';
                            numberPanel = 4;
                            fold = true;
                            break;
                        case 'ht':
                            foldClass = 'double f3';
                            numberPanel = 6;
                            fold = true;
                            break;
                    }
                    $scope.resource.config.fold = fold;
                    $scope.resource.config.foldClass = foldClass;
                    $scope.resource.config.numberPanel = numberPanel;
                }
                if (angular.isDefined(data.pattern)) {
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        if (data.pattern.type == 'c') {
                            side.pattern = {
                                type: 'color',
                                color: data.pattern.color
                            };
                        } else {
                            side.pattern = {
                                type: 'image',
                                src: data.pattern.bg_image[key]
                            };
                            jQuery('.sticker-contour-pattern-wrap svg pattern image').attr('xlink:href', data.pattern.bg_image[key]);
                        }
                    });
                }
                if (angular.isDefined(data.shape)) {
                    angular.forEach($scope.settings.product_data.product, function (side, key) {
                        $scope.changeAreaDesignShape(key, data.shape);
                    });
                }
                $scope.afterChangeExtraOdOptions();
            }
        };
        $scope.afterChangeExtraOdOptions = function () {
        };
        $scope.needLoadVariationDesign = function () {
            $scope.forceLoadVariationDesign = false;
            if (NBDESIGNCONFIG.product_type == 'variable' && NBDESIGNCONFIG['variation_id'] != 0 && NBDESIGNCONFIG['ui_mode'] == 2 && NBDESIGNCONFIG['task'] == 'new') {
                var hasDesign = false;
                _.each($scope.stages, function (stage, index) {
                    var _canvas = stage.canvas;
                    if (_canvas && _canvas.getObjects().length > 0) hasDesign = true;
                });
                if (!hasDesign) {
                    $scope.forceLoadVariationDesign = true;
                    $scope.preventChangeCurrentDesign = false;
                    return true;
                }
            }
            return false;
        };
        $scope.onloadVariation = false;
        $scope.initVariationSetting = false;
        $scope.preventChangeCurrentDesign = false;
        $scope.forceLoadVariationDesign = false;
        $scope.changeVariation = function () {
            if ($scope.onloadVariation) return;
            if (angular.isDefined(NBDESIGNCONFIG.force_hide_option) && NBDESIGNCONFIG.nbdesigner_display_product_option == '1') {
                return;
            }
            $scope.onloadVariation = true;
            $scope.toggleStageLoading();
            $scope.saveDesign();
            appConfig.ready = false;
            $scope.preventChangeCurrentDesign = true;
            $scope.needLoadVariationDesign();
            NBDDataFactory.get('nbdesigner_get_product_info', {
                product_id: NBDESIGNCONFIG['product_id'],
                variation_id: NBDESIGNCONFIG['variation_id'],
                need_templates: 1
            }, function (data) {
                $scope.toggleStageLoading();
                $scope.onloadVariation = false;
                $scope.initVariationSetting = true;
                if (NBDESIGNCONFIG['ui_mode'] == 1) nbd_window.NBDESIGNERPRODUCT.nbdesigner_ready();
                $scope.settings.product_data = JSON.parse(data);
                if (angular.isDefined($scope.settings.product_data.templates)) {
                    $scope.resource.templates = $scope.settings.product_data.templates;
                    if (angular.isDefined($scope.settings.product_data.templates)) {
                        $scope.resource.templates = $scope.settings.product_data.templates;
                        if (angular.isDefined($scope.settings.product_data.templates.template_tags)) {
                            $scope.settings.template_tags = $scope.settings.product_data.templates.template_tags;
                            if ($scope.settings.template_tags.length > 0) {
                                $scope.resource.customTemplates = [];
                                $scope.settings.template_tags.forEach(function (tag) {
                                    $scope.resource.customTemplates[tag.id] = {
                                        limit: 0,
                                        total: tag.templates.length
                                    }
                                });
                            }
                        }
                        $scope.updateApp();
                        $timeout(function () {
                            window.modern.sideBar.tabProductTemplate();
                        });
                    }
                }
                if (!$scope.forceLoadVariationDesign) $scope.settings.product_data.design = $scope.resource.jsonDesign;
                $scope.settings.product_data.config = {};
                $scope.settings.product_data.config.viewport = $scope.viewPort;
                $scope.settings.product_data.fonts = $scope.resource.usedFonts;
                if (angular.isDefined(nbd_window.nbOption)) {
                    var und;
                    $scope.changePrintingOptions(und, true);
                } else {
                    $scope.processProductSettings();
                }
            });
        };
        $scope.loadedPrintingOptions = false;
        $scope.widthoutPrintingOptions = false;
        $scope.getPrintingOptions = function () {
            if ($scope.settings.nbdesigner_display_product_option == '1') {
                jQuery('.nbd-popup.popup-nbo-options').nbShowPopup();
            }
            if (!$scope.loadedPrintingOptions) {
                if (angular.isDefined(NBDESIGNCONFIG.force_hide_option) && NBDESIGNCONFIG.nbdesigner_display_product_option == '1') {
                    jQuery('.nbd-popup.popup-nbo-options .close-popup').triggerHandler('click');
                }
                $http({
                    method: 'GET',
                    url: $scope.settings.link_get_options
                }).then(function (response) {
                    $scope.loadedPrintingOptions = true;
                    var container = jQuery('#nbo-options-wrap');
                    container.append(response.data);
                    jQuery(document).trigger('nbo_get_option_success');
                    /* Compare with other color swatches plugins */
                    jQuery('.variation-selector').removeClass('hidden').show();
                    jQuery('.nbtcs-swatches').addClass('hidden');
                    if (jQuery('.nbo-wrapper').length == 0) {
                        $scope.widthoutPrintingOptions = true;
                        if (jQuery('input[name="variation_id"]').length > 0 && jQuery('input[name="variation_id"]').val() > 0) {
                            $scope.printingOptionsAvailable = true;
                        }
                        jQuery('.variations_form').on('woocommerce_variation_has_changed wc_variation_form', function () {
                            if (jQuery('input[name="variation_id"]').length > 0 && jQuery('input[name="variation_id"]').val() > 0) {
                                NBDESIGNCONFIG.variation_id = jQuery('input[name="variation_id"]').val();
                                $scope.printingOptionsAvailable = true;
                                var _interval = $interval(function () {
                                    if ($scope.completedInsertTemplate == true) {
                                        $scope.changeVariation();
                                        $interval.cancel(_interval);
                                    }
                                }, 100);
                            } else {
                                $scope.printingOptionsAvailable = false;
                            }
                        });
                        jQuery('.variations_form').on('found_variation found_variation.wc-variation-form', function () {
                            setTimeout(function () {
                                if (jQuery('input[name="variation_id"]').length > 0 && jQuery('input[name="variation_id"]').val() > 0) {
                                    NBDESIGNCONFIG.variation_id = jQuery('input[name="variation_id"]').val();
                                    $scope.printingOptionsAvailable = true;
                                    var _interval = $interval(function () {
                                        if ($scope.completedInsertTemplate == true) {
                                            $scope.changeVariation();
                                            $interval.cancel(_interval);
                                        }
                                    }, 100);
                                } else {
                                    $scope.printingOptionsAvailable = false;
                                }
                            }, 100);
                        });
                    }
                    if (NBDESIGNCONFIG.show_nbo_option == "1" && NBDESIGNCONFIG.task == 'new') {
                        container.find('form.variations_form').append('<input name="submit_form_mode2" type="hidden" value="1" />');
                        container.find('form.cart').append('<input name="submit_form_mode2" type="hidden" value="1" />');
                        container.find('form.cart').append('<input name="add-to-cart" type="hidden" value="' + NBDESIGNCONFIG.product_id + '" />');
                    }
                    if (NBDESIGNCONFIG.task2 != '' && NBDESIGNCONFIG.task2 != 'update') {
                        jQuery('.variations_form').addClass('nbd-disabled');
                        jQuery('form.cart').addClass('nbd-disabled');
                    }
                    jQuery('.nbd-popup.popup-nbo-options .overlay-popup').addClass('nbo-disable');
                    jQuery('.single_add_to_cart_button').addClass('nbd-disabled');
                    jQuery('.nbd-popup.popup-nbo-options').find('.overlay-main').removeClass('active');
                    jQuery('.tab-product .loaded').hide();
                    jQuery('.single_add_to_cart_button').hide();
                    var newScope = angular.element(container).scope();
                    var compile = angular.element(container).injector().get('$compile');
                    compile(jQuery(container).contents())(newScope);
                    $timeout(function () {
                        container.perfectScrollbar();
                        if (jQuery('#nbo-options-wrap .variations_form').length) {
                            jQuery('#nbo-options-wrap .variations_form').wc_variation_form();
                            jQuery('#nbo-options-wrap .variations_form').trigger('wc_variation_form');
                            jQuery('#nbo-options-wrap .variations_form .variations select').change();
                        }
                    });
                });
            }
        };
        $scope.searchProductName = '';
        $scope.onChangeProductWidthChanged = function () {
        }

        $scope.onChangeProductHeightChanged = function () {
        }

        $scope.onChangeProductOrientationChanged = function () {
        }

        $scope.onChangeProductUnitChanged = function () {
            $scope.settings.nbdesigner_dimensions_unit = $scope.productChangeOptions.unit;
            $scope.updateApp();
        }

        $scope.onChangeProductDPIChanged = function () {
        }

        $scope.onProductOptionChanged = function (handleOrientation = false) {
            nbd_window['nbOption'] = {
                odOption: {
                    dimension: {
                        width: Number($scope.productChangeOptions.width),
                        height: Number($scope.productChangeOptions.height),
                    },
                    orientation: Number($scope.productChangeOptions.orientation) || 1,
                    unit: $scope.productChangeOptions.unit,
                    dpi: $scope.productChangeOptions.dpi,
                }
            };
            $scope.changePagesPrintingOptions(undefined, false, handleOrientation);
        }
        $scope.onChangeProductMousedown = function (e) {
            e.stopPropagation();
        }
        $scope.showProducts = function () {
            jQuery('.nbd-popup.popup-nbd-products').nbShowPopup();
            if ($scope.resource.products.length) return;
            jQuery('.nbd-popup.popup-nbd-products').find('.overlay-main').addClass('active');
            NBDDataFactory.get('nbd_get_nbd_products', {}, function (data) {
                jQuery('.nbd-popup.popup-nbd-products').find('.overlay-main').removeClass('active');
                var _data = JSON.parse(data);
                if (_data.length && angular.isDefined(_data[0].product_id)) {
                    $scope.resource.products = _data;
                } else {
                    jQuery('.nbd-popup.popup-nbd-products .close-popup').triggerHandler('click');
                }
            });
        };
        $scope.getProductInfo = function () {
            jQuery('.nbd-popup.popup-nbd-products').find('.overlay-main').addClass('active');
            NBDDataFactory.get('nbd_get_product_description', {product_id: NBDESIGNCONFIG.product_id}, function (data) {
                var _data = JSON.parse(data);
                jQuery('.nbd-popup.popup-nbd-products').find('.overlay-main').removeClass('active');
            });
        };
        $scope.changeProduct = function (product_id) {
            $scope.switchedProduct = product_id;
            jQuery('.nbd-popup.popup-nbd-products .close-popup').triggerHandler('click');
            $scope.saveData('change-product');
        };
        /* Upload Image */
        $scope.uploadFile = function (files, indexFile) {
            indexFile = angular.isDefined(indexFile) ? indexFile : 0;
            if (files.length <= 0 || indexFile > (files.length - 1) || indexFile > (parseInt($scope.settings.nbdesigner_max_upload_files_at_once) - 1)) return;
            var file = files[indexFile],
                max_size = parseInt($scope.settings.nbdesigner_maxsize_upload),
                min_size = parseInt($scope.settings.nbdesigner_minsize_upload);
            /*nbdesigner_advanced_ai_to_svg*/
            if (typeof nbpdf_ai_to_svg != "undefined") {
                if (file.type.indexOf("application/postscript") !== -1) {
                    $scope.resource.upload.progressBar = 0;
                    jQuery('.nbd-progress-bar').addClass('active');
                    var stage = $scope.stages[$scope.currentStage],
                        _canvas = stage['canvas'],
                        object = _canvas.getActiveObject();
                    if (!!object && !!object.get('maskId') && files.length == 1) {
                        var maskId = object.get('maskId');
                    }
                    NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                        var data = JSON.parse(data);
                        if (data.flag == 2) {
                            alert(data.mes);
                            jQuery('.nbd-progress-bar').removeClass('active');
                            return;
                        }
                        if (data.flag == 1) {
                            if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                            if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {

                                $scope.toggleStageLoading();
                                alert(data.mes);
                                $scope.uploadFile(files, indexFile + 1);
                                return;
                            }
                            ;
                            $scope.storeUploadFile(data, data.name);
                            jQuery("#tab-photo .tab-scroll").stop().animate({
                                scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                            }, 100);
                            localStorage.setItem('uploaded', $scope.resource.upload.data);
                            $scope.onEndRepeat('upload');
                            $scope.uploadFile(files, indexFile + 1);
                        } else {
                            alert(data.mes);
                        }
                        jQuery('.nbd-progress-bar').removeClass('active');
                    }, function (progress) {
                        $scope.resource.upload.progressBar = progress.toFixed(0);
                    });
                    return;
                }

            }
            /*nbdesigner_advanced*/
            if (typeof nbpdf_pdf_to_svg != "undefined") {
                if (file.type.indexOf("application/pdf") !== -1) {
                    $scope.resource.upload.progressBar = 0;
                    jQuery('.nbd-progress-bar').addClass('active');
                    var stage = $scope.stages[$scope.currentStage],
                        _canvas = stage['canvas'],
                        object = _canvas.getActiveObject();
                    if (!!object && !!object.get('maskId') && files.length == 1) {
                        var maskId = object.get('maskId');
                    }
                    NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                        var data = JSON.parse(data);
                        if (data.flag == 3) {
                            alert(data.mes);
                            jQuery('.nbd-progress-bar').removeClass('active');
                            return;
                        }
                        if (data.flag == 2) {
                            alert(data.mes);
                            jQuery('.nbd-progress-bar').removeClass('active');
                            return;
                        }
                        if (data.flag == 1) {
                            if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                            if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {

                                $scope.toggleStageLoading();
                                alert(data.mes);
                                $scope.uploadFile(files, indexFile + 1);
                                return;
                            }
                            ;
                            $scope.storeUploadFile(data, data.name);
                            jQuery("#tab-photo .tab-scroll").stop().animate({
                                scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                            }, 100);
                            localStorage.setItem('uploaded', $scope.resource.upload.data);
                            $scope.onEndRepeat('upload');
                            $scope.uploadFile(files, indexFile + 1);
                        } else {
                            alert(data.mes);
                        }
                        jQuery('.nbd-progress-bar').removeClass('active');
                    }, function (progress) {
                        $scope.resource.upload.progressBar = progress.toFixed(0);
                    });
                    return;
                }
            }
            if (typeof nbpdf_pdf_to_image !== "undefined") {
                $scope.dataURLtoFile = function (dataurl, filename) {
                    var arr = dataurl.split(','),
                        mime = arr[0].match(/:(.*?);/)[1],
                        bstr = atob(arr[1]),
                        n = bstr.length,
                        u8arr = new Uint8Array(n);
                    while (n--) {
                        u8arr[n] = bstr.charCodeAt(n);
                    }
                    return new File([u8arr], filename, {type: mime});
                }
                $scope.doThing = function (p, i) {
                    $("body").append("<canvas class='canvas_hide' style='display: none' height='600' width='700' id='" + i + "'></canvas>")
                    var canvasEl = document.getElementById(i);
                    p.getPage(i).then(function (page) {
                        var viewport = page.getViewport(1);
                        canvasEl.width = viewport.width;
                        canvasEl.height = viewport.height;
                        page.render({
                            canvasContext:
                                canvasEl.getContext('2d'),
                            viewport: viewport
                        }).then(function () {
                            var bg = canvasEl.toDataURL("image/png");
                            var file = $scope.dataURLtoFile(bg, i + ".jpg");
                            NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                                var data = JSON.parse(data);
                                if (data.flag == 1) {
                                    if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                                    if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {
                                        $scope.toggleStageLoading();
                                        alert(data.mes);
                                        $scope.uploadFile(files, indexFile + 1);
                                        return;
                                    }
                                    ;
                                    $scope.storeUploadFile(data, data.name);
                                    jQuery("#tab-photo .tab-scroll").stop().animate({
                                        scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                                    }, 100);
                                    localStorage.setItem('uploaded', $scope.resource.upload.data);
                                    $scope.onEndRepeat('upload');
                                    $(".canvas_hide").remove();
                                } else {
                                    $scope.toggleStageLoading();
                                    alert(data.mes);
                                }
                            }, function (progress) {
                                $scope.resource.upload.progressBar = progress.toFixed(0);
                            });
                        });
                    })
                }
                if (file.type.indexOf("pdf") > -1) {
                    $scope.resource.upload.progressBar = 0;
                    jQuery('.nbd-progress-bar').addClass('active');
                    setTimeout(() => {
                    }, 100);
                    var fileReader = new FileReader();
                    fileReader.onload = function () {
                        var typedarray = new Uint8Array(this.result);
                        PDFJS.getDocument(typedarray).then(function (pdf) {
                            for (var i = 1; i <= pdf.numPages; i++) {
                                $scope.doThing(pdf, i);
                            }
                        });
                    };
                    fileReader.readAsArrayBuffer(file);
                    setTimeout(() => {
                        jQuery('.nbd-progress-bar').removeClass('active');
                    }, 100);
                    return;
                }
            }
            if ((file.type.indexOf("image") === -1 && file.type.indexOf("pdf") === -1) || (file.type.indexOf("pdf") != -1 && !$scope.settings.is_available_imagick)) {
                alert($scope.settings.is_available_imagick ? $scope.settings.nbdlangs.supported_extensions2 : $scope.settings.nbdlangs.supported_extensions);
                return;
            }
            if (file.size > max_size * 1024 * 1024) {
                alert($scope.settings.nbdlangs.max_file_size + max_size + " MB");
                return;
            } else if (file.size < min_size * 1024 * 1024) {
                alert($scope.settings.nbdlangs.min_file_size + min_size + " MB");
                return;
            }
            ;
            if (file.type.indexOf("svg") > -1) {
                var reader = new FileReader();
                reader.onload = function (event) {
                    if (event.target.readyState === 2) {
                        var result = reader.result;
                        $scope.addSvgFromString(result);
                        $scope.uploadFile(files, indexFile + 1);
                    }
                };
                reader.readAsText(file);
                /*advanced*/
                if (typeof udc_nbd_js_config != "undefined") {
                    NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                        var data = JSON.parse(data);
                        if (data.flag == 1) {
                            if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                            if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {
                                $scope.toggleStageLoading();
                                alert(data.mes);
                                $scope.uploadFile(files, indexFile + 1);
                                return;
                            }
                            ;
                            $scope.storeUploadFile(data, data.name);
                            if ($scope.settings.nbod_auto_add_image == 'no') {
                                if (maskId) {
                                    $scope.addImage(data, false, true, false, false, maskId);
                                } else {
                                    $scope.addImage(data, false, true);
                                }
                            }
                            jQuery("#tab-photo .tab-scroll").stop().animate({
                                scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                            }, 100);
                            localStorage.setItem('uploaded', $scope.resource.upload.data);
                            $scope.onEndRepeat('upload');
                        } else {
                            $scope.toggleStageLoading();
                            alert(data.mes);
                        }
                        jQuery('.nbd-progress-bar').removeClass('active');
                    }, function (progress) {
                        $scope.resource.upload.progressBar = progress.toFixed(0);
                    });
                }
            } else {
                /*advanced*/
                if (typeof nbod_addon_upload_img != "undefined") {
                    if ($scope.settings.nbod_auto_add_image == 'no') {
                        $scope.toggleStageLoading();
                    }
                    $scope.resource.upload.progressBar = 0;
                    jQuery('.nbd-progress-bar').addClass('active');
                    var stage = $scope.stages[$scope.currentStage],
                        _canvas = stage['canvas'],
                        object = _canvas.getActiveObject();
                    if (!!object && !!object.get('maskId') && files.length == 1) {
                        var maskId = object.get('maskId');
                    }
                    NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                        var data = JSON.parse(data);
                        if (data.flag == 1) {
                            if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                            if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {
                                $scope.toggleStageLoading();
                                alert(data.mes);
                                $scope.uploadFile(files, indexFile + 1);
                                return;
                            }
                            ;
                            $scope.storeUploadFile(data, data.name);
                            if ($scope.settings.nbod_auto_add_image == 'no') {
                                if (maskId) {
                                    $scope.addImage(data, false, true, false, false, maskId);
                                } else {
                                    $scope.addImage(data, false, true);
                                }
                            }
                            jQuery("#tab-photo .tab-scroll").stop().animate({
                                scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                            }, 100);
                            localStorage.setItem('uploaded', $scope.resource.upload.data);
                            $scope.onEndRepeat('upload');
                            $scope.uploadFile(files, indexFile + 1);
                        } else {
                            $scope.toggleStageLoading();
                            alert(data.mes);
                        }
                        jQuery('.nbd-progress-bar').removeClass('active');
                    }, function (progress) {
                        $scope.resource.upload.progressBar = progress.toFixed(0);
                    });
                    return;
                }
                ;
                $scope.toggleStageLoading();
                $scope.resource.upload.progressBar = 0;
                jQuery('.nbd-progress-bar').addClass('active');
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'],
                    object = _canvas.getActiveObject();
                if (!!object && !!object.get('maskId') && files.length == 1) {
                    var maskId = object.get('maskId');
                }
                /*advanced*/
                if (typeof mia_nbd_js_config_design != "undefined") {
                    var reader = new FileReader();
                    reader.onload = function (file) {
                        $scope.addImage(file.target.result, false, true);
                    }
                    reader.readAsDataURL(file);
                }
                /*advanced*/
                if (typeof kcnb_nbd_js_config != "undefined") {
                    NBDDataFactory.get('nbdesigner_customer_upload', {
                        temp_name: $scope.templateName,
                        file: file
                    }, function (data) {
                        var data = JSON.parse(data);
                        if (data.flag == 1) {
                            if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                            var queryString = window.location.search;
                            var urlParams = new URLSearchParams(queryString);
                            var admin = urlParams.get('rd');
                            if (admin == 'admin_templates') {
                                $scope.customTemplate.name = data.nameUpload;
                            }
                            if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {
                                $scope.toggleStageLoading();
                                alert(data.mes);
                                $scope.uploadFile(files, indexFile + 1);
                                return;
                            }
                            ;
                            $scope.storeUploadFile(data, data.name);
                            if (maskId) {
                                $scope.addImage(data, false, true, false, false, maskId);
                            } else {
                                $scope.addImage(data, false, true);
                            }
                            jQuery("#tab-photo .tab-scroll").stop().animate({
                                scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                            }, 100);
                            localStorage.setItem('uploaded', $scope.resource.upload.data);
                            $scope.onEndRepeat('upload');
                            $scope.uploadFile(files, indexFile + 1);
                        } else {
                            $scope.toggleStageLoading();
                            alert(data.mes);
                        }
                        jQuery('.nbd-progress-bar').removeClass('active');
                    }, function (progress) {
                        $scope.resource.upload.progressBar = progress.toFixed(0);
                    });
                    return
                }
                NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                    /*advanced*/
                    if (typeof mia_nbd_js_config_design != "undefined") {
                        return;
                    }
                    var data = JSON.parse(data);
                    if (data.flag == 1) {
                        if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                        if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {
                            $scope.toggleStageLoading();
                            alert(data.mes);
                            $scope.uploadFile(files, indexFile + 1);
                            return;
                        }
                        ;
                        $scope.storeUploadFile(data, data.name);
                        if (maskId) {
                            $scope.addImage(data, false, true, false, false, maskId);
                        } else {
                            $scope.addImage(data, false, true);
                        }
                        jQuery("#tab-photoc .tab-scroll").stop().animate({
                            scrollTop: jQuery("#tab-photoc .tab-scroll").prop("scrollHeight")
                        }, 100);
                        localStorage.setItem('uploaded', $scope.resource.upload.data);
                        $scope.onEndRepeat('upload');
                        $scope.uploadFile(files, indexFile + 1);
                    } else {
                        $scope.toggleStageLoading();
                        alert(data.mes);
                    }
                    jQuery('.nbd-progress-bar').removeClass('active');
                }, function (progress) {
                    $scope.resource.upload.progressBar = progress.toFixed(0);
                });
            }
            /*advanced*/
            if (typeof mia_nbd_js_config_design != "undefined") {
                jQuery(".form-upload input[type='file']").val("");
            }
        };

        $scope.removeCustomerUpload = function (e, id) {
            e.stopPropagation();
            if (window.confirm("Are you sure?")) {
                if (id) {
                    NBDDataFactory.get('nbdesigner_remove_customer_upload', {id}, function (data) {
                        const response = JSON.parse(data);
                        if (response.flag) {
                            $scope.resource.upload.data = $scope.resource.upload.data
                                .filter((upload) => !upload.id || upload.id !== id);
                        }
                    });
                }
            }
        }
        $scope.storeUploadFile = function (data, name) {
            var src = typeof data == 'object' ? data.src : data;
            var ojb = {
                id: typeof data === 'object' ? data.id : null,
                url: src,
                src: src,
                des: name,
                ilr: $scope.resource.upload.ilr,
                createdAt: +new Date()
            };
            if (typeof data == 'object' && angular.isDefined(data.origin_url)) {
                ojb.origin_url = data.origin_url;
                ojb.src = src;
                ojb.width = data.width;
                ojb.height = data.height;

                if (angular.isDefined(data.origin_pdf)) {
                    ojb.origin_pdf = data.origin_pdf;
                }
            }
            /*advanced*/
            if (typeof udc_nbd_js_config != "undefined") {
                ojb.name = data.name;
                ojb.show = true;
            }

            if (!$scope.resource.upload.data.length) {
                $scope.resource.upload.data = $scope.settings.nbod_image_customize ? $scope.settings.nbod_image_customize : [];
            }
            $scope.resource.upload.data.push(ojb);

            $scope.resource.upload.filter.total = $scope.resource.upload.data.length;

            if ($scope.settings.nbdesigner_cache_uploaded_image == 'yes') {
                $scope._localStorage.save('nbduploaded');
            }
        };
        /* Login */
        $scope.login = function (callback) {
            if ($scope.settings.is_logged) {
                if (typeof callback == 'function') callback();
                return;
            } else {
                $scope.toggleStageLoading();
                NBDDataFactory.get('nbd_check_use_logged_in', {type: 'check_login'}, function (data) {
                    data = JSON.parse(data);
                    $scope.toggleStageLoading();
                    if (data.is_login == 1) {
                        NBDESIGNCONFIG['nonce_get'] = data.nonce_get;
                        NBDESIGNCONFIG['nonce'] = data.nonce;
                        if (typeof callback == 'function') callback();
                        return;
                    } else {
                        if (checkMobileDevice()) {
                            iframe_src = NBDESIGNCONFIG['login_url'];
                            if (jQuery('.popup-login .main-body iframe').length == 0) {
                                jQuery('.popup-login .main-body').prepend('<iframe id="nbd-login-frame"  width="100%" height="100%" scrolling="yes" frameborder="0" noresize="noresize" allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true" src="' + iframe_src + '"></iframe>');
                                jQuery(document).on('nbd_redirect_login', function (e) {
                                    jQuery('.popup-login .overlay-main').show();
                                });
                                setTimeout(function () {
                                    var interval;
                                    jQuery('.popup-login .main-body iframe').on("load", function () {
                                        jQuery('.popup-login .overlay-main').hide();
                                        jQuery('.popup-login .main-body iframe').contents().find("head").append("<style>header, footer{display:none;}</style>");
                                        if (interval) clearInterval(interval);
                                        interval = setInterval(function () {
                                            try {
                                                var location = jQuery('.popup-login .main-body iframe').contents().get(0).location;
                                                if (location.hash.length) {
                                                    var hash = location.hash;
                                                    var res = hash.split("___");
                                                    if (res.length) {
                                                        NBDESIGNCONFIG['nonce_get'] = res[0].substr(1);
                                                        NBDESIGNCONFIG['nonce'] = res[1];
                                                    }
                                                    clearInterval(interval);
                                                    $scope.settings['is_logged'] = 1;
                                                    jQuery('.popup-login .main-popup .close-popup').triggerHandler('click');
                                                    $scope.updateApp();
                                                    if (typeof callback == 'function') callback();
                                                }
                                            } catch (evt) {

                                            }
                                        }, 100);
                                    });
                                });
                            }
                            ;
                            jQuery('.popup-login').nbShowPopup();
                        } else {
                            /*advanced*/
                            if (typeof hvc_app_modern_js != 'undefined') {
                                NBDESIGNCONFIG['login_url'] = location.origin + '/my-account/';
                            }
                            var popupLeft = (window.screen.width - 700) / 2,
                                popupTop = (window.screen.height - 500) / 2,
                                popup = window.open(NBDESIGNCONFIG['login_url'], '', 'width=700,height=500,left=' + popupLeft + ',top=' + popupTop + '');
                            popup.onload = new function () {
                                if (window.location.hash.length == 0) {
                                    popup.open(NBDESIGNCONFIG['login_url'], '_self');
                                }
                                ;
                                var interval = setInterval(function () {
                                    try {
                                        if (popup.location.hash.length) {
                                            var hash = popup.location.hash;
                                            var res = hash.split("___");
                                            if (res.length) {
                                                NBDESIGNCONFIG['nonce_get'] = res[0].substr(1);
                                                NBDESIGNCONFIG['nonce'] = res[1];
                                            }
                                            clearInterval(interval);
                                            $scope.settings['is_logged'] = 1;
                                            popup.close();
                                            $scope.updateApp();
                                            if (typeof callback == 'function') callback();
                                        }
                                    } catch (evt) {

                                    }
                                }, 100);
                            }
                        }
                    }
                });
            }
        };
        $scope.stageOnload = false;
        $scope.toggleStageLoading = function (timeout) {
            jQuery('.loading-workflow').toggleClass('nbd-show');
            var container = appConfig.isVisual ? '.nbd-mode-vista' : 'body';
            jQuery(container).toggleClass('nbd-onloading');
            var _timeout = timeout ? timeout : 2E4;
            if (jQuery('.loading-workflow').hasClass('nbd-show')) {
                $scope.stageOnload = true;
                $scope._promise = $timeout(function () {
                    if ($scope.stageOnload) {
                        jQuery('.loading-workflow').removeClass('nbd-show');
                        jQuery(container).removeClass('nbd-onloading');
                    }
                }, _timeout);
            } else {
                $timeout.cancel($scope._promise);
                $scope.stageOnload = false;
            }
            $scope.updateApp();
        };
        /* Webcam */
        $scope.initWebcam = function () {
            $scope.resource.webcam.status = true;
            var params;
            if ($scope.settings.is_mobile) {
                params = {
                    width: 250,
                    height: 250,
                    dest_width: 1000,
                    dest_height: 1000,
                    image_format: 'jpeg',
                    jpeg_quality: 100,
                    constraints: {
                        video: {facingMode: "user"},
                        audio: false,
                        width: {exact: 250},
                        height: {exact: 250}
                    },
                    iosPlaceholderText: $scope.settings.nbdlangs.iosPlaceholderText
                };
            } else {
                params = {
                    width: 400,
                    height: 300,
                    dest_width: 1280,
                    dest_height: 960,
                    image_format: 'jpeg',
                    jpeg_quality: 100,
                    constraints: {optional: [{minWidth: 600}]}
                };
            }
            Webcam.set(params);
            Webcam.attach('#my_camera');
            Webcam.setSWFLocation(NBDESIGNCONFIG['assets_url'] + 'webcam.swf');
        };
        $scope.pauseWebcam = function (status) {
            status == true && Webcam.freeze() || Webcam.unfreeze();
        };
        $scope.resetWebcam = function () {
            if ($scope.resource.webcam.status) {
                Webcam.reset();
                $scope.resource.webcam.status = false;
            } else {
                $scope.initWebcam();
            }
        };
        $scope.takeSnapshot = function () {
            Webcam.snap(function (data_uri) {
                $scope.resetWebcam();
                var raw_image_data = data_uri.replace(/^data\:image\/\w+\;base64\,/, '');
                NBDDataFactory.get('nbdesigner_save_webcam_image', {image: raw_image_data}, function (data) {
                    data = JSON.parse(data);
                    if (data.flag == 'success') {
                        jQuery('.popup-webcam .close-popup').triggerHandler('click');
                        $scope.toggleStageLoading();
                        $scope.addImage(data.url, false, true);
                    } else {
                        alert('Oops! Try again!');
                        $scope.initWebcam();
                    }
                });
            });
        };
        $scope.isNBDGalleryHidden = function () {
            if (!$scope.resource.element.type) {
                return false;
            }
            return NON_NBD_GALLERY_TYPES.includes($scope.resource.element.type);
        }
        $scope.onEndRepeat = function (type) {
            switch (type) {
                case 'typography':
                    $scope.renderMasonryList(type, '.nbd-sidebar .typography-items', '.typography-item', '#tab-typography', $scope.resource[type].init);
                    break;
                case 'font':
                    jQuery('#toolbar-font-familly-dropdown').perfectScrollbar('update');
                    break;
                case 'clipart':
                    $scope.renderMasonryList(type, '#tab-svg .clipart-wrap', '.clipart-item', '#tab-svg', $scope.resource[type].init);
                    break;
                case 'photo':
                    $scope.renderMasonryList(type, '#tab-photo .nbdesigner-gallery', '.nbdesigner-item', '#tab-photo', $scope.resource[type].init);
                    /*advanced*/
                    if (typeof ggct_nbd_js_config_design != "undefined") {
                        $scope.renderMasonryList(type, '#tab-gallery .nbdesigner-gallery', '.nbdesigner-itemc', '#tab-photo', $scope.resource[type].init);
                    }
                    break;
                case 'dropbox':
                case 'instagram':
                case 'facebook':
                case 'upload':
                case 'shape':
                case 'icon':
                case 'line':
                case 'flaticon':
                case 'flaticonstickers':
                case 'storyset':
                case 'svgrepo':
                case 'pxillustrations':
                case 'iconscout':
                case 'nounproject':
                case 'iconfinder':
                case 'photoFrame':
                    $scope.renderMasonryList(type, '#nbd-' + type + '-wrap .mansory-wrap', '.mansory-item', '#nbd-' + type + '-wrap', $scope.resource[type].init);
                    break;
            }
            if (typeof bagr_background != 'undefined') {
                /*advanced*/
                if (type == 'background') {
                    $scope.renderMasonryList(type, '#tab-background .background-wrap', '.background-item', '#tab-background', $scope.resource[type].init);
                }
            }
            /*advanced*/
            if (typeof ssnb_nbd_js_config != 'undefined') {
                if (type == 'block') {
                    $scope.renderMasonryList(type, '#tab-block .block-wrap', '.block-item', '#tab-block', $scope.resource[type].init);
                }
                if (type == 'clipart') {
                    $scope.renderMasonryList(type, '#tab-cliparts .mansory-wrap', '.mansory-item', '#tab-cliparts', $scope.resource[type].init);
                }
            }
            /*advanced*/
            if (typeof udc_nbd_js_config != "undefined") {
                if (type == 'overlay') {
                    $scope.renderMasonryList(type, '#tab-overlay .overlay-wrap', '.overlay-item', '#tab-overlay', $scope.resource[type].init);
                }
            }
        };
        $scope.updateScrollBar = function (jSelector) {
            $timeout(function () {
                jQuery(jSelector).scrollLeft = 0;
                jQuery(jSelector).perfectScrollbar('update');
            });
        };
        $scope.updateScrollBarCustomize = function (jSelector) {
            $timeout(function () {
                jQuery(jSelector).perfectScrollbar();
            });
        };
        $timeout(function () {
            jQuery('#customize-filter-mask').perfectScrollbar('update');
        });
        $scope.renderMasonryList = function (type, container, item, scrollContainer, init) {
            const $scrollingContainerElement = jQuery(scrollContainer);
            imagesLoaded(jQuery(container), function () {
                if (!init) {
                    let scrollingElement;
                    let scrollHeight;
                    if (container === '#tab-photo .nbdesigner-gallery') {
                        scrollingElement = jQuery(container)[1].closest('#style-3');
                        scrollTop = scrollingElement.scrollTop;
                    }
                    jQuery(container).masonry();
                    jQuery(container).masonry('destroy');
                    jQuery(container).masonry({
                        itemSelector: item
                    });
                    if (container === '#tab-photo .nbdesigner-gallery') {
                        scrollingElement.scrollTop = scrollTop;
                    }
                } else {
                    jQuery(container).masonry({
                        itemSelector: item
                    });
                }
                if (type !== 'clipart', 'overlay') {
                    jQuery(container + ' .loading-photo').hide();
                    jQuery.each(jQuery(container + ' ' + item), function (e) {
                        var animate = Math.floor(Math.random() * 10);
                        animate = (animate + 1) * 100;
                        if (checkMobileDevice()) {
                            jQuery(this).addClass("in-view");
                        } else {
                            jQuery(this).addClass("in-view slideInDown animated animate" + animate);
                        }
                    });
                } else {
                    jQuery.each(jQuery(container + ' ' + item), function (e) {
                        if (checkMobileDevice()) {
                            jQuery(this).addClass("in-view");
                        } else {
                            jQuery(this).addClass("in-view fadeIn animated animate");
                        }
                    });
                }
                jQuery(scrollContainer + ' .tab-scroll').perfectScrollbar('update');
                if (type !== 'clipart', 'overlay') {
                    $timeout(function () {
                        jQuery(scrollContainer + ' .loading-photo').hide();
                        jQuery(scrollContainer + ' .tab-load-more').show();
                    }, 100);
                }
                $scope.resource[type].onload = false;
                $scope.resource[type].init = false;

            });
        };
        /* Infinite scroll */
        $scope.scrollLoadMore = function (container, type) {
            const categoryComponents = document
                .querySelectorAll(`${container} category-component`);
            if (categoryComponents) {
                categoryComponents
                    .forEach((item) => {
                        $scope.$broadcast("scrollLoadMore", item.getAttribute('id'));
                    });
            }
            const categoryComponents2 = document
                .querySelectorAll(`${container} category-component2`);
            if (categoryComponents2) {
                categoryComponents2
                    .forEach((item) => {
                        $scope.$broadcast("scrollLoadMore", item.getAttribute('id'));
                    });
            }
            if ($scope.resource[type].onload) return;
            if (type == 'photo' && $scope.resource.personal.status) {
                var photoType = $scope.resource.personal.type;
                if (photoType == 'url' || photoType == 'upload') return;
                if ($scope.resource[photoType].filter.currentPage * $scope.resource[photoType].filter.perPage < $scope.resource[photoType].filter.total) {
                    $scope.resource[photoType].filter.currentPage += 1;
                    $timeout(function () {
                        jQuery('#tab-template .tab-scroll').perfectScrollbar('update');
                    });
                } else {
                    jQuery(container + ' .loading-photo').hide();
                    $scope.resource[photoType].onload = false;
                    $scope.updateApp();
                    return;
                }
                jQuery(container + ' .loading-photo').show();
                $scope.resource[photoType].onload = true;
                if (photoType == 'facebook') $scope.getPersonalPhoto('facebook');
                $scope.updateApp();
                return;
            }
            ;

            if (type == 'upload' && $scope.resource.personal.status) {
                var photoType = $scope.resource.personal.type;
                if ($scope.resource[photoType].filter.perPage <= $scope.resource[photoType].filter.total) {
                    $scope.resource[photoType].filter.perPage += $scope.resource[photoType].filter.perPage;
                    $timeout(function () {
                        jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    });
                } else {
                    $timeout(function () {
                        jQuery('#tab-photo .tab-scroll').perfectScrollbar('update');
                    });
                    return;
                }
                $scope.resource[photoType].onload = true;
                $scope.updateApp();
                return;
            }
            ;
            if (type == 'element') {
                var elementType = $scope.resource.element.type;
                if (['icon', 'shape', 'line', 'flaticon', 'flaticonstickers', 'svgrepo', 'iconscout', 'nounproject', 'iconfinder', 'storyset', 'pxillustrations'].indexOf(elementType) > -1) {
                    if ($scope.resource[elementType].filter.currentPage < $scope.resource[elementType].filter.totalPage) {
                        $scope.resource[elementType].filter.currentPage += 1;
                        $scope.getMedia(elementType, 'more');
                        $scope.resource[type].onload = true;
                    } else {
                        jQuery(container + ' .loading-photo').hide();
                        return;
                    }
                }
                ;
                if (elementType == 'photoFrame') {
                    if ($scope.resource[elementType].filter.currentPage * $scope.resource[elementType].filter.perPage < $scope.resource[elementType].filter.total) {
                        $scope.resource[elementType].filter.currentPage += 1;
                    } else {
                        jQuery(container + ' .loading-photo').hide();
                        return;
                    }
                }
                return;
            }
            ;
            if (type == 'globalTemplate') {
                if ($scope.resource.templateLimit < $scope.resource.templates.length) {
                    $scope.resource.templateLimit += 24;
                } else {
                    if ($scope.resource[type].filter.currentPage < $scope.resource[type].filter.totalPage) {
                        $scope.resource[type].filter.currentPage += 1;
                        $scope.toggleStageLoading();
                        $scope.resource[type].onload = true;
                        $scope.loadGlobalTemplate($scope.templateCat);
                    } else {
                        jQuery(container + ' .loading-photo').hide();
                        return;
                    }
                }
                return;
            }
            if (type !== 'clipart') {
                if (type !== 'overlay' && $scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage >= $scope.resource[type].filter.total) {
                    jQuery(container + ' .loading-photo').hide();
                    return;
                }
                jQuery(container + ' .loading-photo').show();
                if ($scope.resource[type].filter.currentPage * $scope.resource[type].filter.perPage < $scope.resource[type].filter.total) {
                    $scope.resource[type].filter.currentPage += 1;
                }
            }
            switch (type) {
                case 'clipart':
                    if ($scope.resource.clipart.filter.search) {
                        $scope.resource[type].filter.searchPerPage += $scope.resource[type].filter.searchPerPage;
                    } else if (!$scope.resource.clipart.filter.currentCat.id) {
                        $scope.resource[type].filter.categoryPerPage += $scope.resource[type].filter.categoryPerPage;
                    } else if ($scope.resource.clipart.filter.currentCat.id) {
                        $scope.resource[type].filter.categoryPerPage += $scope.resource[type].filter.categoryPerPage;
                        $scope.resource[type].filter.perPage += $scope.resource[type].filter.perPage;
                    }
                    break;
                case 'overlay':
                    if ($scope.resource.overlay.filter.search) {
                        $scope.resource[type].filter.searchPerPage += $scope.resource[type].filter.searchPerPage;
                    } else if (!$scope.resource.overlay.filter.currentCat.id) {
                        $scope.resource[type].filter.categoryPerPage += $scope.resource[type].filter.categoryPerPage;
                    } else if ($scope.resource.overlay.filter.currentCat.id) {
                        $scope.resource[type].filter.categoryPerPage += $scope.resource[type].filter.categoryPerPage;
                        $scope.resource[type].filter.perPage += $scope.resource[type].filter.perPage;
                    }
                    break;
                case 'typography':
                    $scope.resource[type].onload = true;
                    break;
                case 'font':

                    break;
                case 'photo':
                    $scope.resource[type].onload = true;
                    !$scope.resource.personal.status && $scope.getPhoto($scope.resource.photo.type, 'more');
                    break;
            }
            if (typeof bagr_background != 'undefined') {
                /*advanced*/
                if (type == 'background') {
                    $scope.resource[type].onload = true;
                }
            }
            /*advanced*/
            if (typeof ssnb_nbd_js_config != 'undefined') {
                if (type == 'block') {
                    $scope.resource[type].onload = true;
                }
            }

            $scope.updateApp();
        };
        $scope.onSearchChanged = function () {
            $scope.resource['clipart', 'overlay'].filter.searchPerPage = 25;
            $scope.resource['clipart', 'overlay'].filter.categoryPerPage = 10;
            $scope.resource['clipart', 'overlay'].filter.perPage = 25;
            $scope.updateApp();
        }
        $scope.generateTypoLink = function (typo) {
            if ($scope.settings.task == 'typography') {
                return NBDESIGNCONFIG['plg_url'] + '/data/typography/img/' + typo.id + '.png';
            } else {
                return '//dpeuzbvf3y4lr.cloudfront.net/typography/' + typo.folder + '/preview.png';
            }
        };
        /* Fonts */
        $scope.loadFontFailAction = function (font) {
            _.remove($scope.settings.gg_fonts, {
                id: font.id
            });
            $scope.resource.font.filteredFonts = filterFontFilter($scope.resource.font.data, $scope.resource.font.filter);
            $scope.updateApp();
        };
        /* Save Data */
        $scope.prepareBeforeSaveForLater = function () {
            $scope.selectedMyDesign = '';
            $scope.login(function () {
                var dataObj = {
                    product_id: NBDESIGNCONFIG['product_id'],
                    variation_id: NBDESIGNCONFIG['variation_id']
                };
                var action = 'nbd_get_user_designs';
                $scope.toggleStageLoading();
                NBDDataFactory.get(action, dataObj, function (data) {
                    data = JSON.parse(data);
                    if (data.flag == 1) {
                        $scope.resource.myTemplates = data.designs;
                        $scope.toggleStageLoading();
                        jQuery('.popup-nbd-my-templates2').nbShowPopup();
                    } else {
                        $scope.toggleStageLoading();
                    }
                });
            });
        };
        $scope.selectMyDesign = function (id) {
            $scope.selectedMyDesign = id;
            jQuery('.popup-nbd-my-templates2 .close-popup').triggerHandler('click');
            $scope.saveData('saveforlater');
        };
        $scope.showFeatureLockedPopup = function (id = 7237, text, level) {
            NBDDataFactory.get('nbd_get_elementor_template', {id, ng: text, level}, function (data) {
                if (!data) {
                    return;
                }
                const json = JSON.parse(data);
                if (json.html) {
                    jQuery('.popup-nbd-locked-feature .main-body').html(json.html);
                    jQuery('.popup-nbd-locked-feature .body .loaded').hide();
                }
            });

            jQuery('.popup-nbd-locked-feature').nbShowPopup();
        };
        $scope.showNewDesignPopup = function (id = 4085, text, level) {
            NBDDataFactory.get('nbd_get_elementor_template', {id, ng: text, level}, function (response) {
                if (!response) {
                    return;
                }

                try {
                    const json = JSON.parse(response);
                    if (json.html) {
                        jQuery('.popup-nbd-new-design .main-body').html(json.html);
                        jQuery('.popup-nbd-new-design .body .loaded').hide();
                    }
                } catch (e) {
                    console.error('Failed to parse JSON response', e);
                }
            });

            jQuery('.popup-nbd-new-design').nbShowPopup();
        };
        $scope.saveForLater = function () {
            $scope.login(function () {
                $scope.selectedMyDesign = undefined;
                $scope.saveData('saveforlater');
            });
        };
        $scope.downloadMockupPreview = function () {
            jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').addClass('active');
            var mockups = '';
            angular.forEach($scope.resource.mockups, function (mockup, key) {
                if (mockup.select) {
                    mockups += mockup.path + '|';
                }
            });
            if (mockups.length > 0) {
                var dataObj = {};
                dataObj.type = 'get_mockup';
                dataObj.folder = $scope.resource.social.folder;
                dataObj.mockups = mockups.slice(0, mockups.length - 1);
                NBDDataFactory.get('nbd_get_resource', dataObj, function (data) {
                    data = JSON.parse(data);
                    if (data.flag == 1) {
                        var filename = 'designs.zip',
                            a = document.createElement('a');
                        if (nbd_window.jQuery('.nbd-main-bar .nbd-main-menu input[name="title"]').val() != "") {
                            filename = nbd_window.jQuery('.nbd-main-bar .nbd-main-menu input[name="title"]').val().replace(' ', '_') + '_' + filename;
                        }
                        a.setAttribute('href', data.data.url);
                        a.setAttribute('download', filename);
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    } else {
                        alert('try again!');
                        console.log(data);
                    }
                    jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').removeClass('active');
                });
            } else {
                jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').removeClass('active');
                alert('Please choose mockup!');
            }
        };
        $scope.cancelMockupPreview = function () {
            jQuery('.nbd-popup.popup-nbd-mockup-preview .close-popup').triggerHandler('click');
        };
        /*advanced*/
        if (typeof pcsc_pcloud_js != "undefined") {
            $scope.currentPrivew = {
                stage: 0,
                srcPreview: ''
            }
            $scope.changePreview = function (index) {
                var _canvas = $scope.stages[index].canvas;
                $scope.currentPrivew.srcPreview = _canvas.toDataURL();
            }
            $scope.closePopupPreview = function () {
                jQuery('.nbd-popup.popup-nba-preview .close-popup').triggerHandler('click');
            }
        }
        $scope.prepareSaveTemplate = function () {
            if (typeof pcsc_pcloud_js != "undefined") {
                if ($scope.isTemplateMode && $scope.settings.task == 'edit') {
                    $scope.currentPrivew.stage = $scope.currentStage;
                    $scope.changePreview($scope.currentStage);
                    jQuery('.nbd-popup.popup-nba-preview').nbShowPopup();
                    return;
                }
            }
            jQuery('.nbd-popup.popup-template-tags').nbShowPopup();
        };
        /*advanced*/
        if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
            $scope.attrs = NBDESIGNCONFIG['setting_template'].length > 0 ? NBDESIGNCONFIG['setting_template'] : [
                {
                    name: 'basic',
                    description: '',
                    expand: false,
                    price: '',
                },
                {
                    name: 'standard',
                    description: '',
                    expand: false,
                    price: '',
                },
                {
                    name: 'premium',
                    description: '',
                    expand: false,
                    price: '',
                }
            ];
            $scope.toggleExpandSettingField = function (index) {
                var flag = $scope.attrs[index].expand;
                $scope.attrs[index].expand = !flag;
            }
            $scope.popupSaveTemplate = function () {
                jQuery('.custom').nbShowPopup();
            };
            $scope.showTemplateSettingPopup = function () {
                jQuery('.settings-template').nbShowPopup();
            }
        }
        if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
            $scope.popupSaveTemplateEmail = function () {
                jQuery('.custom').nbShowPopup();
            };
            $scope.validateEmail = function (email) {
                var re = /^(([a-zA-Z0-9]+)|([a-zA-Z0-9]+((?:\_[a-zA-Z0-9]+)|(?:\.[a-zA-Z0-9]+))*))(@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-zA-Z]{2,6}(?:\.[a-zA-Z]{2})?)$)/;
                return re.test(email);
            }
            $scope.version = NBDESIGNCONFIG.version;
        }
        /* Template tags */
        $scope.reloadTemplateTags = function () {
            $http({
                method: 'GET',
                url: NBDESIGNCONFIG['ajax_url'] + '?action=nbd_get_template_tags&nonce=' + NBDESIGNCONFIG['nonce']
            }).then(function successCallback(response) {
                if (angular.isDefined(response.data.flag) && response.data.flag == 1) {
                    $scope.customTemplate.reload = 1;
                    $scope.customTemplate.tags = response.data.tags;
                    $scope.customTemplate.tag_ids = [];
                    angular.forEach($scope.customTemplate.tags, function (tag, key) {
                        $scope.customTemplate.tag_ids.push(tag.term_id);
                    });
                }
            }, function errorCallback(response) {
                console.log('Fail to load: template tags');
            });
        };
        $scope.addTemplateTag = function (tagId) {
            var _index = _.findIndex($scope.customTemplate.selectedTags, function (tag) {
                return tag == tagId;
            });
            if (_index == -1) {
                $scope.customTemplate.selectedTags.push(tagId);
            } else {
                $scope.customTemplate.selectedTags.splice(_index, 1);
            }
        };
        $scope.isSelectedTags = function (tagId) {
            $scope.customTemplate.tag_ids.push(tagId);
            $scope.customTemplate.tag_ids = _.uniq($scope.customTemplate.tag_ids);
            return _.includes($scope.customTemplate.selectedTags, tagId);
        };
        $scope.validateTemplateTags = function () {
            var newSelectedTags = [];
            angular.forEach($scope.customTemplate.selectedTags, function (tag, key) {
                if (_.includes($scope.customTemplate.tag_ids, tag)) {
                    newSelectedTags.push(tag);
                }
            });
            return newSelectedTags;
        };
        $scope.addTemplateColor = function (color) {
            color = color.substr(1);
            $scope.customTemplate.selectedColors.push(color);
            $scope.customTemplate.selectedColors = _.uniq($scope.customTemplate.selectedColors);
            $scope.customTemplate.showPicker = false;
        };
        $scope.removeTemplateColor = function (colorIndex) {
            $scope.customTemplate.selectedColors.splice(colorIndex, 1);
        };
        $scope.selectCustomTemplatePreview = function (files) {
            $scope.customTemplate.template_thumb = files[0];
        };
        $scope.onSaveData = false;
        $scope.saveData = function (type) {
            if (typeof custom_richard != 'undefined') {
                /*advanced*/
                var mitte = document.cookie.split('; ').find(row => row.startsWith('mitte')).split('=')[1];
                nbd_window.jQuery('.variations_form, form.cart').append('<input name="nbd_mitte" type="hidden" value="' + mitte + '" />');
            }
            /*advanced*/
            if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                var alb_mailer = jQuery(".alb-mailer").val();
                var alb_recipient = jQuery(".alb-recipient").val();
                if (jQuery('.custom').hasClass('nb-show')) {
                    if (jQuery('.nbd-admin-setting-local-setting-recipient').hasClass('ng-hide')) {
                        if (alb_mailer.trim() == "") {
                            alert("At least one field must be filled out");
                            return;
                        }
                        if (!$scope.validateEmail(alb_mailer)) {
                            alert("Please include an '@' in the email address.");
                            return;
                        }
                    } else if (alb_mailer.trim() == "" || alb_recipient.trim() == "") {
                        alert("At least one field must be filled out");
                        return;
                    } else if (!$scope.validateEmail(alb_mailer) || !$scope.validateEmail(alb_recipient)) {
                        alert("Please include an '@' in the email address.");
                        return;
                    }
                }
            }
            $scope.onSaveData = true;
            jQuery('.variations_form, form.cart').find('[name="nbo-ignore-design"]').remove();
            if (angular.isUndefined(type) && angular.isDefined(nbd_window.nbOption) && angular.isDefined(nbd_window.nbOption.odOption)
                && angular.isDefined(nbd_window.nbOption.odOption.page) && angular.isDefined(nbd_window.nbOption.odOption.page.list_page) && nbd_window.nbOption.odOption.page.list_page.length == 0) {
                if (NBDESIGNCONFIG.show_nbo_option == "1" && NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.task2 == '') {
                    nbd_window.jQuery('.variations_form, form.cart').append('<input name="nbo-ignore-design" type="hidden" value="1" />');
                    jQuery('.variations_form, form.cart').submit();
                    return;
                }
                return;
            }
            if (angular.isUndefined(type)) type = $scope.settings.task;
            if (type != 'share' && type != 'save_draft') $scope.toggleStageLoading(6E4);
            if (type == 'typography') $scope.resource.usedFonts = [];
            var excludeType = ['saveforlater', 'share', 'download-pdf', 'preview_mockup', 'save_draft', 'download-jpg', 'change-product'];
            if (!_.includes(excludeType, type)) $scope.maybeZoomStage = true;
            if (_.includes(['saveforlater', 'share', 'preview_mockup', 'save_draft', 'change-product'], type)) $scope.onSaveData = false;
            if ($scope.settings.nbdesigner_dimensions_unit == 'px' && type == 'share') $scope.maybeZoomStage = true;

            function _saveData() {
                $scope.resource.config.viewport = $scope.viewPort;
                /* Backward compatible version 1.x */
                $scope.resource.config.scale = ($window.innerWidth > ($window.innerHeight - 120) ? $window.innerHeight - 120 : $window.innerWidth) / 500;
                $scope.resource.config.product = $scope.settings.product_data.product;
                if (angular.isDefined($scope.settings.product_data.origin_product)) {
                    $scope.resource.config.origin_product = $scope.settings.product_data.origin_product;
                }
                $scope.resource.config.dpi = $scope.settings.product_data.option.dpi;
                if ($scope.settings.product_data.option.option_dpi) {
                    $scope.resource.config.option_dpi = true;
                }
                if ($scope.settings.product_data.option.unit) {
                    $scope.resource.config.unit = $scope.settings.product_data.option.unit;
                }
                if (angular.isDefined(NBDESIGNCONFIG['design_id'])) {
                    $scope.resource.config.design_id = NBDESIGNCONFIG['design_id'];
                }
                if (angular.isDefined($scope.areaDesignShapes) && $scope.areaDesignShapes.length) {
                    $scope.resource.config.areaDesignShapes = $scope.areaDesignShapes;
                }
                $scope.resource.config.originPDFs = $scope.originPDFs;
                $scope.resource.config.pdfStacks = $scope.pdfStacks;
                if (angular.isDefined($scope.settings.nbes_enable_settings) && angular.isDefined($scope.settings.nbes_settings)
                    && $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined($scope.settings.nbes_settings.combination_colors)) {
                    $scope.resource.config.combinationColor = $scope.currentCombinationColor;
                }
                var dataObj = {};
                dataObj.used_font = new Blob([JSON.stringify($scope.resource.usedFonts)], {type: "application/json"});
                if (type == 'template') $scope.resource.jsonDesign.canvas = {
                    width: $scope.templateSize.width,
                    height: $scope.templateSize.height
                };
                /*advanced*/
                if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                    var number_side = $scope.settings.product_data.product.length;
                    var a = $scope.resource.jsonDesign["frame_" + (number_side - 1)].objects;
                    a.forEach((e, i) => {
                        if (a[i].idvalue != 'undefined' && a[i].text == "") {
                            Object.assign(a[i], {idvalue: "valuevourcher"});
                        }
                        if ((NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.ui_mode == 1) || (NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == '')) {
                            if (a[i].sampleText != 'undefined' && a[i].sampleText == "sampleText") {
                                Object.assign(a[i], {visible: false});
                            }
                            if (a[i].termCodition != 'undefined' && a[i].termCodition == "coditionText") {
                                Object.assign(a[i], {visible: true});
                            }
                        }
                    });
                }
                dataObj.design = new Blob([JSON.stringify($scope.resource.jsonDesign)], {type: "application/json"});
                if (type === 'download-pdf') {
                    _.each($scope.stages, function (stage, index) {
                        var key = 'frame_' + index,
                            svg_key = 'frame_' + index + '_svg';
                        dataObj[key] = $scope.makeblob(stage.design);
                        dataObj[svg_key] = new Blob([stage.svg], {type: "image/svg"});
                        if (angular.isDefined($scope.partialSvgs[index]) && $scope.partialSvgs[index].length) {
                            $scope.partialSvgs[index].forEach(function (partialSvg, partialIndex) {
                                var partial_svg_key = 'frame_' + index + '_svg_part_' + partialIndex;
                                dataObj[partial_svg_key] = new Blob([partialSvg], {type: "image/svg"});
                            });
                        }
                    });
                } else {
                    dataObj['frame_0'] = $scope.makeblob($scope.stages[0].frame_preview || $scope.stages[0].design);
                }
                switch (type) {
                    case 'typography':
                        dataObj.type = 'save_typography';
                        dataObj.id = $scope.resource.currentTypo;
                        _.each($scope.stages, function (stage, index) {
                            var key = 'frame_' + index;
                            dataObj[key] = $scope.makeblob(stage.design);
                        });
                        NBDDataFactory.get('nbd_get_resource', dataObj, function (data) {
                            $scope.stages[0].states.usedFonts = [];
                            alert('Success!');
                        });
                        break;
                    case 'template':
                        dataObj.type = 'save_template';
                        dataObj.source = 'media';
                        dataObj.tem_name = $scope.templateName;
                        dataObj.cid = $scope.templateCat;
                        jQuery('.popup-template .close-popup').triggerHandler('click');
                        NBDDataFactory.get('nbd_get_resource', dataObj, function (data) {
                            data = JSON.parse(data);
                            if (data.flag == 1) {
                                /*advanced*/
                                if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                                    function replaceObjectJson() {
                                        var number_side =
                                            $scope.settings.product_data.product.length;
                                        var a = data.design["frame_" + (number_side - 1)].objects;
                                        var objects = a;
                                        money = NBDESIGNCONFIG.val_money;
                                        var str = money;
                                        str = str.replace("&pound;", "£");
                                        money = str;
                                        for (var i = 0; i < objects.length; i++) {
                                            if (objects[i].itemId === "vourcher") {
                                                objects[i].text =
                                                    "Vourcher No: " + NBDESIGNCONFIG.id_order +
                                                    "\n" +
                                                    "Issue Date: " +
                                                    NBDESIGNCONFIG.date;
                                            }
                                        }
                                    }

                                    replaceObjectJson();
                                }
                                _.each($scope.stages, function (stage, index) {
                                    stage.states.usedFonts = [];
                                });
                                $scope.resource.usedFonts = [];
                                $scope.listAddedColor = [];
                                $scope.resetStage();
                                $scope.toggleStageLoading();
                                alert('Success!');
                            } else {
                                alert('Try again!');
                            }
                        });
                        break;
                    case 'saveforlater':
                    default:
                        ['product_id', 'variation_id', 'task', 'task2', 'design_type', 'nbd_item_key', 'cart_item_key', 'order_id', 'enable_upload_without_design', 'auto_add_to_cart', 'ui_mode'].forEach(function (key) {
                            dataObj[key] = NBDESIGNCONFIG[key];
                        });
                        let isAdminTemplate;
                        const queryString = window.location.search;
                        const urlParams = new URLSearchParams(queryString);
                        const admin = urlParams.get('rd');
                        isAdminTemplate = admin === 'admin_templates';
                        /*advanced*/
                        if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
                            var settings = jQuery('#form-settings').serializeArray();
                            settings.forEach(ele => {
                                dataObj[ele.name] = ele.value;
                            });
                            if (angular.isDefined(NBDESIGNCONFIG['price_package']) && NBDESIGNCONFIG['price_package'] != '') {
                                dataObj['price_package'] = NBDESIGNCONFIG['price_package'];
                            }
                        }
                        if (angular.isDefined(NBDESIGNCONFIG['design_id'])) {
                            dataObj['design_id'] = NBDESIGNCONFIG['design_id'];
                        }
                        if (type == 'share') dataObj['share'] = 1;
                        if (type == 'change-product') dataObj['switched_product'] = $scope.switchedProduct;
                        dataObj['nbd_file'] = '';
                        /*advanced*/
                        if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                            dataObj["nbod_alb"] = $scope.settings['nbod_alb'];
                        }
                        dataObj.config = new Blob([JSON.stringify($scope.resource.config)], {type: "application/json"});
                        if ($scope.resource.config.qty != null) {
                            dataObj.qty = $scope.resource.config.qty;
                        } else {
                            delete $scope.resource.config.qty;
                        }
                        $timeout(function () {
                            var action = (!_.includes(excludeType, type) && NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.ui_mode == 2) ? 'nbd_save_cart_design' : 'nbd_save_customer_design';
                            if (NBDESIGNCONFIG.show_nbo_option == "1" && NBDESIGNCONFIG.task == 'new') {
                                action = 'nbd_save_customer_design';
                            }
                            if (action === 'nbd_save_customer_design') {
                                if (angular.isDefined($scope.selectedMyDesign) && $scope.selectedMyDesign != '') {
                                    dataObj.pre_folder = $scope.selectedMyDesign;
                                } else if (!angular.isDefined($scope.selectedMyDesign) && (NBDESIGNCONFIG['nbd_item_key'] || $scope.savedNbdKey)) {
                                    dataObj.pre_folder = $scope.savedNbdKey || NBDESIGNCONFIG['nbd_item_key'];
                                }
                                dataObj['is_admin_template'] = isAdminTemplate || '';
                            }
                            if (type == 'save_draft') {
                                action = 'nbd_save_draft_design';
                                dataObj.save_draft = 1;
                                if (angular.isDefined($scope.resource.draft_folder) && $scope.resource.draft_folder != '') dataObj.draft_folder = $scope.resource.draft_folder;
                            }
                            if (type == 'preview_mockup') {
                                dataObj.generate_mockup = 1;
                                jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').addClass('active');
                            }
                            if (NBDESIGNCONFIG.task == 'create' || (NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template')) {
                                if ($scope.customTemplate.type == 2) {
                                    dataObj['template_thumb'] = $scope.customTemplate.template_thumb;
                                }
                                // nbd add all template ai to svg
                                if (typeof nbptemp_all_ai_to_svg != "undefined") {
                                    $scope.catetemplae = '';
                                    if ($scope.customTemplate.type == 3) {
                                        dataObj['templateall'] = 1;
                                    }
                                    if ($scope.customTemplate.type == 4) {
                                        dataObj['templateall'] = 1;
                                        dataObj['tempcate'] = jQuery("#seclect_temp").val();
                                    }
                                }
                                dataObj['template_name'] = $scope.customTemplate.name;
                                dataObj['template_type'] = $scope.customTemplate.type;
                                var selectedTags = $scope.validateTemplateTags();
                                dataObj['template_tags'] = selectedTags.join(',');
                                dataObj['template_colors'] = $scope.customTemplate.selectedColors.join(',');
                                /*advanced*/
                                if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
                                    dataObj['price'] = $scope.customTemplate.price;
                                }
                                $scope.closePopup('.popup-template-tags');
                            }
                            /*advanced*/
                            if (typeof mctp_nbd_js_config_design != "undefined") {
                                dataObj['template_typeTemplate'] = $scope.customTemplate.typeTemplate;
                            }
                            /*advanced*/
                            if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
                                dataObj['nba_template_price'] = $scope.priceTem;
                            }

                            NBDDataFactory.get(action, dataObj, function (data) {
                                data = JSON.parse(data);
                                if (data.flag == 'success') {
                                    if (type == 'save_draft') {
                                        $scope.resource.draft_folder = data.draft_folder;
                                        return;
                                    }
                                    if (type == 'preview_mockup') {
                                        if (data.mockups) {
                                            $scope.resource.mockups = data.mockups;
                                            $scope.resource.social.folder = data.folder;
                                            var origin_url = 'whatsapp://send?text=';
                                            var d = new Date();
                                            var share_url = NBDESIGNCONFIG.nbd_create_own_page + '?product_id=' + NBDESIGNCONFIG.product_id + '&variation_id=' + NBDESIGNCONFIG.variation_id + '&reference=' + $scope.resource.social.folder + '&nbd_share_id=' + $scope.resource.social.folder + '&t=' + d.getTime();
                                            $scope.resource.social.wa_link = origin_url + encodeURIComponent(share_url);
                                            jQuery('.whatsapp_share').attr('href', $scope.resource.social.wa_link);
                                        }
                                        $timeout(function () {
                                            jQuery('.nbd-simple-slider').nbSimpleSlider();
                                        });
                                        jQuery('.nbd-popup.popup-nbd-mockup-preview').find('.overlay-main').removeClass('active');
                                        $scope.toggleStageLoading();
                                        return;
                                    }
                                    if (type == 'download-pdf' || type == 'download-jpg') {
                                        var _dataObj = {nbd_item_key: data.folder};
                                        var action2 = type == 'download-pdf' ? 'nbd_frontend_download_pdf' : 'nbd_frontend_download_jpeg';
                                        NBDDataFactory.get(action2, _dataObj, function (_data) {
                                            _data = JSON.parse(_data);
                                            if (_data[0].flag == 1) {
                                                var filename = type == 'download-pdf' ? 'design.pdf' : 'designs.zip',
                                                    t = new Date().getTime(),
                                                    a = document.createElement('a');
                                                if (nbd_window.jQuery('.nbd-main-bar .nbd-main-menu input[name="title"]').val() != "") {
                                                    filename = nbd_window.jQuery('.nbd-main-bar .nbd-main-menu input[name="title"]').val().replace(' ', '_') + '_' + filename;
                                                }
                                                a.setAttribute('href', _data[0].link + '?t=' + t);
                                                a.setAttribute('download', filename);
                                                a.style.display = 'none';
                                                document.body.appendChild(a);
                                                a.click();
                                                document.body.removeChild(a);
                                                $scope.toggleStageLoading();
                                            }
                                        });
                                        return;
                                    }
                                    if (type == 'change-product') {
                                        window.open(data['redirect_url'], '_blank');
                                        $scope.toggleStageLoading();
                                        return;
                                    }
                                    if (NBDESIGNCONFIG.ui_mode == 3) {
                                        if (NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.task2 == '') {
                                            $scope.toggleStageLoading();
                                            jQuery(document).triggerHandler('nbd_design_stored', {_type: type});
                                            return;
                                        } else {
                                            if (NBDESIGNCONFIG['redirect_url'] != "") {
                                                window.location = NBDESIGNCONFIG['redirect_url'];
                                                return;
                                            }
                                            ;
                                        }
                                    }
                                    if (type == 'saveforlater' && !isAdminTemplate) {
                                        const title = document.querySelector('.nbd-main-bar .nbd-main-menu input[name="title"]').value;
                                        var _dataObj = {
                                            product_id: NBDESIGNCONFIG.product_id,
                                            variation_id: NBDESIGNCONFIG.variation_id,
                                            folder: data.folder,
                                            my_design_title: title
                                        };
                                        if (angular.isDefined($scope.selectedMyDesign) && $scope.selectedMyDesign != '') {
                                            _dataObj.pre_folder = $scope.selectedMyDesign;
                                        } else if (!angular.isDefined($scope.selectedMyDesign) && (NBDESIGNCONFIG['nbd_item_key'] || $scope.savedNbdKey)) {
                                            _dataObj.pre_folder = $scope.savedNbdKey || NBDESIGNCONFIG['nbd_item_key'];
                                        }
                                        NBDDataFactory.get('nbd_save_for_later', _dataObj, function (_data) {
                                            _data = JSON.parse(_data);
                                            if (angular.isDefined($scope.selectedMyDesign) && $scope.selectedMyDesign != '') {
                                                if (_data.src) {
                                                    _.each($scope.resource.myTemplates, function (template, index) {
                                                        if (template.id == _data.folder) {
                                                            template.src = _data.src;
                                                        }
                                                    });
                                                }
                                            }
                                            ;
                                            $scope.savedNbdKey = _data.folder;
                                            $scope.selectedMyDesign = undefined;
                                            $scope.toggleStageLoading();
                                            jQuery('.nbd-toasts__saved').nbToasts();
                                        });
                                        return;
                                    }
                                    if (type == 'share') {
                                        $scope.resource.social.folder = data.sfolder;
                                        $scope.resource.social.images = data.image;
                                        jQuery('.nbd-popup.popup-share').find('.overlay-main').removeClass('active');
                                        return;
                                    } else {
                                        if (NBDESIGNCONFIG.show_nbo_option == "1" && (NBDESIGNCONFIG.task == 'new' || NBDESIGNCONFIG.task2 == 'update')) {
                                            if (NBDESIGNCONFIG.show_nbo_option == "1" && NBDESIGNCONFIG.task == 'new') {

                                            }
                                            ;
                                            jQuery('.variations_form, form.cart').submit();
                                            return;
                                        }
                                        if (NBDESIGNCONFIG['redirect_url'] != "") {
                                            // nbd add all template ai to svg
                                            if (typeof nbptemp_all_ai_to_svg != "undefined") {
                                                if ($scope.customTemplate.type == 3) {
                                                    window.location = NBDESIGNCONFIG['newURL'];
                                                    return;
                                                }
                                            }
                                            if (!isAdminTemplate) {
                                                window.location = NBDESIGNCONFIG['redirect_url'];
                                            } else {
                                                $scope.toggleStageLoading();
                                            }
                                            return;
                                        }
                                        ;
                                        if (NBDESIGNCONFIG['nbdesigner_auto_add_cart_in_detail_page'] == "yes" && NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.ui_mode == 1 && !(angular.isDefined(NBDESIGNCONFIG.edit_option_mode) && NBDESIGNCONFIG.edit_option_mode == '1')) {
                                            /*advanced*/
                                            if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                                                var alb_mailer = jQuery(".alb-mailer").val();
                                                var alb_recipient = jQuery(".alb-recipient").val();
                                                var alb_txtdate = jQuery("#txtdate").val();
                                                var alb_hour = jQuery(".hour").val();
                                                nbd_window.NBDESIGNERPRODUCT.add_email_order_template(alb_mailer, alb_recipient, alb_txtdate, alb_hour);
                                            }
                                            nbd_window.jQuery('.variations_form, form.cart').append('<input name="add-to-cart" type="hidden" value="' + NBDESIGNCONFIG.product_id + '" />');
                                            nbd_window.jQuery('.variations_form, form.cart').append('<input name="nbd-auto-add-to-cart-in-detail-page" type="hidden" value="1" />');
                                            nbd_window.jQuery(nbd_window.document).triggerHandler('nbd_design_stored', {
                                                _type: type,
                                                prevent_ajax: 1
                                            });
                                        } else {
                                            nbd_window.NBDESIGNERPRODUCT.product_id = NBDESIGNCONFIG['product_id'];
                                            nbd_window.NBDESIGNERPRODUCT.variation_id = NBDESIGNCONFIG['variation_id'];
                                            nbd_window.NBDESIGNERPRODUCT.folder = data.folder;
                                            nbd_window.NBDESIGNERPRODUCT.show_design_thumbnail(data.image, NBDESIGNCONFIG['task'], $scope.resource.config);
                                            nbd_window.NBDESIGNERPRODUCT.get_sugget_design(NBDESIGNCONFIG['product_id'], NBDESIGNCONFIG['variation_id']);
                                            /*advanced*/
                                            if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
                                                nbd_window.NBDESIGNERPRODUCT.add_field_hire_designer($scope.priceTem, $scope.currentTemp.id);
                                            }
                                            if (NBDESIGNCONFIG.ui_mode == 1 && $scope.resource.config.qty != null) {

                                            }
                                            if (NBDESIGNCONFIG.ui_mode == 1 && angular.isDefined(data.gallery)) {
                                                nbd_window.jQuery(nbd_window.document).triggerHandler('nbd_update_gallery', {
                                                    gallery: data.gallery,
                                                    folder: data.folder
                                                });
                                            }
                                            $scope.toggleStageLoading();
                                            $timeout(function () {
                                                _.each($scope.stages, function (stage, index) {
                                                    //$scope.zoomStage(stage.states.fitScaleIndex, index);
                                                });
                                            });
                                        }
                                    }
                                } else {
                                    console.log('Oops! Design has not been saved!');
                                    if (type != 'save_draft') {
                                        $scope.toggleStageLoading()
                                    }
                                    ;
                                }
                                $scope.onSaveData = false;
                            });
                        });
                        break;
                }
            };

            function waitForSaveDesign() {
                $scope.saveDesign();
                if ($scope.checkSaveStatus()) {
                    _saveData();
                } else {
                    var interval = $interval(function () {
                        if ($scope.checkSaveStatus()) {
                            $interval.cancel(interval);
                            _saveData();
                        }
                    }, 100);
                }
            }

            if ($scope.onSaveData && NBDESIGNCONFIG.nbdesigner_enable_font_to_outlines == 'yes') {
                $scope.loadOutlineFonts();
                var status = $scope.checkLoadedOutlineFont();
                if (status.error) {
                    alert(NBDESIGNCONFIG.nbdlangs.wrong_to_convert_outline_font);
                    return;
                }
                if (status.loaded) {
                    waitForSaveDesign();
                } else {
                    var _interval = $interval(function () {
                        var status = $scope.checkLoadedOutlineFont();
                        if (status.error) {
                            $interval.cancel(_interval);
                            alert(NBDESIGNCONFIG.nbdlangs.wrong_to_convert_outline_font);
                        }
                        if (status.loaded) {
                            $interval.cancel(_interval);
                            waitForSaveDesign();
                        }
                    }, 100);
                }
            } else {
                waitForSaveDesign();
            }
        };
        $scope.createShareLink = function (type, origin_url) {
            $scope.resource.social.type = type;
            var d = new Date();
            var share_url = NBDESIGNCONFIG.nbd_create_own_page + '?product_id=' + NBDESIGNCONFIG.product_id + '&variation_id=' + NBDESIGNCONFIG.variation_id + '&reference=' + $scope.resource.social.folder + '&nbd_share_id=' + $scope.resource.social.folder + '&t=' + d.getTime();
            if (jQuery('.quick-view form .variations select').length) {
                share_url += '&' + jQuery('.quick-view form .variations select').serialize();
            } else if ($scope.settings.ui_mode == 1 && nbd_window.jQuery('.variations_form .variations select').length) {
                share_url += '&' + nbd_window.jQuery('.variations_form .variations select').serialize();
            }
            $scope.resource.social.link = origin_url + encodeURIComponent(share_url);
            $scope.resource.social.design_link = share_url;
            var comment = angular.isDefined($scope.resource.social.comment) ? $scope.resource.social.comment : $scope.settings.nbdlangs.my_design;
            if (type == 'twitter') $scope.resource.social.link += '&text=' + comment;
        };
        $scope.copyShareLink = function (e) {
            jQuery(e.target).siblings('input').select();
            document.execCommand("copy");
        };
        $scope.copyColorCode = function (e) {
            jQuery(e.target).siblings('input').select();
            document.execCommand("copy");
        };
        $scope.updateShareLink = function () {
            var link = $scope.resource.social.link;
            if (link.indexOf('&text=') > -1) {
                link = link.substr(0, link.indexOf('&text=') + 6) + $scope.resource.social.comment;
                $scope.resource.social.link = link;
            }
        };
        $scope.outlineFonts = [];
        $scope.loadOutlineFonts = function () {
            _.each($scope.stages, function (stage, index) {
                var _canvas = stage.canvas;
                _canvas.forEachObject(function (obj, objIndex) {
                    if (obj.type == 'i-text' || obj.type == 'textbox' || obj.type == 'text' || obj.type == 'curvedText') {
                        var fontName = obj.get('fontFamily'),
                            font = _.filter($scope.resource.font.data, {alias: fontName})[0],
                            fontWeight = obj.get('fontWeight'),
                            fontStyle = obj.get('fontStyle'),
                            font_url = '';

                        if (fontWeight == 'bold') {
                            if (fontStyle == 'italic') {
                                font_url = font.file.bi != 1 ? font.file.bi : NBDESIGNCONFIG.default_font.file.bi;
                                fontName += '__bi';
                            } else {
                                font_url = font.file.b != 1 ? font.file.b : NBDESIGNCONFIG.default_font.file.b;
                                fontName += '__b';
                            }
                        } else {
                            if (fontStyle == 'italic') {
                                font_url = font.file.i != 1 ? font.file.i : NBDESIGNCONFIG.default_font.file.i;
                                fontName += '__i';
                            } else {
                                font_url = font.file.r != 1 ? font.file.r : NBDESIGNCONFIG.default_font.file.r;
                            }
                        }

                        if (font.type != 'google') {
                            font_url = NBDESIGNCONFIG['font_url'] + font_url;
                        } else {
                            font_url = font_url.replace('http:', 'https:');
                        }

                        if (_.filter($scope.outlineFonts, {name: fontName}).length == 0) {
                            $scope.outlineFonts.push({
                                name: fontName,
                                url: font_url,
                                loaded: false,
                                error: false
                            });
                        }
                    }
                });
            });

            $scope.outlineFonts.forEach(function (font) {
                opentype.load(font.url, function (err, fontJson) {
                    if (err) {
                        font.error = true;
                    } else {
                        font.loaded = true;
                        window.outlineFonts[font.name] = fontJson;
                    }
                });
            });
        };
        $scope.checkLoadedOutlineFont = function () {
            var status = {
                loaded: true,
                error: false
            };
            $scope.outlineFonts.forEach(function (font) {
                if (!font.loaded) {
                    status.loaded = false;
                }
                if (font.error) {
                    status.error = true;
                }
            });
            return status;
        };
        $scope.maybeZoomStage = false;
        $scope.stageSaveStatus = [];
        $scope.originPDFs = [];
        $scope.pdfStacks = [];
        $scope.partialSvgs = [];
        $scope.checkSaveStatus = function () {
            var status = true;
            $scope.stageSaveStatus.forEach(function (stageStatus) {
                if (!stageStatus) {
                    status = false;
                }
            });
            return status;
        };
        $scope.createPreviewWithClippath = function (index, callback) {
            var stage = $scope.stages[index];
            if (angular.isUndefined(stage)) return;

            var design = stage.design,
                _canvas = stage.canvas,
                width = _canvas.width,
                height = _canvas.height;

            if (!design) return;

            function createPreviewSvg() {
                var svg = '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">';
                svg += '<defs>';
                svg += '<clipPath id="area-design-shape-' + index + '"><path d="' + $scope.areaDesignClipPaths[index] + '" /></clipPath>';
                svg += '</defs>';

                svg += '<g clip-path="url(#area-design-shape-' + index + ')">';
                if (stage.config.bgType == 'color') {
                    svg += '<rect x="0" y="0" width="' + width + '" height="' + height + '" fill="' + stage.config.bgColor + '" />';
                }

                svg += '<image x="0" y="0" width="' + width + '" height="' + height + '"' + ' xlink:href="' + design + '" />';
                svg += '</g>';
                svg += '</svg>';
                return svg;
            }

            var previewSvg = createPreviewSvg(),
                img = new Image();
            url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(previewSvg);
            img.onload = function () {
                var kanvas = document.createElement("canvas");
                kanvas.width = width;
                kanvas.height = height,
                    context = kanvas.getContext('2d');
                context.drawImage(img, 0, 0, width, height, 0, 0, width, height);

                stage.design = kanvas.toDataURL();
                if (typeof callback == 'function') {
                    $timeout(function () {
                        callback();
                    });
                }
            }
            img.src = url;
        };
        $scope.downloadDesign = function (downloadType) {
            if (NBDESIGNCONFIG.nbdesigner_enable_font_to_outlines == 'yes') {
                $scope.loadOutlineFonts();
                var status = $scope.checkLoadedOutlineFont();
                if (status.error) {
                    alert(NBDESIGNCONFIG.nbdlangs.wrong_to_convert_outline_font);
                    return;
                }
                if (status.loaded) {
                    $scope.saveDesign(downloadType);
                } else {
                    var _interval = $interval(function () {
                        var status = $scope.checkLoadedOutlineFont();
                        if (status.error) {
                            $interval.cancel(_interval);
                            alert(NBDESIGNCONFIG.nbdlangs.wrong_to_convert_outline_font);
                        }
                        if (status.loaded) {
                            $interval.cancel(_interval);
                            $scope.saveDesign(downloadType);
                        }
                    }, 100);
                }
            } else {
                $scope.saveDesign(downloadType);
            }
        };
        $scope.handleDownloadClick = function () {
            const {format, dpi, pages, size, quality, forceTransparency} = $scope.downloadOptions;
            switch (format) {
                case 'png':
                    $scope.saveDesign(format, pages, size, dpi, null, forceTransparency);
                    break;
                case 'webp':
                    $scope.saveDesign(format, pages, size, dpi, null, forceTransparency);
                    break;
                case 'download-jpg':
                    $scope.saveDesign('jpg', pages, size, dpi, quality);
                    break;
                case 'svg':
                    $scope.saveDesign(format, pages);
                    break;
                case 'download-pdf':
                    $scope.saveData(format);
                    break;
                default:
                    break;
            }
        }

        $scope.saveDesign = function (downloadType, pages, size, dpi, quality, forceTransparency) {
            if ($scope.settings.nbdesigner_dimensions_unit == 'px' && angular.isDefined(downloadType) && (downloadType == 'png' || downloadType == 'jpg' || downloadType == 'webp')) {
                $scope.maybeZoomStage = true;
            }
            $scope.stageSaveStatus = [];
            $scope.partialSvgs = [];
            const stages = $scope.stages
                .filter((stage, index) => {
                    if (!pages || (pages && pages.includes('all'))) {
                        return true;
                    }
                    return pages.includes(String(index));
                })
            _.each(stages, function (stage, index) {
                const dimensionsUnit = (stage.unit || $scope.settings.nbdesigner_dimensions_unit);
                const productDpi = (stage.dpi || $scope.settings.product_data.option.dpi);
                $scope.stageSaveStatus[index] = false;
                $scope.deactiveAllLayer(index);
                var zoomIndex = stage.states.fillScaleIndex != -1 ? stage.states.fillScaleIndex : stage.states.fitScaleIndex;
                if ($scope.maybeZoomStage) $scope.zoomStage(zoomIndex, index);
                var _canvas = stage.canvas,
                    key = 'frame_' + index;
                let originalCanvasBackground = _canvas.backgroundColor;
                $scope.renderStage(index);
                $scope.resource.jsonDesign[key] = _canvas.toJSON($scope.includeExport);
                stage.svg = _canvas.toSVG();
                if (forceTransparency) {
                    _canvas.setBackgroundColor('rgba(0, 0, 0, 0)');
                }
                if (!dpi || downloadType === 'svg') {
                    if (dpi && dpi !== productDpi && dimensionsUnit !== 'px') {
                        const canvasWidth = _canvas.width;
                        const configWidth = stage.config._width;
                        const dpiAdoptedWidth = configWidth * dpi / productDpi;
                        const multiplier = dpiAdoptedWidth / canvasWidth;
                        stage.design = _canvas.toDataURL({
                            format: downloadType === 'jpg' ? 'jpeg' : downloadType,
                            multiplier: multiplier * size || 1,
                            quality: quality || 1
                        });
                    } else {
                        const params = {
                            format: downloadType === 'jpg' ? 'jpeg' : downloadType,
                            multiplier: size || 1,
                            quality: quality || 1
                        };
                        stage.design = _canvas.toDataURL(params);
                        stage.frame_preview = _canvas.toDataURL({...params, format: 'jpeg', quality: 0.8});
                    }
                } else {
                    if (dpi && dpi !== productDpi && dimensionsUnit !== 'px') {
                        const canvasWidth = _canvas.width;
                        const configWidth = stage.config._width;
                        const dpiAdoptedWidth = configWidth * dpi / productDpi;
                        const multiplier = dpiAdoptedWidth / canvasWidth;
                        if (downloadType !== 'webp') {
                            stage.design = changeDpiDataUrl(
                                _canvas.toDataURL({
                                    format: downloadType === 'jpg' ? 'jpeg' : 'downloadType',
                                    multiplier: multiplier * size || 1,
                                    quality: quality || 1
                                }),
                                dpi
                            );
                        } else {
                            stage.design = _canvas.toDataURL({
                                format: 'webp',
                                multiplier: multiplier * size || 1,
                            });
                        }
                    } else {
                        if (downloadType !== 'webp') {
                            stage.design = changeDpiDataUrl(
                                _canvas.toDataURL({
                                    format: downloadType === 'jpg' ? 'jpeg' : downloadType,
                                    multiplier: size || 1,
                                    quality: quality || 1
                                }),
                                dpi
                            );
                        } else {
                            stage.design = _canvas.toDataURL({
                                format: 'webp',
                                multiplier: size || 1,
                            });
                        }
                    }
                }
                _canvas.setBackgroundColor(originalCanvasBackground);
                stage.config.svgWidth = _canvas.width;
                stage.config.svgHeight = _canvas.height;

                $scope.pdfStacks[index] = '';
                if (angular.isDefined($scope.originPDFs[index]) && $scope.originPDFs[index].length) {
                    var objectLen = _canvas.getObjects().length,
                        pdfLen = $scope.originPDFs[index].length,
                        part = 0,
                        first, last;

                    function storePartialSvg(first, last, part) {
                        var count = 0;
                        _canvas.forEachObject(function (obj, objIndex) {
                            if (objIndex > first && objIndex < last) {
                                obj.set({excludeFromExport: false});
                                count++;
                            } else {
                                obj.set({excludeFromExport: true});
                            }
                        });
                        if (count) {
                            $scope.partialSvgs[index] = $scope.partialSvgs[index] || [];
                            $scope.partialSvgs[index][part] = _canvas.toSVG();
                            return true;
                        }
                        return false;
                    }

                    var stack = '';
                    $scope.originPDFs[index].forEach(function (pdf, pdfIndex) {
                        if (pdfIndex == 0) {
                            first = -1;
                            last = pdf.index;
                            if (storePartialSvg(first, last, part)) {
                                part++;
                                stack = '0';
                            }
                        }

                        first = pdf.index;
                        if (pdfIndex < (pdfLen - 1)) {
                            last = $scope.originPDFs[index][pdfIndex + 1].index;
                        } else {
                            last = objectLen;
                        }

                        stack += '_P';

                        if (storePartialSvg(first, last, part)) {
                            stack += '_' + part;
                            part++;
                        }
                    });
                    if (stack.startsWith("_")) {
                        stack = stack.substr(1);
                    }
                    $scope.pdfStacks[index] = stack;

                    _canvas.forEachObject(function (obj) {
                        obj.set({excludeFromExport: false});
                    });
                }

                if (angular.isDefined($scope.areaDesignZoomedClipPaths[index]) && $scope.areaDesignZoomedClipPaths[index] && !downloadType) {
                    $timeout(function () {
                        var clipPath = '<clipPath id="area-design-shape-' + index + '"><path d="' + $scope.areaDesignZoomedClipPaths[index] + '" /></clipPath>';

                        var bg = '';
                        if (stage.config.bgType == 'color') {
                            bg = '<rect x="0" y="0" width="' + stage.config.svgWidth + '" height="' + stage.config.svgHeight + '" fill="' + stage.config.bgColor + '" />';
                        }
                        var newSvg = stage.svg.replace('<\/defs>', clipPath + '<\/defs><g clip-path="url(#area-design-shape-' + index + ')">' + bg);

                        newSvg = newSvg.replace('<\/svg>', '<\/g><\/svg>');
                        stage.svg = newSvg;

                        $timeout(function () {
                            $scope.createPreviewWithClippath(index, function () {
                                $scope.stageSaveStatus[index] = true;
                            });
                        }, 100);
                    }, 300);
                } else if ($scope.onSaveData && NBDESIGNCONFIG.enable_sticker_preview && index == 0) {
                    $scope.generateStickerCutline(true);
                    var interval = $interval(function () {
                        if ($scope.stickerCutline.active) {
                            $interval.cancel(interval);
                            $scope.stageSaveStatus[0] = true;
                            $scope.resource.config.contour = $scope.stickerCutline.svg;
                        }
                    }, 100);
                } else {
                    $scope.stageSaveStatus[index] = true;
                }

                $scope.resource.usedFonts = _.concat($scope.resource.usedFonts, stage.states.usedFonts);
            });
            $scope.resource.usedFonts = _.uniqBy($scope.resource.usedFonts, 'alias');
            $scope.maybeZoomStage = false;
            if (downloadType) {
                $scope.toggleStageLoading();
                $timeout(function () {
                    $scope.toggleStageLoading();
                    _.each(stages, function (stage, index) {
                        $timeout(function () {
                            var filename = (index + 1) + ((downloadType == 'png' || downloadType == 'jpg' || downloadType == 'webp') ? `.${downloadType}` : '.svg'),
                                a = document.createElement('a');
                            if (stage.config.name) {
                                filename = stage.config.name
                            }

                            function download() {
                                a.setAttribute('download', filename);
                                a.style.display = 'none';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                if (navigator.userAgent.indexOf("Edge") > -1) {
                                    setTimeout(function () {
                                        return window.URL.revokeObjectURL(_data);
                                    }, 1000);
                                }

                                if ($scope.settings.nbdesigner_dimensions_unit == 'px' && angular.isDefined(downloadType) && (downloadType == 'png' || downloadType == 'jpg' || downloadType == 'webp')) {
                                    $scope.zoomStage(stage.states.fitScaleIndex, index);
                                }
                            }

                            if (downloadType == 'png' || downloadType == 'jpg' || downloadType == 'webp') {
                                function downloadPng() {
                                    var _data = stage.design;
                                    if (navigator.userAgent.indexOf("Edge") > -1) {
                                        var blob;
                                        blob = $scope.makeblob(_data);
                                        _data = window.URL.createObjectURL(blob);
                                    }
                                    a.setAttribute('href', _data);
                                    download();
                                }

                                if (angular.isDefined($scope.areaDesignClipPaths[index]) && $scope.areaDesignClipPaths[index]) {
                                    $timeout(function () {
                                        $scope.createPreviewWithClippath(index, function () {
                                            downloadPng();
                                        });
                                    }, 300);
                                } else {
                                    downloadPng();
                                }
                            } else {
                                if (angular.isDefined($scope.areaDesignZoomedClipPaths[index]) && $scope.areaDesignZoomedClipPaths[index]) {
                                    var clipPath = '<clipPath id="area-design-shape-' + index + '"><path d="' + $scope.areaDesignZoomedClipPaths[index] + '" /></clipPath>';
                                    var bg = '';
                                    if (stage.config.bgType == 'color') {
                                        bg = '<rect x="0" y="0" width="' + stage.config.svgWidth + '" height="' + stage.config.svgHeight + '" fill="' + stage.config.bgColor + '" />';
                                    }
                                    var newSvg = stage.svg.replace('<\/defs>', clipPath + '<\/defs><g clip-path="url(#area-design-shape-' + index + ')">' + bg);
                                    newSvg = newSvg.replace('<\/svg>', '<\/g><\/svg>');
                                    stage.svg = newSvg;
                                }
                                var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(stage.svg);
                                a.setAttribute('href', url);
                                download();
                            }


                        }, index * 500);
                    });
                }, 300);
            }
        };
        $scope.makeblob = function (dataURL) {
            var BASE64_MARKER = ';base64,';
            if (dataURL.indexOf(BASE64_MARKER) == -1) {
                var parts = dataURL.split(',');
                var contentType = parts[0].split(':')[1];
                var raw = decodeURIComponent(parts[1]);
                return new Blob([raw], {type: contentType});
            }
            var parts = dataURL.split(BASE64_MARKER);
            var contentType = parts[0].split(':')[1];
            var raw = window.atob(parts[1]);
            var rawLength = raw.length;
            var uInt8Array = new Uint8Array(rawLength);
            for (var i = 0; i < rawLength; ++i) {
                uInt8Array[i] = raw.charCodeAt(i);
            }
            return new Blob([uInt8Array], {type: contentType});
        };
        $scope.setImageMaskEffect = function (src) {
            const canvas = $scope.getCurrentStageCanvas();
            const item = canvas.getActiveObject();
            if (item.isMask || item.maskId) {
                return;
            }
            $scope.createClippingMaskFromShape();
            $timeout(() => {
                $scope.resource.addImageContext = 'manual';
                $scope.addImageFromUrl({url: src});
            }, 1000);
        }
        $scope.updateApp = function () {
            if ($scope.$root.$$phase !== "$apply" && $scope.$root.$$phase !== "$digest") $scope.$apply();
        };
        $scope.$on('showFeatureLockedPopup', function (event, e) {
            $scope.showFeatureLockedPopup(e.id, e.text, e.level);
        })
        $scope.$on('nbd:keypress', function (event, e) {
            $scope.keypressHandle(e);
        });
        $scope.$on('nbd:keydown', function (event, e) {
            $scope.keydownHandle(e);
        });
        $scope.keydownHandle = function (e) {
        };

        $scope.wraperClickHandle = function ($event) {
            var $textPicker = jQuery('#nbd-text-color-picker');
            var $bgPicker = jQuery('#nbd-bg-color-picker');
            var $canvasBgPicker = jQuery('#nbd-canvas-background-color-picker');
            var $strokePicker = jQuery('#nbd-stroke-color-picker');
            var $shadowTextPicker = jQuery('#nbd-text-shadow-color-picker');
            var $shadowPicker = jQuery('#nbd-shadow-color-picker');
            var $globalPicker = jQuery('#nbd-global-color-picker');
            var $stageBgPicker = jQuery('#nbd-stage-bg-color-picker');
            if (!jQuery($event.target).hasClass('color-palette-add') && $scope.showTextColorPicker
                && $textPicker.has($event.target).length == 0 && !$textPicker.is($event.target)) {
                $scope.showTextColorPicker = false;
            }
            ;
            /*advanced*/
            if (typeof udc_nbd_js_config != "undefined") {
                var $filterPicker = jQuery('#nbd-text-color-picker-customize'),
                    $filterPickerBlend = jQuery('#nbd-text-color-picker-customize-blend');
                if (!jQuery($event.target).hasClass('color-palette-add-customize') && $scope.showFilterColorPicker
                    && $filterPicker.has($event.target).length == 0 && !$filterPicker.is($event.target)) {
                    $scope.showFilterColorPicker = false;
                }
                if (!jQuery($event.target).hasClass('color-palette-add-customize-blend') && $scope.showFilterColorPickerBlend
                    && $filterPickerBlend.has($event.target).length == 0 && !$filterPickerBlend.is($event.target)) {
                    $scope.showFilterColorPickerBlend = false;
                }
            }
            ;
            if (!jQuery($event.target).hasClass('color-palette-add') && $scope.showBgColorPicker && $bgPicker.has($event.target).length == 0 && !$bgPicker.is($event.target)) {
                $scope.showBgColorPicker = false;
            }
            if (!jQuery($event.target).hasClass('color-palette-trigger') && $scope.showCanvasBackgroundColorPicker && $canvasBgPicker.has($event.target).length == 0 && !$canvasBgPicker.is($event.target)) {
                $scope.showCanvasBackgroundColorPicker = false;
            }
            if (!jQuery($event.target).hasClass('color-palette-trigger') && $scope.showBrushStrokeColorPicker && $strokePicker.has($event.target).length == 0 && !$strokePicker.is($event.target)) {
                $scope.showBrushStrokeColorPicker = false;
            }
            if (!jQuery($event.target).hasClass('color-palette-trigger') && $scope.showBrushShadowColorPicker && $shadowPicker.has($event.target).length == 0 && !$shadowPicker.is($event.target)) {
                $scope.showBrushShadowColorPicker = false;
            }
            if (!jQuery($event.target).hasClass('color-palette-trigger') && $scope.showBrushShadowTextColorPicker && $shadowTextPicker.has($event.target).length == 0 && !$shadowTextPicker.is($event.target)) {
                $scope.showBrushShadowTextColorPicker = false;
            }
            if (!jQuery($event.target).hasClass('color-palette-add') && $scope.stageBgColorPicker.status && $stageBgPicker.has($event.target).length == 0 && !$stageBgPicker.is($event.target)) {
                $scope.stageBgColorPicker.status = false;
            }
            if (!jQuery($event.target).hasClass('color-palette-add') && $scope.globalPicker.active && $globalPicker.has($event.target).length == 0 && !$globalPicker.is($event.target)) {
                $scope.globalPicker.active = false;
            }
            ;
        };
        /* Hotkeys */
        $scope.keypressHandle = function (e) {
            var targetEl = e.target.tagName.toUpperCase();
            if (targetEl == 'INPUT' || targetEl == 'TEXTAREA' || $scope.stages[$scope.currentStage].states.isEditing) {
                if (!(e.ctrlKey && (e.which == 66 || e.which == 73))) {
                    return;
                }
            }
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states;
            if (e.ctrlKey || e.metaKey) {
                //var keepDefault = [67, 116];
                var keepDefault = [116];

                if (_.includes(keepDefault, e.which)) return;
                e.preventDefault();
                if (e.shiftKey) {
                    switch (e.which) {
                        case 72:
                            /* Hold Ctrl + Shift + H Show/Hide Layer */
                            $scope.setLayerAttribute('visible');
                            $scope.updateApp();
                            break;
                        case 76:
                            /* Hold Ctrl + Shift + L Lock Layer */
                            $scope.setLayerAttribute('selectable');
                            $scope.updateApp();
                            break;
                        case 221:
                            /* Hold Ctrl + Shift + ] Bring layer to front */
                            $scope.setStackPosition('bring-front');
                            break;
                        case 219:
                            /* Hold Ctrl + Shift + [ Send layer to back */
                            $scope.setStackPosition('send-back');
                            break;
                        case 86:
                            /* Hold Ctrl + Shift + V → Align layer center vertical */
                            $scope.translateLayer('vertical');
                            break;
                        case 73:
                            /* Hold Ctrl + Shift + I → Import Design */
                            $scope.importDesign();
                            break;
                        case 69:
                            /* Hold Ctrl + Shift + E → Export Design */
                            $scope.exportDesign();
                            break;
                        case 83:
                            /* Hold Ctrl + Shift + S → Save Design for later*/
                            $scope.saveData('saveforlater');
                            break;
                        case 77:
                            /* Hold Ctrl + Shift + M → Convert layer to mask*/
                            $scope.createClippingMaskFromShape();
                            break;
                        case 76:
                            /* Hold Ctrl + Shift + L → clear all stages*/
                            $scope.clearAllStage();
                            break;
                        case 188:
                            /* Hold Ctrl + Shift + < → Decreate font size*/
                            if (_states.isText) {
                                _states.text.ptFontSize -= 1;
                                $scope.setTextAttribute('fontSize', _states.text.ptFontSize);
                            }
                            $scope.updateApp();
                            break;
                        case 190:
                            /* Hold Ctrl + Shift + > → Increate font size*/
                            if (_states.isText) {
                                _states.text.ptFontSize += 1;
                                $scope.setTextAttribute('fontSize', _states.text.ptFontSize);
                            }
                            $scope.updateApp();
                            break;
                        case 71:
                            /* Hold Ctrl + Shift + G → Ungroup */
                            if (_states.isNativeGroup) {
                                $scope.unGroupLayers();
                            }
                            $scope.updateApp();
                            break;
                    }
                } else {

                    switch (e.which) {
                        case 85:
                            /* Hold Ctrl and  U → turn text underline */
                            if (_states.isText) $scope.setTextAttribute('underline', true);
                            $scope.updateApp();
                            break;
                        case 65:
                            /* Hold Ctrl press A → select all layers */
                            $scope.selectAllLayers();
                            break;
                        case 83:
                            /* Hold Ctrl + S → Save Design for later*/
                            $scope.saveData('saveforlater');
                            break;
                        case 38:
                            /* Hold Ctrl + Uparrow → Go Page Up*/
                            $scope.switchStage('prev');
                            break;
                        case 66:
                            /* Hold Ctrl press B → set font weight bold */
                            if (_states.isText
                                && (_states.text.font.file.b
                                    && (_states.text.fontStyle != 'italic' || (_states.text.fontStyle == 'italic' && _states.text.font.file.bi)))) {
                                $scope.setTextAttribute('fontWeight', _states.text.fontWeight == 'bold' ? 'normal' : 'bold');
                            }
                            $scope.updateApp();
                            break;
                        case 80:
                            /* Hold Ctrl press P → duplicate layers */
                            $scope.copyLayers();
                            break;
                        case 67:
                            /* Hold Ctrl press C → duplicate layers */
                            // $scope.isExternalImageCopied=false;
                            // $scope.isElementCopied=true;
                            $scope.copyobjs();

                            $scope.writeOnClipboard(' ');

                            break;
                        case 88:
                            /* Hold Ctrl press X → duplicate layers */
                            $scope.cutobjs();
                            break;
                        case 73:
                            /* Hold Ctrl press I → set text style italic */
                            if (_states.isText
                                && (_states.text.font.file.i
                                    && (_states.text.fontWeight != 'bold' || (_states.text.fontWeight == 'bold' && _states.text.font.file.bi)))) {
                                $scope.setTextAttribute('fontStyle', _states.text.fontStyle == 'italic' ? 'normal' : 'italic');
                            }
                            $scope.updateApp();
                            break;
                        case 68:
                            /* Hold Ctrl press D → deactive all layers */
                            $scope.deactiveAllLayer();
                            break;
                        case 69:
                            /* Hold Ctrl press E → clear stage */
                            $scope.clearStage();
                            break;
                        case 90:
                            /* Hold Ctrl press Z → Undo */
                            if (_states.isUndoable) {
                                $scope.undo();
                            }
                            break;
                        case 89:
                            /* Hold Ctrl press Y → Undo */
                            if (_states.isRedoable) {
                                $scope.redo();
                            }
                            break;
                        case 71:
                            /* Hold Ctrl press G → Group Layers */
                            if (_states.isGroup) {
                                $scope.groupLayers();
                            }
                            $scope.updateApp();
                            break;
                        case 76:
                            /* Hold Ctrl press L → Toggle Bleed Line */
                            $scope.settings.bleedLine = !$scope.settings.bleedLine;
                            $scope.updateApp();
                            break;
                        case 82:
                            /* Hold Ctrl press R → Toggle Ruler */
                            $scope.toggleRuler();
                            $scope.updateApp();
                            break;
                        case 72:
                            /* Hold Ctrl press H → Align layer center horizontal */
                            $scope.translateLayer('horizontal');
                            break;
                        case 86:
                            /* Hold Ctrl press V → Align layer center vertical */

                            navigator.clipboard.readText()
                                .then(text => {
                                    if (text == ' ') {
                                        $scope.copyLayers($scope.clipboard);
                                    } else {
                                        $scope.pasteExternalImage();
                                    }
                                })
                                .catch(err => {
                                    // maybe user didn't grant access to read from clipboard
                                    console.log('Something went wrong in reading clipboard text', err);
                                });
                            break;
                        case 187:
                            /* Hold Ctrl press + → Zoom In stage */
                            if (_states.currentScaleIndex < _states.scaleRange.length - 1) {
                                $scope.zoomStage(_states.currentScaleIndex + 1);
                                $scope.updateApp();
                            }
                            break;
                        case 189:
                            /* Hold Ctrl press - → Zoom out stage */
                            if (_states.currentScaleIndex > 0) {
                                $scope.zoomStage(_states.currentScaleIndex - 1);
                                $scope.updateApp();
                            }
                            break;
                        case 48:
                        case 96:
                            /* Hold Ctrl press 0 → Resize stage to fit */
                            $scope.zoomStage(_states.fitScaleIndex);
                            $scope.updateApp();
                            break;
                        case 49:
                        case 97:
                            /* Hold Ctrl press 1 → Resize stage to origin size */
                            if (_states.fillScaleIndex == -1) {
                                $scope.zoomStage(_states.fitScaleIndex);
                            } else {
                                $scope.zoomStage(_states.fillScaleIndex);
                            }
                            ;
                            $scope.updateApp();
                            break;
                        case 221:
                            /* Hold Ctrl press ] Bring layer forward */
                            $scope.setStackPosition('bring-forward');
                            break;
                        case 219:
                            /* Hold Ctrl press [ Bring layer backward */
                            $scope.setStackPosition('send-backward');
                            break;
                        case 79:
                            /* Hold Ctrl press O → Load My Design */
                            $scope.loadMyDesign(null, false);
                            break;
                    }
                }
            } else if (e.altKey) {
                e.preventDefault();
                switch (e.which) {
                    case 65:
                        /* Selection → Hold Alt press A → Align Left */
                        if (_states.isGroup)
                            $scope.alignLayer('left', 'alt');
                        break;
                    case 68:
                        /* Selection → Hold Alt press D → Align Right */
                        if (_states.isGroup)
                            $scope.alignLayer('right', 'alt');
                        break;
                    case 87:
                        /* Selection → Hold Alt press W → Align Top */
                        if (_states.isGroup)
                            $scope.alignLayer('top', 'alt');
                        break;
                    case 83:
                        /* Selection → Hold Alt press S → Align Bottom */
                        if (_states.isGroup)
                            $scope.alignLayer('bottom', 'alt');
                        break;
                    case 72:
                        /* Selection → Hold Alt press H → Align Horizontal */
                        if (_states.isGroup)
                            $scope.alignLayer('horizontal', 'alt');
                        break;
                    case 86:
                        /* Selection → Hold Alt press V → Align Vertical */
                        if (_states.isGroup)
                            $scope.alignLayer('vertical', 'alt');
                        break;
                    case 37:
                        /* Hold Alt press left arrow */
                        $scope.moveLayer('left', 'alt');
                        break;
                    case 38:
                        /* Hold Alt press up arrow */
                        $scope.moveLayer('up', 'alt');
                        break;
                    case 39:
                        /* Hold Alt press right arrow */
                        $scope.moveLayer('right', 'alt');
                        break;
                    case 40:
                        /* Hold Alt press down arrow */
                        $scope.moveLayer('down', 'alt');
                        break;
                    case 85:
                        /* Hold Alt press U */
                        if (_states.isText) $scope.setTextAttribute('is_uppercase', true);
                        $scope.updateApp();
                        break;
                    case 76:
                        /* Hold Alt press U */
                        if (_states.isText) $scope.setTextAttribute('is_uppercase', false);
                        $scope.updateApp();
                        break;
                }
            } else if (e.shiftKey) {
                switch (e.which) {
                    case 72:
                        /* Hold Shift press H > Flip Horizontal */
                        $scope.rotateLayer('reflect-hoz');
                        break;
                    case 86:
                        /* Hold Shift press V > Flip Vertical */
                        $scope.rotateLayer('reflect-ver');
                        break;
                    case 107:
                        /* Hold Shift press + → zoom out layer */
                        $scope.scaleLayer('+');
                        break;
                    case 109:
                        /* Hold Shift press - → zoom in layer */
                        $scope.scaleLayer('-');
                        break;
                    case 71:
                        /* Hold Shift + G → Toggle Grid */
                        $scope.settings.showGrid = !$scope.settings.showGrid;
                        $scope.updateApp();
                        break;
                    case 76:
                        /* Hold Shift + L → clear all guidelines*/
                        $scope.clearGuides();
                        break;
                    case 68:
                        /* Hold Shift + D → Toggle Dimension */
                        $scope.settings.showDimensions = !$scope.settings.showDimensions;
                        $scope.updateApp();
                        break;
                }
            } else {
                switch (e.which) {
                    case 84:
                        /* Add text */
                        $scope.addText("Heading", "heading");
                        break;
                    case 82:
                        /* Add rectangle */
                        $scope.addGeometricalObject('rect');
                        break;
                    case 79:
                        /* Add Elipse  */
                        $scope.addGeometricalObject('ellipse');
                        break;
                    case 85:
                        /* Add Rounded Rectangle  */
                        $scope.addGeometricalObject('roundedrectangle');
                        break;
                    case 67:
                        /* Add circle */
                        $scope.addGeometricalObject('circle');
                        break;
                    case 76:
                        /* Add line */
                        $scope.addGeometricalObject('line');
                        break;
                    case 27:
                        /* Press Esc */
                        $scope.deactiveAllLayer();
                        break;
                    case 37:
                        /* Press left arrow */
                        if (_states.isActiveLayer)
                            $scope.moveLayer('left');
                        break;
                    case 38:
                        /* Press up arrow */
                        if (_states.isActiveLayer)
                            $scope.moveLayer('up');
                        break;
                    case 39:
                        /* Press right arrow */
                        if (_states.isActiveLayer)
                            $scope.moveLayer('right');
                        break;
                    case 40:
                        /* Press down arrow */
                        if (_states.isActiveLayer)
                            $scope.moveLayer('down');
                        break;
                    case 46:
                    case 8:
                        /* Press "delete" → delete layers */
                        $scope.deleteLayers();
                        break;
                    case 86:
                        /* Press "V" → disable draw mode */
                        if ($scope.resource.drawMode.status) jQuery('.item[data-type="draw"]').triggerHandler('click');
                        break;
                    case 66:
                        /* Press "B" → enable draw mode */
                        if (!$scope.resource.drawMode.status) jQuery('.item[data-type="draw"]').triggerHandler('click');
                        break;
                }
            }
        };
        $scope.onMouseWheelUp = function (e) {
            if (!e.metaKey && !e.ctrlKey) {
                return;
            }
            const _stage = $scope.stages[$scope.currentStage];
            const _states = _stage.states;
            if (_states.currentScaleIndex < _states.scaleRange.length - 1) {
                $scope.zoomStage(_states.currentScaleIndex + 1);
                $scope.updateApp();
            }
        };

        $scope.onMouseWheelDown = function (e) {
            if (!e.metaKey && !e.ctrlKey) {
                return;
            }
            const _stage = $scope.stages[$scope.currentStage];
            const _states = _stage.states;
            if (_states.currentScaleIndex > 0) {
                $scope.zoomStage(_states.currentScaleIndex - 1);
                $scope.updateApp();
            }
        };
        $scope.onClickStage = function ($event) {
            /*
         * Deactive all layer if click outer canvas
         * Hide context menu
         * Store stages
         */
            if (angular.element($event.target).hasClass('stage')) {
                $scope.deactiveAllLayer();
                /* store all stages */
                if ($scope.settings.nbdesigner_save_latest_design == 'yes') {
                    $scope.saveDesign();
                    var json = {config: {}};
                    json.config.viewport = $scope.viewPort;
                    json.fonts = $scope.resource.usedFonts;
                    json.design = $scope.resource.jsonDesign;
                    if (angular.isDefined(NBDESIGNCONFIG.design_id)) {
                        json.config.design_id = NBDESIGNCONFIG.design_id;
                    }
                    var pid = NBDESIGNCONFIG['product_id'] + '-' + NBDESIGNCONFIG['variation_id'];
                    $scope.localStore.update(pid, json, function () {
                        jQuery('.nbd-toasts__saved').nbToasts();
                    });
                }
            }
            $scope.ctxMenuStyle.visibility = 'hidden';
            $scope.updateApp();
        };
        $scope.$on('nbd:contextmenu', function (event, e) {
            $scope.contextMenu(e);
        });
        $scope.ctxMenuStyle = {
            'top': '17%',
            'left': '33%',
            'visibility': 'hidden'
        };
        $scope.contextMenu = function (e) {
            if ($scope.stages[$scope.currentStage].states.isEditing || $scope.stages[$scope.currentStage].states.isMask) return;
            e.preventDefault();
            var posX = e.pageX,
                posY = e.pageY;
            var contextEl = angular.element(document.getElementById('nbd-context-menu'))[0],
                height = contextEl.clientHeight,
                width = contextEl.clientWidth;
            if ($scope.workBenchWidth < (posX + width + 15)) posX = $scope.workBenchWidth - width - 15;
            if ($scope.workBenchHeight < (posY + height + 15)) posY = $scope.workBenchHeight - height - 15;
            $scope.ctxMenuStyle = {
                'visibility': 'visible',
                top: posY,
                left: posX
            }
            $scope.updateApp();
        };
        $scope.preventLoadDesign = false;
        $scope.globalPicker = {
            color: NBDESIGNCONFIG.nbdesigner_default_color,
            attr: 'text.stroke',
            active: false
        };
        /*advanced*/
        if (typeof udc_nbd_js_config != 'undefined') {
            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'text.textgradientone',
                active: false
            };
            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'text.textgradienttwo',
                active: false
            };
            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'svgobj.stroke',
                active: false
            };
            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'svg.shadow',
                active: false
            };

            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'bg.color',
                active: false
            };

            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'image.shadow',
                active: false
            };

            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'bggrdone.grdcolorone',
                active: false
            };

            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'bggrdtwo.grdcolortwo',
                active: false
            };

            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'txt.shadow',
                active: false
            };


            $scope.globalPicker = {
                color: NBDESIGNCONFIG.nbdesigner_default_color,
                attr: 'photoimg.stroke',
                active: false
            };

            $scope.bgsection = function () {
                jQuery('#nbd-global-color-palette').addClass('show');
                jQuery('#nbd-global-color-palette').attr('style', 'display: block !important');
                jQuery('.nbd-global-color-palette').css('left', '28%');
                jQuery('.nbd-global-color-palette').css('margin-top', '15px');
                // $scope.setCurrentBackgoundGradientColor();
                // $scope.getPhoto('Pixabay');
                // $scope.onClickTab('Pixabay', 'photo');
            };
            $scope.imageShadow = function () {
                jQuery('.nbd-global-color-palette').css('left', '52%');
            };
            $scope.pathStroke = function () {
                jQuery('.nbd-global-color-palette').css('left', '44%');
            };
            $scope.pathShadow = function () {
                jQuery('.nbd-global-color-palette').css('left', '41%');
            };
            $scope.textShadow = function () {
                jQuery('.nbd-global-color-palette').css('left', '71%');
            };
            $scope.textGradientcolorone = function () {
                jQuery('.nbd-global-color-palette').css('left', '48%');
            };
            $scope.textGradientcolortwo = function () {
                jQuery('.nbd-global-color-palette').css('left', '73%');
            };
        }
        $scope.selectGlobalPicker = function (color, hide = true) {
            $scope.globalPicker.color = color;
            var attr_arr = $scope.globalPicker.attr.split(".");
            /*advanced*/
            if (typeof udc_nbd_js_config != 'undefined') {
                $scope.shadowcolor = color;
                if (attr_arr.length == 2 && attr_arr[0] == 'text') {
                    $scope.applyTextPropertyToGroup(attr_arr[1], $scope.globalPicker.color);
                    //$scope.setShadowcolor($scope.shadowcolor);
                    //jQuery('#textshadowcolor').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'photoimg') {
                    $scope.changeObjectColor(attr_arr[1], $scope.globalPicker.color);
                    jQuery('#imgstrokecolor').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'svgobj') {
                    $scope.changeObjectColor(attr_arr[1], $scope.globalPicker.color);
                    jQuery('#svgstrokecolor').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'txt') {
                    $scope.setShadowcolor($scope.shadowcolor);
                    jQuery('#textshadowcolor').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'svg') {
                    $scope.setShadowcolor($scope.shadowcolor);
                    jQuery('#svgshadowcolor').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'svgobj') {
                    $scope.changeObjectColor(attr_arr[1], $scope.globalPicker.color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'bg') {
                    $scope.setCanvasBGcolor(attr_arr[1], $scope.globalPicker.color);
                    jQuery('#nbd-global-color-palette').addClass('show');
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'image') {
                    $scope.setShadowcolor($scope.shadowcolor);
                    jQuery('#imgshadowcolor').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'bggrdone') {
                    $scope.setCanvasGradientone($scope.globalPicker.color);
                    jQuery('#bggrdone').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'bggrdtwo') {
                    $scope.setCanvasGradienttwo($scope.globalPicker.color);
                    jQuery('#bggrdtwo').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'textgrdone') {
                    $scope.setTextGradientone($scope.globalPicker.color);
                    jQuery('#textgradientcolorone').css('background', color);
                }
                if (attr_arr.length == 2 && attr_arr[0] == 'textgrdtwo') {
                    $scope.setTextGradienttwo($scope.globalPicker.color);
                    jQuery('#textgradientcolortwo').css('background', color);
                }
            }
            if (attr_arr.length == 2 && attr_arr[0] == 'text') {
                $scope.applyTextPropertyToGroup(attr_arr[1], $scope.globalPicker.color);
                $timeout(function () {
                    jQuery('.menu-item.item-stroke').addClass('active');
                });
            } else if (attr_arr.length == 2 && attr_arr[0] == 'geoObject') {
                $scope.setGeometricalObjectAttr(attr_arr[1], color);
            } else if (attr_arr.length == 2 && attr_arr[0] == 'shadow') {
                $scope.stages[$scope.currentStage].states.shadow.color = $scope.globalPicker.color;
                $timeout(function () {
                    jQuery('.menu-item.item-shadow').addClass('active');
                });
            }
            if (hide) {
                jQuery('#nbd-global-color-palette').removeClass('show');
            }
        };
        $scope.$on('nbd:picker', function (event, attr, color) {
            $scope.globalPicker.attr = attr;
            $scope.globalPicker.color = color;
        });
        $scope.$on('canvas:created', function (event, id, last) {
            /* init canvas parameters */
            $scope.initStageSetting(id);
            var _canvas = $scope.stages[id].canvas;
            if (!checkMobileDevice()) {
                jQuery('#stage-container-' + id).perfectScrollbar();
                jQuery('#stage-container-' + id).on('drop', function (event) {
                    $scope.onDrop(event, id);
                });
            }
            ;
            /* Listen canvas events */
            _canvas.on('mouse:down', function (options) {
                /*advanced*/
                if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                    var e = options.target;
                    if (e != null) {
                        if (e.lengthLimit != "undefined") {
                            jQuery("#limit").val("");
                        }
                        if (e.lengthLimit) {
                            jQuery("#limit").val(e.lengthLimit);
                        }
                    }
                }
                $scope.onMouseDown(id, options);
            });
            /* nbdesigner advanced*/
            if (typeof mia_nbd_js_config_design != "undefined") {
                _canvas.on('dragover', function (options) {
                    if (angular.isDefined(options.target)) {
                        var canvas = $scope.stages[$scope.currentStage].canvas;
                        var obj = options.target;
                        canvas.setActiveObject(obj);
                        jQuery('.bounding-rect-upload-zone').each(function () {
                            var itemId = jQuery(this).attr("data-itemid");
                            var th = jQuery(this);
                            if (itemId == obj.itemId) {
                                th.css("visibility", "hidden");
                            }
                        });
                    }
                });
            }
            _canvas.on("mouse:over", function (options) {
                $scope.onMouseOverStage(id, options);
            });
            _canvas.on("mouse:out", function (options) {
                $scope.onMouseOutStage(id, options);
            });
            _canvas.on("mouse:move", function (options) {
                $scope.onMouseMoveStage(id, options);
            });
            _canvas.on("mouse:up", function (options) {
                /*advanced*/
                if (typeof mia_nbd_js_config_design != "undefined" && options.target != null) {
                    if (options.target.clickUpload) {
                        jQuery('div.nbd-dnd-file input[type="file"]').click();
                    }
                }
                $scope.onMouseUpStage(id, options);
            });
            _canvas.on("path:created", function (options) {
                $scope.onPathCreated(id, options);
            });
            _canvas.on("object:added", function (options) {
                $scope.onObjectAdded(id, options);
            });
            _canvas.on("object:removed", function (options) {
                $scope.onObjectRemoved(id, options);
            });
            _canvas.on("selection:created", function (options) {
                $scope.onSelectionCreated(id, options);
            });
            _canvas.on("object:scaling", function (options) {
                $scope.onObjectScaling(id, options);
            });
            _canvas.on("object:scaled", function (options) {
                $scope.onObjectScaled(id, options);
            });
            _canvas.on("object:moving", function (options) {
                if (typeof custom_richard != 'undefined') {
                    /*advanced*/
                    var obj = options.target;
                    // if object is too big ignore
                    if (obj.currentHeight < obj.canvas.height || obj.currentWidth < obj.canvas.width || obj.width * obj.scaleX < obj.canvas.width) {
                        obj.setCoords();
                        // top-left  corner
                        if (obj.getBoundingRect().top < 0 || obj.getBoundingRect().left < 0) {
                            obj.top = Math.max(obj.top, obj.top - obj.getBoundingRect().top);
                            obj.left = Math.max(obj.left, obj.left - obj.getBoundingRect().left);
                        }
                        // bot-right corner
                        if (obj.getBoundingRect().top + obj.getBoundingRect().height > obj.canvas.height || obj.getBoundingRect().left + obj.getBoundingRect().width > obj.canvas.width) {
                            obj.top = Math.min(obj.top, obj.canvas.height - obj.getBoundingRect().height + obj.top - obj.getBoundingRect().top);
                            obj.left = Math.min(obj.left, obj.canvas.width - obj.getBoundingRect().width + obj.left - obj.getBoundingRect().left);
                        }
                    }
                }
                /*advanced*/
                if (typeof mia_nbd_js_config_design != "undefined" && options.target.elementUpload) {
                    var timeoutTriggered = false;

                    function stopDragging(element) {
                        element.lockMovementX = true;
                        element.lockMovementY = true;
                    }

                    function onMoving(e) {
                        if (!timeoutTriggered) {
                            stopDragging(e.target);
                        }
                        timeoutTriggered = true;
                    }

                    if (options.target.clickUpload) {
                        onMoving(options);
                    }
                }
                $scope.onObjectMoving(id, options);
            });
            /*advanced*/
            if (typeof udc_nbd_js_config != 'undefined') {
                _canvas.on("object:selected", function (options) {
                    const object = options.target;
                    if (options.target && options.target.type == 'image') $scope.selectedcanvasObject = options.target;
                });
            }
            _canvas.on("object:moved", function (options) {
                $scope.onObjectMoved(id, options);
            });
            _canvas.on("object:rotating", function (options) {
                $scope.onObjectRotating(id, options);
            });
            _canvas.on("object:modified", function (options) {
                $scope.onObjectModified(id, options);
            });
            _canvas.on("before:render", function (options) {
                // Dubois Julien Custom for NBDesigner Advanced
                if (typeof nbd_customize_option_color != "undefined") {
                    if (angular.isDefined(nbd_window.nbOption)) {
                        var data = nbd_window.nbOption.odOption;
                        if (angular.isDefined(data.color) && angular.isUndefined(data.color)) {
                            fgColor = data.color.bg_foce_color;
                            $scope.changeFillAllLayers(fgColor);
                        }
                    }
                }
                $scope.onBeforeRender(id, options);
            });
            _canvas.on("after:render", function (options) {
                $scope.onAfterRender(id, options);
                // NBD template ai to svg
                if (typeof nbptemp_ai_to_svg != "undefined") {
                    var paramsString = window.location.href;
                    var searchParams = new URLSearchParams(paramsString);
                    if (searchParams.has("src")) {
                        var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                            activeObject = _canvas.getActiveObject();
                        if (angular.isDefined(_canvas)) {
                            if (angular.isDefined(activeObject) && activeObject != null) {
                                $scope.unGroupLayers();
                                $scope.saveData();
                            }
                        }
                    }
                }
            });
            _canvas.on("selection:cleared", function (options) {
                $scope.onSelectionCleared(id, options);
                /*advanced*/
                if (typeof udc_nbd_js_config != 'undefined') {
                    if ($scope.isCrop) $scope.cropImageArea();
                }
            });
            _canvas.on("text:editing:entered", function (options) {
                /*advanced*/
                if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                    var e = options.target;
                    if (e != null) {
                        var stage = $scope.stages[$scope.currentStage];
                        if ($scope.stages[$scope.currentStage].states.isText) {
                            if (typeof ttp_enqueue_custom_admin_js_check1 != 'undefined') {
                                jQuery(".toolbar-text").addClass('ng-hide');
                            }
                        }
                        if (e.lengthLimit != "undefined") {
                            e.hiddenTextarea.setAttribute("maxlength", e.lengthLimit);
                        }
                    }
                }
                $scope.onEditingEntered(id, options);
            });
            _canvas.on("text:editing:exited", function (options) {
                $scope.onEditingExited(id, options);
            });
            _canvas.on("text:changed", function (options) {
                $scope.onTextChanged(id, options);
            });
            _canvas.on("selection:updated", function (options) {
                console.log(options);
                $scope.onSelectionUpdated(id, options);
                /*advanced*/
                if (typeof udc_nbd_js_config != 'undefined') {
                    if ($scope.isCrop) $scope.cropImageArea();
                    if (options.target && options.target.type == 'image') $scope.selectedcanvasObject = options.target;
                }
            });
            _canvas.on("text:selection:changed", function (options) {
                $scope.onSelectionChanged(id, options);
            });
            _canvas.on("mouse:dblclick", function (options) {
                /*advanced*/
                if (typeof ttp_enqueue_custom_admin_js1 != "undefined" && NBDESIGNCONFIG.message != "") {
                    if (options.target.selectable === false && options.target) {
                        alert(NBDESIGNCONFIG.message);
                    }
                }
                $scope.onDblClick(options);
                /*advanced*/
                if (typeof udc_nbd_js_config != 'undefined') {
                    // $scope.cropInit(options);
                }
            });
            _canvas.on("drop", function (options) {
                $scope.onDropOnCanvas(options);
            });
            _canvas.on("dragenter", function (options) {
                $scope.onDragenterOnCanvas(options);
            });
            _canvas.on("dragleave", function (options) {
                $scope.onDragleaveOnCanvas(options);
            });
            /* Load template after render canvas */
            if (last == '1') {
                appConfig.ready = true;
                if ($scope.preventLoadDesign) {
                    $scope.preventLoadDesign = false;
                    return;
                }
                $scope.loadTemplateAfterRenderCanvas();
            }
            if ($scope.duplicateStageIndex == id) {
                $scope.duplicateStageIndex = -1;
                $scope.contextAddLayers = 'template';
                $scope.onloadTemplate = true;
                $scope.stages[id].canvas.loadFromJSON($scope.resource.jsonDesign[id], function () {
                    $scope.onloadTemplate = false;
                    $scope.contextAddLayers = 'normal';
                });
            }
        });
        /*advanced*/
        if (typeof udc_nbd_js_config != 'undefined') {
            $scope.rotateSelection = function (picture, angle) {

                var _canvas = this.stages[$scope.currentStage].canvas;
                _canvas.discardActiveObject();
                var sel = new fabric.ActiveSelection([picture, picture.picArea], {
                    canvas: _canvas,
                });
                _canvas.setActiveObject(sel);
                sel.rotate(angle);
                _canvas.requestRenderAll();

                //unselect
                _canvas.discardActiveObject();
                _canvas.requestRenderAll();
            };

            $scope.cropInit = function (options) {
                var _canvas = this.stages[$scope.currentStage].canvas;
                var picture = options ? options.target : _canvas.getActiveObject();
                if (picture && picture.type === 'image' && !picture.picArea) {

                    picture.oldOriginX = picture.originX;
                    picture.oldOriginY = picture.originY;

                    picture.originX = 'left';
                    picture.originY = 'top';

                    if (picture.oldOriginX == 'center') {

                        picture.originX = 'left';
                        picture.originY = 'top';
                        picture.setCoords();

                        var oldAngle = picture.angle;
                        if (oldAngle) {
                            picture.angle = 0;
                            picture.left -= (picture.width * picture.scaleX) / 2;
                            picture.top -= (picture.height * picture.scaleY) / 2;
                            picture.rotate(oldAngle);
                            picture.setCoords();
                        } else {
                            picture.left -= (picture.width * picture.scaleX) / 2;
                            picture.top -= (picture.height * picture.scaleY) / 2;
                            picture.setCoords();
                        }
                    }

                    $scope.addPictureArea(picture);
                    picture.oldOpacity = picture.opacity;
                    picture.opacity = 0.7;
                    picture.hasRotatingPoint = false;
                    if (picture.cropX || picture.cropY) {
                        var oldAngle = picture.angle;
                        var oldLeft = picture.picArea.left;
                        var oldTop = picture.picArea.top;

                        $scope.rotateSelection(picture, 360 - oldAngle);

                        if (picture.cropX)
                            picture.left = picture.picArea.left - picture.cropX * picture.scaleX;
                        if (picture.cropY)
                            picture.top = picture.picArea.top - picture.cropY * picture.scaleY;

                        picture.scaleX = picture.oldScaleX;
                        picture.scaleY = picture.oldScaleY;
                        picture.width = picture.oldWidth;
                        picture.height = picture.oldHeight;

                        picture.cropX = 0;
                        picture.cropY = 0;

                        $scope.rotateSelection(picture, oldAngle);

                        picture.left -= picture.picArea.left - oldLeft;
                        picture.top -= picture.picArea.top - oldTop;
                        picture.setCoords();

                        picture.picArea.left = oldLeft;
                        picture.picArea.top = oldTop;
                        picture.picArea.setCoords();
                    } else {

                        if (!picture.oldWidth) picture.oldWidth = picture.width;
                        if (!picture.oldHeight) picture.oldHeight = picture.height;
                        if (!picture.oldScaleX) picture.oldScaleX = picture.scaleX;
                        if (!picture.oldScaleY) picture.oldScaleY = picture.scaleY;

                        if (picture.width < picture.oldWidth)
                            picture.width = picture.oldWidth;
                        if (picture.height < picture.oldHeight)
                            picture.height = picture.oldHeight;
                        picture.setCoords();
                    }
                    _canvas.setActiveObject(picture);
                    _canvas.renderAll();
                    $scope.isCrop = true;
                }
            };


            $scope.GetCanvasAtResoution = function () {
                var canvas = this.stages[$scope.currentStage].canvas;
                var newWidth = jQuery('#resize-width').val();
                if (canvas.width != newWidth) {
                    var scaleMultiplier = newWidth / canvas.width;
                    var objects = canvas.getObjects();
                    for (var i in objects) {
                        objects[i].scaleX = objects[i].scaleX * scaleMultiplier;
                        objects[i].scaleY = objects[i].scaleY * scaleMultiplier;
                        objects[i].left = objects[i].left * scaleMultiplier;
                        objects[i].top = objects[i].top * scaleMultiplier;
                        objects[i].setCoords();
                    }
                    var obj = canvas.backgroundImage;
                    if (obj) {
                        obj.scaleX = obj.scaleX * scaleMultiplier;
                        obj.scaleY = obj.scaleY * scaleMultiplier;
                    }

                    canvas.discardActiveObject();
                    canvas.setWidth(canvas.getWidth() * scaleMultiplier);
                    canvas.setHeight(canvas.getHeight() * scaleMultiplier);
                    canvas.renderAll();
                    canvas.calcOffset();
                }
            };

            $scope.resizeCanavsResoution = function () {
                /*var canvas = this.stages[$scope.currentStage].canvas;
            var wh = event.target.value.split("x");
            if(wh == "") return false;
            var ctype = wh[2];
            if (ctype == "pi") {
                 var newWidth = wh[0];
                 var newHeight = wh[1];
            }
            if (ctype == "inches") {
                newWidth = wh[0] * 96;
                newHeight = wh[1] * 96;
            }
            if (canvas.width != newWidth  && canvas.height != newHeight) {
                var scaleMultiplier = newWidth / canvas.width;
                var scaleMultiplier = newHeight / canvas.height;
                var objects = canvas.getObjects();
                for (var i in objects) {
                    objects[i].scaleX = objects[i].scaleX * scaleMultiplier;
                    objects[i].scaleY = objects[i].scaleY * scaleMultiplier;
                    objects[i].left = objects[i].left * scaleMultiplier;
                    objects[i].top = objects[i].top * scaleMultiplier;
                    objects[i].setCoords();
                }
                var obj = canvas.backgroundImage;
                if(obj){
                    obj.scaleX = obj.scaleX * scaleMultiplier;
                    obj.scaleY = obj.scaleY * scaleMultiplier;
                }

                canvas.discardActiveObject();
                canvas.setWidth(canvas.getWidth() * scaleMultiplier);
                canvas.setHeight(canvas.getHeight() * scaleMultiplier);
                canvas.renderAll();
                canvas.calcOffset();
            }*/
                var canvas = this.stages[$scope.currentStage].canvas;
                var wh = event.target.value.split("x");
                if (wh == "") return false;
                var newWidth = parseInt(wh[0]);
                var newHeight = parseInt(wh[1]);
                var ctype = wh[2];
                if (ctype == "inches") {
                    newWidth = wh[0] * 96;
                    newHeight = wh[1] * 96;
                }
                if (canvas.width != newWidth || canvas.height != newHeight) {
                    var scaleMultiplier = newWidth / canvas.width;
                    canvas.discardActiveObject();
                    canvas.setWidth(canvas.getWidth() * scaleMultiplier);
                    canvas.setHeight(canvas.getHeight() * scaleMultiplier);
                    canvas.renderAll();
                    canvas.calcOffset();
                }
            };

            $scope.addTextMask = function (url) {
                var _canvas = this.stages[$scope.currentStage].canvas;
                var text = _canvas.getActiveObject();
                if (text.type == 'textbox' || text.type == 'i-text') {
                    fabric.util.loadImage(url, function (img) {
                        text.set('fill', new fabric.Pattern({
                            source: img,
                            repeat: 'repeat'
                        }));
                        _canvas.renderAll();
                    });
                }
            };


            $scope.addPictureArea = function (picture) {
                $scope.diffuseAnimation = true;
                var _canvas = this.stages[$scope.currentStage].canvas;
                var picArea = new fabric.Rect({
                    fill: 'black',
                    originX: picture.originX,
                    originY: picture.originY,
                    width: picture.width * picture.scaleX,
                    height: picture.height * picture.scaleY,
                    left: picture.left,
                    top: picture.top,
                    angle: picture.angle,
                    selectable: false,
                    excludeFromExport: true,
                });
                _canvas.add(picArea);
                ;
                picArea.left = picture.left;
                picArea.top = picture.top;
                picArea.setCoords();

                var picIndex = _canvas.getObjects().indexOf(picture);
                if (!picIndex) {
                    picArea.moveTo(0);
                    picture.moveTo(1);
                } else
                    picArea.moveTo(picIndex);

                picture.picArea = picArea;
                _canvas.renderAll();
                $scope.diffuseAnimation = false;
            };

            $scope.cropImageArea = function () {
                var _canvas = this.stages[$scope.currentStage].canvas;
                $scope.isCrop = false;
                if ($scope.selectedcanvasObject && $scope.selectedcanvasObject.type === 'image' && $scope.selectedcanvasObject.picArea) {
                    if (($scope.selectedcanvasObject.width * $scope.selectedcanvasObject.scaleX < $scope.selectedcanvasObject.picArea.width * $scope.selectedcanvasObject.picArea.scaleX) ||
                        ($scope.selectedcanvasObject.height * $scope.selectedcanvasObject.scaleY < $scope.selectedcanvasObject.picArea.height * $scope.selectedcanvasObject.picArea.scaleY)) {
                    } else {
                        //functionality to crop
                        $scope.selectedcanvasObject.oldScaleX = $scope.selectedcanvasObject.scaleX;
                        $scope.selectedcanvasObject.oldScaleY = $scope.selectedcanvasObject.scaleY;

                        var oldAngle = $scope.selectedcanvasObject.picArea.angle;
                        var oldLeft = $scope.selectedcanvasObject.picArea.left;
                        var oldTop = $scope.selectedcanvasObject.picArea.top;

                        $scope.rotateSelection($scope.selectedcanvasObject, 360 - oldAngle);

                        //crop
                        $scope.selectedcanvasObject.cropX = ($scope.selectedcanvasObject.picArea.left - $scope.selectedcanvasObject.left) / $scope.selectedcanvasObject.scaleX;
                        $scope.selectedcanvasObject.cropY = ($scope.selectedcanvasObject.picArea.top - $scope.selectedcanvasObject.top) / $scope.selectedcanvasObject.scaleY;
                        $scope.selectedcanvasObject.width = $scope.selectedcanvasObject.picArea.width / $scope.selectedcanvasObject.scaleX;
                        $scope.selectedcanvasObject.height = $scope.selectedcanvasObject.picArea.height / $scope.selectedcanvasObject.scaleY;

                        $scope.selectedcanvasObject.left = $scope.selectedcanvasObject.picArea.left;
                        $scope.selectedcanvasObject.top = $scope.selectedcanvasObject.picArea.top;

                        $scope.rotateSelection($scope.selectedcanvasObject, oldAngle);

                        $scope.selectedcanvasObject.left = oldLeft;
                        $scope.selectedcanvasObject.top = oldTop;

                        _canvas.renderAll();
                    }
                    $scope.selectedcanvasObject.setCoords();
                    _canvas.remove($scope.selectedcanvasObject.picArea);
                    $scope.selectedcanvasObject.opacity = $scope.selectedcanvasObject.oldOpacity;
                    $scope.selectedcanvasObject.selectable = true;
                    $scope.selectedcanvasObject.hasRotatingPoint = true;
                    $scope.selectedcanvasObject.picArea = null;
                    _canvas.discardActiveObject();
                }
            };
        }
        $scope.loadTemplateAfterRenderCanvas = function () {
            $scope.initStagesCanvas();
            if ($scope.forceInitStage) {
                $scope.initStagesSettingWithoutTemplate();
                $scope.forceInitStage = false;
                return;
            }
            if (!$scope.isTemplateMode || ($scope.isTemplateMode && $scope.settings.task == 'edit')) {
                $timeout(function () {
                    function loadTemplate() {
                        if ($scope.the_first_time_load_page && angular.isDefined($scope.settings.product_data.lazy_load_design_folder) && $scope.settings.product_data.lazy_load_design_folder != '') {
                            $scope.insertTemplate(false, {id: $scope.settings.product_data.lazy_load_design_folder});
                            $scope.the_first_time_load_page = false;
                            delete ($scope.settings.product_data.lazy_load_design_folder);
                        } else if (angular.isDefined($scope.settings.product_data.design)) {
                            var config = ($scope.the_first_time_load_page && angular.isDefined($scope.settings.product_data.config_ref)) ? $scope.settings.product_data.config_ref : $scope.settings.product_data.config;
                            var viewport = config.viewport;
                            $scope.the_first_time_load_page = false;
                            if (angular.isUndefined(config.viewport) && angular.isDefined(config.scale)) {
                                viewport = {width: config.scale * 500, height: config.scale * 500};
                            }
                            $scope.insertTemplate(true, {
                                fonts: $scope.settings.product_data.fonts,
                                design: $scope.settings.product_data.design,
                                viewport: viewport
                            });
                            if (angular.isDefined($scope.settings.product_data.design_id)) {
                                NBDESIGNCONFIG.design_id = $scope.settings.product_data.design_id;
                            }
                        } else {
                            if (NBDESIGNCONFIG.product_data.option.admindesign == "1" && $scope.resource.templates.length == 0 && NBDESIGNCONFIG.product_data.option.global_template == "1" &&
                                NBDESIGNCONFIG.product_data.option.global_template_cat != "" && $scope.settings.nbdesigner_disable_auto_load_template == 'no') {
                                var interval = setInterval(function () {
                                    if ($scope.globalTemplateLoaded) {
                                        if ($scope.resource.globalTemplate.data.length > 0) {
                                            $scope.insertGlobalTemplate($scope.resource.globalTemplate.data[0].id);
                                        } else {
                                            $scope.initStagesSettingWithoutTemplate();
                                        }
                                        ;
                                        clearInterval(interval);
                                    }
                                }, 100);
                            } else {
                                $scope.initStagesSettingWithoutTemplate();
                            }
                        }
                    }

                    function loadLocalDesign() {
                        var pid = NBDESIGNCONFIG['product_id'] + '-' + NBDESIGNCONFIG['variation_id'];
                        if ($scope.settings.nbdesigner_save_latest_design == 'yes') {
                            if ($scope.localStore.ready) {
                                $scope.localStore.get(pid, function (data) {
                                    if (data) {
                                        $scope.insertTemplate(true, {
                                            fonts: data.data.fonts,
                                            design: data.data.design,
                                            viewport: data.data.config.viewport
                                        });
                                        if (angular.isDefined(data.data.config.design_id)) {
                                            NBDESIGNCONFIG.design_id = data.data.config.design_id;
                                        }
                                    } else {
                                        loadTemplate();
                                    }
                                });
                            } else {
                                loadTemplate();
                            }
                        } else {
                            loadTemplate();
                        }
                    }

                    if ($scope.preventChangeCurrentDesign) {
                        loadTemplate();
                        return;
                    }
                    if (angular.isDefined($scope.settings.product_data.is_reference)) {
                        delete $scope.settings.product_data.is_reference;
                        loadTemplate();
                        return;
                    }
                    ;
                    if (angular.isDefined($scope.settings.product_data.is_template) || $scope.settings.task == 'create_template') {
                        loadLocalDesign();
                    } else {
                        loadTemplate();
                    }
                });
            } else {
                $scope.initStagesSettingWithoutTemplate();
            }
        };
        $scope.initStagesCanvas = function () {
            _.each($scope.stages, function (stage, index) {
                var _canvas = stage.canvas;
                if (angular.isDefined($scope.settings.nbes_enable_settings)) {
                    var forceBg = false, color = '';
                    if ($scope.settings.nbes_enable_settings.combination == 1) {
                        if (angular.isDefined($scope.settings.nbes_settings.combination_colors) && angular.isDefined($scope.settings.nbes_settings.combination_colors.bg_codes) && $scope.settings.nbes_settings.combination_colors.bg_codes.length > 0) {
                            forceBg = true;
                            color = $scope.settings.nbes_settings.combination_colors.bg_codes[$scope.currentCombinationColor];
                            $scope.settings.hideColorPalette = true;
                        }
                    } else if ($scope.settings.nbes_enable_settings.background == 1) {
                        if (angular.isDefined($scope.settings.nbes_settings.background_colors) && angular.isDefined($scope.settings.nbes_settings.background_colors.codes) && $scope.settings.nbes_settings.background_colors.codes.length > 0) {
                            forceBg = true;
                            color = $scope.settings.nbes_settings.background_colors.codes[$scope.currentBackgroundColor];
                        }
                    }
                    if (forceBg) {
                        _canvas.setBackgroundColor(color);
                    }
                }
                if (stage.config.area_design_type == "2") {
                    $scope.contextAddLayers = 'template';
                    var width = _canvas.width,
                        height = _canvas.height,
                        path = new fabric.Path("M0 0 H" + width + " V" + height + " H0z M " + width / 2 + " 0 A " + width / 2 + " " + height / 2 + ", 0, 1, 0, " + width / 2 + " " + height + " A " + width / 2 + " " + height / 2 + ", 0, 1, 0, " + width / 2 + " 0z");
                    path.set({strokeWidth: 0, isAlwaysOnTop: true, fill: '#ffffff', selectable: false, evented: false});
                    _canvas.add(path);
                }
            });
        };
        $scope.theFirstCalcViewport = true;
        $scope.viewPort = {};
        $scope.calcViewport = function () {
            var _offsetWidth = checkMobileDevice() ? 20 : 100,
                _offsetHeight = checkMobileDevice() ? 70 : 100,
                _width = jQuery('.nbd-stages').width() - _offsetWidth,
                _height = jQuery('.nbd-stages').height() - _offsetHeight;

            if (navigator.userAgent.indexOf("Safari") != -1 && navigator.userAgent.indexOf("CriOS") == -1) {
                _offsetHeight = checkMobileDevice() ? 60 : 100;
                var ratio = window.devicePixelRatio || 1;
                // NBDesigner Advanced zoom design
                if (typeof checkZoom != 'undefined') {
                    ratio = ratio * 1.25;
                }
                if (checkMobileDevice()) {
                    var screen = {
                        width: window.screen.width * ratio,
                        height: window.screen.height * ratio
                    };
                    if ((screen.width == 1125 && screen.height === 2436) || (screen.width == 1242 && screen.height === 2688) || (screen.width == 828 && screen.height === 1792)) {
                        _offsetHeight = 180;
                    }
                }
            }
            ;

            if (navigator.userAgent.indexOf("CriOS") != -1) {
                var ratio = window.devicePixelRatio || 1;
                // NBDesigner Advanced zoom design
                if (typeof checkZoom != 'undefined') {
                    ratio = ratio * 1.25;
                }
                if (checkMobileDevice()) {
                    var screen = {
                        width: window.screen.width * ratio,
                        height: window.screen.height * ratio
                    };
                    if ((screen.width == 1125 && screen.height === 2436) || (screen.width == 1242 && screen.height === 2688) || (screen.width == 828 && screen.height === 1792)) {
                        _offsetHeight = 180;
                    }
                }
            }

            _height = jQuery('.nbd-stages').height() - _offsetHeight;
            if ($scope.theFirstCalcViewport) {
                $scope.viewPort = {width: _width, height: _height};
            }
            $scope.theFirstCalcViewport = false;
            return {width: _width, height: _height};
        };
        $scope.reCalcViewPort = function () {

        };
        $scope.calcStyle = function (value) {
            return value + 'px';
        };
        $scope.getDPI = function () {
            var div = document.createElement("div");
            div.style.height = "1in";
            div.style.width = "1in";
            div.style.top = "-200%";
            div.style.left = "-200%";
            div.style.position = "absolute";
            div.style.visibility = "hidden";
            div.style.opacity = "0";
            document.body.appendChild(div);
            var dpi = div.offsetHeight;
            document.body.removeChild(div);
            return dpi;
        };
        $scope.processProductSettings = function (overridePagesUnits = false) {
            $scope.stages = [];
            _.each($scope.settings.product_data.product, function (side, index) {
                var unitRatio = 1;
                const dimensionsUnit = overridePagesUnits ? $scope.settings.nbdesigner_dimensions_unit : (side.unit || $scope.settings.nbdesigner_dimensions_unit);
                const dpi = overridePagesUnits ? $scope.settings.product_data.option.dpi : (side.dpi || $scope.settings.product_data.option.dpi);
                switch (dimensionsUnit) {
                    case 'in':
                        unitRatio = 2.54;
                        break;
                    case 'mm':
                        unitRatio = 0.1;
                        break;
                    case 'ft':
                        unitRatio = 30.48;
                        break;
                    case 'px':
                        unitRatio = 2.54 / parseFloat(dpi);
                        break;
                    default:
                        unitRatio = 1;
                        break;
                }
                const rateConvert2Px = $scope.rateConvertCm2Px96dpi * unitRatio * parseFloat(dpi) / 96;
                var viewPort = $scope.calcViewport();
                var scaleRange = [0.1, 0.25, 0.3, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, 4, 5],
                    maxSize = checkMobileDevice() ? 1000 : 10000;
                var _width = side.product_width * rateConvert2Px,
                    _height = side.product_height * rateConvert2Px,
                    designViewPort = $scope.fitRectangle(viewPort.width, viewPort.height, _width, _height, true),
                    fillScale = _width / designViewPort.width,
                    minScale = 200 / Math.max(designViewPort.width, designViewPort.height),
                    maxScale = maxSize / Math.max(designViewPort.width, designViewPort.height),
                    screenViewPort = $scope.fitRectangle(screen.width, screen.height, _width, _height, true),
                    fullScreenScale = screenViewPort.width / designViewPort.width;
                var _scaleRange = scaleRange.filter(function (item) {
                    return item >= minScale && item <= maxScale;
                });
                $scope.stages[index] = {
                    config: {
                        _height: _height,
                        _width: _width,
                        area_design_type: side.area_design_type,
                        bgColor: side.bg_color_value,
                        bgImage: side.img_src,
                        bgType: side.bg_type,
                        bleed_lr: designViewPort.width * side.bleed_left_right / side.product_width,
                        bleed_tb: designViewPort.width * side.bleed_top_bottom / side.product_width,
                        cheight: designViewPort.height,
                        cwidth: designViewPort.width,
                        dpi: dpi,
                        height: designViewPort.width * side.real_height / side.product_width,
                        img_overlay: side.img_overlay,
                        left: designViewPort.width * side.real_left / side.product_width,
                        margin_lr: designViewPort.width * side.margin_left_right / side.product_width,
                        margin_tb: designViewPort.width * side.margin_top_bottom / side.product_width,
                        name: side.orientation_name,
                        pHeight: side.product_height,
                        pWidth: side.product_width,
                        show_overlay: side.show_overlay,
                        showBleed: side.show_bleed,
                        showOverlay: side.show_overlay,
                        showSafeZone: side.show_safe_zone,
                        top: designViewPort.width * side.real_top / side.product_width,
                        unit: dimensionsUnit,
                        width: designViewPort.width * side.real_width / side.product_width,
                    },
                    states: {},
                    undos: [],
                    redos: [],
                    layers: [],
                    canvas: {},
                    rulers: [],
                    rulerLines: {vers: [], hors: []}
                };
                if (typeof nbod_addon_side_thumbnail != "undefined") {
                    //nbdesigner advanced
                    $scope.stages[index].config.showThumbnail = side.show_thumbnail;
                    $scope.stages[index].config.show_thumbnail = side.show_thumbnail;
                    $scope.stages[index].config.img_thumbnail = side.img_thumbnail;
                    $scope.stages[index].stage_thumbnail = [];
                }
                /*advanced*/
                if (typeof kvlc_js_cusom != "undefined") {
                    $scope.stages[index].config.showThumbnail = side.show_thumbnail;
                    $scope.stages[index].config.show_thumbnail = side.show_thumbnail;
                    $scope.stages[index].config.img_overlay = side.img_overlay;
                    $scope.stages[index].config.img_thumbnail = side.img_thumbnail;
                }
                if (typeof custom_richard != 'undefined') {
                    /*advanced*/
                    $scope.stages[index].config.ratioViewPort = designViewPort.width / _width;
                }
                if (angular.isDefined(side.bleed_radius) && side.bleed_radius != 0) {
                    $scope.stages[index].config.bleed_radius = designViewPort.width * side.bleed_radius / side.product_width;
                    $scope.stages[index].config.safezone_radius = designViewPort.width * side.safezone_radius / side.product_width;
                }
                var _state = $scope.stages[index].states;
                angular.copy($scope.defaultStageStates, _state);
                var factor = 6.4516;
                switch (dimensionsUnit) {
                    case 'in':
                        factor = 1;
                        break;
                    case 'mm':
                        factor = 645.16;
                        break;
                    case 'ft':
                        factor = 1 / 144;
                        break;
                    case 'px':
                        factor = parseFloat(dpi) * parseFloat(dpi);
                        break;
                    default:
                        factor = 6.4516;
                        break;
                }
                _state.ratioConvertFont = designViewPort.width / (side.product_width / unitRatio * 2.54 * 72) * factor;
                _scaleRange.forEach(function (value) {
                    value != 1 && _state.scaleRange.push({
                        ratio: value,
                        value: (value * 100).toFixed() + '%',
                        label: (value * 100).toFixed() + '%'
                    });
                });
                _state.scaleRange.push({ratio: 1, value: '100%', label: 'Fit'});
                _state.scaleRange.push({
                    ratio: fullScreenScale,
                    value: (fullScreenScale * 100).toFixed() + '%',
                    label: (fullScreenScale * 100).toFixed() + '%'
                });
                if (fillScale >= minScale && fillScale <= maxScale) _state.scaleRange.push({
                    ratio: fillScale,
                    value: (fillScale * 100).toFixed() + '%',
                    label: 'Fill'
                });

                var printFactor = 2.54;
                switch (dimensionsUnit) {
                    case 'in':
                        printFactor = 1;
                        break;
                    case 'mm':
                        printFactor = 25.4;
                        break;
                    case 'ft':
                        printFactor = 1 / 12;
                        break;
                    case 'px':
                        printFactor = parseFloat(dpi);
                        break;
                    default:
                        printFactor = 2.54;
                        break;
                }

                var scopeDpi = $scope.getDPI(),
                    printSizeWidth = side.product_width / printFactor * scopeDpi,
                    printSizeHeight = side.product_height / printFactor * scopeDpi;

                var printScale = 0;
                if (printSizeWidth < maxSize && printSizeHeight < maxSize && printSizeWidth > minScale && printSizeHeight > minScale) {
                    printScale = printSizeWidth / designViewPort.width;
                    _state.scaleRange.push({
                        ratio: printScale,
                        value: (printScale * 100).toFixed() + '%',
                        label: 'Print Size'
                    });
                }
                _state.scaleRange = _.sortBy(_state.scaleRange, [function (o) {
                    return o.ratio;
                }]);
                _state.currentScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                    return o.ratio == 1;
                });
                _state.fitScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                    return o.ratio == 1;
                });
                _state.fillScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                    return o.ratio == fillScale;
                });
                _state.fullScreenScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                    return o.ratio == fullScreenScale;
                });
                _state.printScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                    return o.ratio == printScale;
                });

                $timeout(function () {
                    if (angular.isDefined($scope.areaDesignShapes[index]) && $scope.areaDesignShapes[index]) {
                        $scope.changeAreaDesignShape(index, $scope.areaDesignShapes[index]);
                    }
                });
            });
            if ($scope.settings.task == 'typography' || $scope.settings.task == 'create_template') {
                $scope.stages = [{
                    config: {},
                    states: {
                        scaleRange: [{ratio: 1, value: '100%', label: 'Fit'}, {
                            ratio: 2,
                            value: '200%',
                            label: '200%'
                        }, {ratio: 3, value: '300%', label: '300%'}],
                        currentScaleIndex: 0,
                        fitScaleIndex: 0,
                        fillScaleIndex: 0
                    },
                    undos: [],
                    redos: [],
                    layers: [],
                    canvas: {}
                }
                ];
                $scope.stages[0].states.ratioConvertFont = 1;
                if ($scope.settings.task == 'create_template')
                    $scope.stages[0].states.scaleRange = [{ratio: 1, value: '100%', label: 'Fit'}, {
                        ratio: 2,
                        value: '200%',
                        label: '200%'
                    }, {ratio: 3, value: '300%', label: '300%'}, {ratio: 4, value: '400%', label: '400%'}, {
                        ratio: 5,
                        value: '500%',
                        label: '500%'
                    }]
                angular.copy($scope.defaultConfig, $scope.stages[0].config);
                angular.merge($scope.stages[0].states, $scope.defaultStageStates);
            }
            ;
            ($scope.settings.showRuler && appConfig.isModern) && $scope.initRuler();
        };
        $scope.reprocessProductSettings = function () {
            side = $scope.settings.product_data.product[$scope.currentStage];
            var unitRatio = 1;
            const dimensionUnit = side.unit || $scope.settings.nbdesigner_dimensions_unit;
            switch (dimensionUnit) {
                case 'in':
                    unitRatio = 2.54;
                    break;
                case 'mm':
                    unitRatio = 0.1;
                    break;
                case 'ft':
                    unitRatio = 30.48;
                    break;
                case 'px':
                    unitRatio = 2.54 / parseFloat(side.dpi || $scope.settings.product_data.option.dpi);
                    break;
                default:
                    unitRatio = 1;
                    break;
            }
            const rateConvert2Px = $scope.rateConvertCm2Px96dpi * unitRatio * parseFloat(side.dpi || $scope.settings.product_data.option.dpi) / 96;
            var viewPort = $scope.calcViewport();
            var scaleRange = [0.1, 0.25, 0.3, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, 4, 5],
                maxSize = checkMobileDevice() ? 1000 : 10000;
            var _width = side.product_width * rateConvert2Px,
                _height = side.product_height * rateConvert2Px,
                designViewPort = $scope.fitRectangle(viewPort.width, viewPort.height, _width, _height, true);
            fillScale = _width / designViewPort.width,
                minScale = 200 / Math.max(designViewPort.width, designViewPort.height),
                maxScale = maxSize / Math.max(designViewPort.width, designViewPort.height),
                screenViewPort = $scope.fitRectangle(screen.width, screen.height, _width, _height, true),
                fullScreenScale = screenViewPort.width / designViewPort.width;
            var _scaleRange = scaleRange.filter(function (item) {
                return item >= minScale && item <= maxScale;
            });
            $scope.stages[$scope.currentStage] = {
                config: {
                    _height: _height,
                    _width: _width,
                    area_design_type: side.area_design_type,
                    bgColor: side.bg_color_value,
                    bgImage: side.img_src,
                    bgType: side.bg_type,
                    bleed_lr: designViewPort.width * side.bleed_left_right / side.product_width,
                    bleed_tb: designViewPort.width * side.bleed_top_bottom / side.product_width,
                    cheight: designViewPort.height,
                    cwidth: designViewPort.width,
                    dpi: side.dpi,
                    height: designViewPort.width * side.real_height / side.product_width,
                    img_overlay: side.img_overlay,
                    left: designViewPort.width * side.real_left / side.product_width,
                    margin_lr: designViewPort.width * side.margin_left_right / side.product_width,
                    margin_tb: designViewPort.width * side.margin_top_bottom / side.product_width,
                    name: side.orientation_name,
                    pHeight: side.product_height,
                    pWidth: side.product_width,
                    show_overlay: side.show_overlay,
                    showBleed: side.show_bleed,
                    showOverlay: side.show_overlay,
                    showSafeZone: side.show_safe_zone,
                    top: designViewPort.width * side.real_top / side.product_width,
                    unit: side.unit,
                    width: designViewPort.width * side.real_width / side.product_width,
                },
                states: {},
                undos: [],
                redos: [],
                layers: [],
                canvas: {},
                rulers: [],
                rulerLines: {vers: [], hors: []}
            };
            if (angular.isDefined(side.bleed_radius) && side.bleed_radius != 0) {
                $scope.stages[index].config.bleed_radius = designViewPort.width * side.bleed_radius / side.product_width;
                $scope.stages[index].config.safezone_radius = designViewPort.width * side.safezone_radius / side.product_width;
            }
            var _state = $scope.stages[$scope.currentStage].states;
            angular.copy($scope.defaultStageStates, _state);
            var factor = 6.4516;
            switch (dimensionUnit) {
                case 'in':
                    factor = 1;
                    break;
                case 'mm':
                    factor = 645.16;
                    break;
                case 'ft':
                    factor = 1 / 144;
                    break;
                case 'px':
                    factor = parseFloat(side.dpi || $scope.settings.product_data.option.dpi) * parseFloat(side.dpi || $scope.settings.product_data.option.dpi);
                    break;
                default:
                    factor = 6.4516;
                    break;
            }
            _state.ratioConvertFont = designViewPort.width / (side.product_width / unitRatio * 2.54 * 72) * factor;
            _scaleRange.forEach(function (value) {
                value != 1 && _state.scaleRange.push({
                    ratio: value,
                    value: (value * 100).toFixed() + '%',
                    label: (value * 100).toFixed() + '%'
                });
            });
            _state.scaleRange.push({ratio: 1, value: '100%', label: 'Fit'});
            _state.scaleRange.push({
                ratio: fullScreenScale,
                value: (fullScreenScale * 100).toFixed() + '%',
                label: (fullScreenScale * 100).toFixed() + '%'
            });
            if (fillScale >= minScale && fillScale <= maxScale) _state.scaleRange.push({
                ratio: fillScale,
                value: (fillScale * 100).toFixed() + '%',
                label: 'Fill'
            });

            var printFactor = 2.54;
            switch (dimensionUnit) {
                case 'in':
                    printFactor = 1;
                    break;
                case 'mm':
                    printFactor = 25.4;
                    break;
                case 'ft':
                    printFactor = 1 / 12;
                    break;
                case 'px':
                    printFactor = parseFloat(side.dpi || $scope.settings.product_data.option.dpi);
                    break;
                default:
                    printFactor = 2.54;
                    break;
            }

            var dpi = $scope.getDPI(),
                printSizeWidth = side.product_width / printFactor * dpi,
                printSizeHeight = side.product_height / printFactor * dpi;

            var printScale = 0;
            if (printSizeWidth < maxSize && printSizeHeight < maxSize && printSizeWidth > minScale && printSizeHeight > minScale) {
                printScale = printSizeWidth / designViewPort.width;
                _state.scaleRange.push({
                    ratio: printScale,
                    value: (printScale * 100).toFixed() + '%',
                    label: 'Print Size'
                });
            }
            _state.scaleRange = _.sortBy(_state.scaleRange, [function (o) {
                return o.ratio;
            }]);
            _state.currentScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                return o.ratio == 1;
            });
            _state.fitScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                return o.ratio == 1;
            });
            _state.fillScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                return o.ratio == fillScale;
            });
            _state.fullScreenScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                return o.ratio == fullScreenScale;
            });
            _state.printScaleIndex = _.findIndex(_state.scaleRange, function (o) {
                return o.ratio == printScale;
            });
            $scope.updateApp();
            $timeout(function () {
                $scope.switchStage($scope.currentStage - 1, 'next');
                ($scope.settings.showRuler && appConfig.isModern) && $scope.initRuler();
            }, 100);
        };
        $scope.changeAreaDesignShape = function (stageIndex, svg) {
            jQuery('#stage-container-' + stageIndex + ' .stage-area-design-shape').html('').append(svg);
            $scope.areaDesignShapes[stageIndex] = svg;
            $timeout(function () {
                $scope.processAreaDesignShape(stageIndex);
            });
        };
        $scope.processAreaDesignShape = function (index) {
            var stage = $scope.stages[index];
            if (angular.isUndefined(stage)) return;
            if (angular.isUndefined($scope.areaDesignShapes[index]) && $scope.areaDesignShapes[index]) return;

            var svgWdth = stage.config.width * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
            var svgHght = stage.config.height * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;

            function makeSVGElement(tag, attrs) {
                var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
                for (var k in attrs)
                    el.setAttribute(k, attrs[k]);
                return el;
            }

            function standardizePathDStrFormat(str) {
                return str
                    .replace(/\n|\r/gm, " ")
                    .replace(/,/g, " ")
                    .replace(/-/g, " -")
                    .replace(/([A-Za-z])/g, " $1 ")
                    .replace(/  /g, " ")
                    .replace(/ ([Ee]) /g, "$1")
                    .replace(/^ /g, "")
                    .replace(/ $/g, "");
            }

            function getArrayOfPathDComponents(str) {
                str = standardizePathDStrFormat(str);
                return str.split(" ");
            }

            function getTransformedPathDStr(oldPathDStr, pathTranslX, pathTranslY, scale) {
                var BOTH_X_AND_Y = 1;
                var JUST_X = 2;
                var JUST_Y = 3;
                var NONE = 4;
                var ELLIPTICAL_ARC = 5;
                var ABSOLUTE = 6;
                var RELATIVE = 7;

                var oldPathDArr = getArrayOfPathDComponents(oldPathDStr);
                var newPathDArr = [];

                var commandParams, absOrRel, oldPathDComp, newPathDComp;

                var idx = 0;

                while (idx < oldPathDArr.length) {
                    var oldPathDComp = oldPathDArr[idx];
                    if (/^[A-Za-z]$/.test(oldPathDComp)) {
                        newPathDArr[idx] = oldPathDArr[idx];
                        switch (oldPathDComp.toUpperCase()) {
                            case "A":
                                commandParams = ELLIPTICAL_ARC;
                                break;
                            case "H":
                                commandParams = JUST_X;
                                break;
                            case "V":
                                commandParams = JUST_Y;
                                break;
                            case "Z":
                                commandParams = NONE;
                                break;
                            default:
                                commandParams = BOTH_X_AND_Y;
                        }
                        absOrRel = ((oldPathDComp === oldPathDComp.toUpperCase()) ? ABSOLUTE : RELATIVE);
                        idx += 1;
                    } else {
                        var translX, translY;
                        if (absOrRel === ABSOLUTE) {
                            translX = pathTranslX;
                            translY = pathTranslY;
                        } else if (absOrRel === RELATIVE) {
                            translX = 0;
                            translY = 0;
                        }
                        switch (commandParams) {
                            case BOTH_X_AND_Y:
                                newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                                newPathDArr[idx + 1] = Number(oldPathDArr[idx + 1]) * scale.Y + translY;
                                idx += 2;
                                break;
                            case JUST_X:
                                newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                                idx += 1;
                                break;
                            case JUST_Y:
                                newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.Y + translY;
                                idx += 1;
                                break;
                            case ELLIPTICAL_ARC:
                                newPathDArr[idx] = Number(oldPathDArr[idx]) * scale.X + translX;
                                newPathDArr[idx + 1] = Number(oldPathDArr[idx + 1]) * scale.Y + translY;
                                newPathDArr[idx + 2] = Number(oldPathDArr[idx + 2]);
                                newPathDArr[idx + 3] = Number(oldPathDArr[idx + 3]);
                                newPathDArr[idx + 4] = Number(oldPathDArr[idx + 4]);
                                newPathDArr[idx + 5] = Number(oldPathDArr[idx + 5]) * scale.X + translX;
                                newPathDArr[idx + 6] = Number(oldPathDArr[idx + 6]) * scale.Y + translY;
                                idx += 7;
                                break;
                            case NONE:
                                throw new Error('numeric value should not follow the SVG Z/z command');
                                break;
                        }
                    }
                }
                return newPathDArr.join(" ");
            }

            function getTranslationAndScaling(origPathBoundingBox, svgWdth, svgHght) {

                var origPathWdth = origPathBoundingBox.width;
                var origPathHght = origPathBoundingBox.height;
                var origPathX = origPathBoundingBox.x;
                var origPathY = origPathBoundingBox.y;

                if (origPathWdth == 0) return {pathTranslX: 0, pathTranslY: 0, scale: {X: 1, Y: 1}};

                var scaleBasedOnWdth = svgWdth / origPathWdth;
                var scaleBasedOnHght = svgHght / origPathHght;

                var scale = Math.min(scaleBasedOnWdth, scaleBasedOnHght);

                var scaledPathX = origPathX * scaleBasedOnWdth;
                var scaledPathY = origPathY * scaleBasedOnHght;
                var scaledPathWdth = origPathWdth * scaleBasedOnWdth;
                var scaledPathHght = origPathHght * scaleBasedOnHght;

                var scaledPathCentreX = scaledPathX + (scaledPathWdth / 2);
                var scaledPathCentreY = scaledPathY + (scaledPathHght / 2);
                var svgRootCentreX = 0 + (svgWdth / 2);
                var svgRootCentreY = 0 + (svgHght / 2);

                var pathTranslX = svgRootCentreX - scaledPathCentreX;
                var pathTranslY = svgRootCentreY - scaledPathCentreY;

                return {
                    pathTranslX: pathTranslX,
                    pathTranslY: pathTranslY,
                    scale: {X: scaleBasedOnWdth, Y: scaleBasedOnHght}
                };
            }

            $timeout(function () {
                if (jQuery('#stage-container-' + index + ' .stage-area-design-shape svg').length == 0) return;

                var _viewBox = $scope.areaDesignShapes[index].match(/viewBox="(.*?)"/)[1],
                    viewBox = _viewBox.split(/\s+|,/);

                var defs = makeSVGElement('defs', {}),
                    clipPath = makeSVGElement('clipPath', {id: 'area-design-shape-' + index}),
                    svg = document.querySelector('#stage-container-' + index + ' .stage-area-design-shape svg'),
                    path = document.querySelector('#stage-container-' + index + ' .stage-area-design-shape svg > path');
                var origPathBoundingBox = path.getBBox(),
                    d = path.getAttribute('d');
                oldDefs = svg.getElementsByTagName('defs')[0];
                if (oldDefs) {
                    svg.removeChild(oldDefs);
                }
                svg.insertBefore(defs, svg.firstChild);
                defs.appendChild(clipPath);

                var stageScale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                var obj = getTranslationAndScaling(origPathBoundingBox, svgWdth, svgHght),
                    zoomedObj = getTranslationAndScaling(origPathBoundingBox, svgWdth / stageScale, svgHght / stageScale),
                    pathTranslX = obj.pathTranslX,
                    pathTranslY = obj.pathTranslY,
                    scale = obj.scale,
                    zoomedPathTranslX = zoomedObj.pathTranslX,
                    zoomedPathTranslY = zoomedObj.pathTranslY,
                    zoomedScale = zoomedObj.scale,
                    newPathDStr = getTransformedPathDStr(d, pathTranslX, pathTranslY, scale),
                    newZoomedPathDStr = getTransformedPathDStr(d, zoomedPathTranslX, zoomedPathTranslY, zoomedScale),
                    newPath = makeSVGElement('path', {d: newPathDStr});
                clipPath.appendChild(newPath);
                $scope.areaDesignClipPaths[index] = newPathDStr;
                $scope.areaDesignZoomedClipPaths[index] = newZoomedPathDStr;
                jQuery('#stage-container-' + index + ' .stage-area-design-shape svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + svgWdth + " " + svgHght);

                var bleedWidth = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.width - 2 * stage.config.bleed_lr),
                    bleedHeight = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.height - 2 * stage.config.bleed_tb),
                    safeZoneWidth = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.width - 2 * stage.config.bleed_lr - 2 * stage.config.margin_lr),
                    safeZoneHeight = stage.states.scaleRange[stage.states.currentScaleIndex].ratio * (stage.config.height - 2 * stage.config.bleed_tb - 2 * stage.config.margin_tb),
                    bleedScaleX = viewBox[2] / bleedWidth,
                    bleedScaleY = viewBox[3] / bleedHeight,
                    safeZoneScaleX = viewBox[2] / safeZoneWidth,
                    safeZoneScaleY = viewBox[3] / safeZoneHeight;
                jQuery('#stage-container-' + index + ' .bleed-line').html('').append($scope.areaDesignShapes[index]);
                jQuery('#stage-container-' + index + ' .safe-line').html('').append($scope.areaDesignShapes[index]);

                var bleedObj = getTranslationAndScaling(origPathBoundingBox, bleedWidth, bleedHeight),
                    safeZoneObj = getTranslationAndScaling(origPathBoundingBox, safeZoneWidth, safeZoneHeight),
                    bleedPathTranslX = bleedObj.pathTranslX,
                    bleedPathTranslY = bleedObj.pathTranslY,
                    bleedScale = bleedObj.scale,
                    safeZonePathTranslX = safeZoneObj.pathTranslX,
                    safeZonePathTranslY = safeZoneObj.pathTranslY,
                    safeZoneScale = safeZoneObj.scale,
                    newBleedPathDStr = getTransformedPathDStr(d, bleedPathTranslX, bleedPathTranslY, bleedScale),
                    newSafeZonePathDStr = getTransformedPathDStr(d, safeZonePathTranslX, safeZonePathTranslY, safeZoneScale);
                //jQuery('#stage-container-' + index + ' .bleed-line svg path').attr({d: newBleedPathDStr, transform: 'scale(' + bleedScaleX + ', ' + bleedScaleY + ')'});
                jQuery('#stage-container-' + index + ' .bleed-line svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + bleedWidth + " " + bleedHeight);
                jQuery('#stage-container-' + index + ' .bleed-line svg path').attr({d: newBleedPathDStr});
                //jQuery('#stage-container-' + index + ' .safe-line svg path').attr({d: newSafeZonePathDStr, transform: 'scale(' + safeZoneScaleX + ', ' + safeZoneScaleY + ')'});
                jQuery('#stage-container-' + index + ' .safe-line svg').removeAttr('viewBox')[0].setAttribute("viewBox", viewBox[0] + " " + viewBox[1] + " " + safeZoneWidth + " " + safeZoneHeight);
                jQuery('#stage-container-' + index + ' .safe-line svg path').attr({d: newSafeZonePathDStr});

                $scope.updateApp();
            });
        };
        $scope.removeAreaDesignShape = function (stageIndex) {
            jQuery('#stage-container-' + stageIndex + ' .stage-area-design-shape').html('');
            jQuery('#stage-container-' + stageIndex + ' .bleed-line').html('');
            jQuery('#stage-container-' + stageIndex + ' .safe-line').html('');
            $scope.areaDesignShapes[stageIndex] = false;
            $scope.areaDesignClipPaths[stageIndex] = false;
        };
        /* Ruler and ruler guide line */
        $scope.toggleRuler = function () {
            $scope.settings.showRuler = !$scope.settings.showRuler;
            if ($scope.settings.showRuler && appConfig.isModern) {
                $scope.initRuler();
            } else {
                $scope.clearGuides();
            }
            ;
        };
        $scope.initRuler = function () {
            var viewPort = $scope.calcViewport();
            $timeout(function () {
                _.each($scope.settings.product_data.product, function (side, index) {
                    var stage = $scope.stages[index];
                    stage.hozRuler = jQuery('#hoz-ruler-' + index).nbdRuler({
                        layout: 'horizontal',
                        viewPort: viewPort,
                        config: stage.config,
                        zoomRatio: stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                        unit: stage.config.unit || $scope.settings.nbdesigner_dimensions_unit
                    });
                    stage.verRuler = jQuery('#ver-ruler-' + index).nbdRuler({
                        layout: 'vertical',
                        viewPort: viewPort,
                        config: stage.config,
                        zoomRatio: stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                        unit: stage.config.unit || $scope.settings.nbdesigner_dimensions_unit
                    });
                    stage.hozRuler.render();
                    stage.verRuler.render();
                });
            }, 100);
        };
        $scope.calcRulerPaddingLeft = function (cwidth) {
            var viewPort = $scope.calcViewport();
            var additionalPadding = (viewPort.width - cwidth) / 2;
            additionalPadding = additionalPadding > 0 ? (additionalPadding + 50) : 50;
            return additionalPadding + 'px';
        };
        $scope.calcRulerPaddingTop = function () {
            return '40px';
        };
        $scope.addRulerGuideLine = function ($event, direction) {
            var stage = $scope.stages[$scope.currentStage],
                el = jQuery($event.currentTarget),
                stageEl = el.parent('.stage'),
                stagePos = stageEl.offset(),
                top = $event.pageY - stagePos.top,
                left = $event.pageX - stagePos.left;
            stage.rulerLines[direction].push({top: top, left: left});
        };
        $scope.calcStyleGuideline = function (line, cf, ratio, direction) {
            var style = {};
            var viewPort = $scope.calcViewport();
            if (direction == 'hor') {
                style.top = (line.top > 40 ? (40 + (line.top - 40) * ratio - 3) : (line.top - 3)) + 'px';
                style.width = ((cf.cwidth * ratio > viewPort.width ? cf.cwidth * ratio : viewPort.width) + 100) + 'px';
            } else {
                var additionalPadding = (cf.cwidth * ratio - viewPort.width) / 2;
                if (additionalPadding < 0) {
                    if (line.left <= 50) {
                        style.left = line.left;
                    } else {
                        style.left = viewPort.width / 2 - (viewPort.width / 2 - (line.left - 50)) * ratio + 50;
                    }
                } else {
                    style.left = viewPort.width / 2 - (viewPort.width / 2 - (line.left - 50)) * ratio + 50 + additionalPadding;
                }
                style.left = (style.left - 3) + 'px';
                style.height = ((cf.cheight * ratio > viewPort.height ? cf.cheight * ratio : viewPort.height) + 90) + 'px';
            }
            return style;
        };
        $scope.clearGuides = function () {
            $scope.stages[$scope.currentStage].rulerLines = {vers: [], hors: []};
        };
        $scope.initStageSetting = function (id) {
            $scope.setStageDimension(id);
            $scope.renderStage(id);
            $scope.updateApp();
        };
        $scope.initStagesSettingWithoutTemplate = function () {
            _.each($scope.stages, function (stage, index) {
                var _canvas = stage.canvas;
                _canvas.requestRenderAll();
            });
            $scope.afterInsertTemplate();
        };
        $scope.firstTimeLoadedTemplate = true;
        $scope.firstTimeShowTemplateFiledsPopup = true;
        /*advanced*/
        if (typeof ht_nbd_js_config != "undefined") {
            var vid = $('#video-custom');
            $scope.buttonPopupShowVideo = function () {
                $('#tab-product-template .nbd-need-help .help svg').on('click', function () {
                    vid.trigger('play');
                    $scope.popupShowVideo();
                });
            }
            $scope.popupShowVideo = function () {
                vid.trigger('play');
                $('.nbd-popup.popup-nbt-video-help').nbShowPopup();
            }
            window.onload = function () {
                document.onclick = function (e) {
                    if (e.target.className === 'icon-nbd icon-nbd-clear close-popup' || e.target.className === 'overlay-popup') {
                        vid.trigger('pause');
                    }
                };
            };
        }
        $scope.afterInsertTemplate = function () {
            if ($scope.settings.ui_mode == 1 || $scope.settings.ui_mode == 2) {
                var showTourGuide = localStorage.getItem('showTourGuide');
                if (!showTourGuide) {
                    $scope.startTourGuide();
                    /*advanced*/
                    if (typeof ht_nbd_js_config != "undefined") {
                        $scope.popupShowVideo();
                    }
                } else {
                    $scope.showTemplateFieldsPopup();
                    /*advanced*/
                    if (typeof ht_nbd_js_config != "undefined") {
                        $('.nbd-need-help').show();
                        $scope.buttonPopupShowVideo();
                    }
                }
            }
            _.each($scope.stages, function (stage, index) {
                $scope.updateMaskedLayers(index);
                $timeout(function () {
                    $scope.setHistory(index, true);
                });
            });
            const currentCanvas = $scope.stages[$scope.currentStage].canvas;
            // currentCanvas.setBackgroundColor(currentCanvas.backgroundColor);
            $scope.setCurrentBackgoundGradientColor();
            currentCanvas.renderAll();
            $scope.firstTimeLoadedTemplate = false;
            $scope.completedInsertTemplate = true;
            $scope.onLoadPrintingOptions = false;
            $scope.preventChangeCurrentDesign = false;
            $scope.forceLoadVariationDesign = false;
            $scope.onChangePrintingOptions = false;

            if (angular.isDefined($scope.settings.nbes_enable_settings) && angular.isDefined($scope.settings.nbes_settings)
                && $scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined($scope.settings.nbes_settings.combination_colors)) {
                $scope.selectCombinationColor($scope.currentCombinationColor);
            }

            if ($scope.awaitSubmitForm) {
                $scope.saveData();
            }
            if (!$scope.queryParamsApplied) {
                $scope.applyWidthAndHeightFromQueryParams();
            }
        };
        $scope.queryParamsApplied = false;
        $scope.applyWidthAndHeightFromQueryParams = function () {
            const queryParams = new URLSearchParams(window.location.search);
            const width = queryParams.get('width');
            const height = queryParams.get('height');
            if (width && height) {
                $timeout(function () {
                    $scope.queryParamsApplied = true;
                    $scope.productChangeOptions.width = +width;
                    $scope.productChangeOptions.height = +height;
                    $scope.productChangeOptions.orientation = +width < +height ? '0' : '1';
                    $scope.onProductOptionChanged(false);
                });
            }
        }
        $scope.updateMaskedLayers = function (stage_id) {
            function getLayerbyId(canvas, id) {
                var layer;
                canvas.forEachObject(function (obj, idx) {
                    if (obj.get('itemId') == id) layer = obj;
                });
                return layer;
            }

            var _canvas = $scope.stages[stage_id].canvas,
                needRender = false;
            _canvas.forEachObject(function (obj, layerIndex) {
                if (!!obj.get('maskId')) {
                    var id = obj.get('maskId'),
                        maskLayer = getLayerbyId(_canvas, id);
                    if (maskLayer) {
                        needRender = true;
                        maskLayer.set({opacity: 0.001, fill: '#ffffff'});
                        obj.set({clipPath: maskLayer});
                    }
                }
            });
            if (needRender) {
                $scope.renderStage(stage_id);
            }
        };
        $scope.showTemplateFieldsPopup = function (force) {
            if (!$scope.settings.is_mobile && ($scope.settings.ui_mode == 1 || $scope.settings.ui_mode == 2) && NBDESIGNCONFIG.nbdesigner_enable_template_mapping == 'yes'
                && $scope.firstTimeShowTemplateFiledsPopup && NBDESIGNCONFIG.is_logged != 1 && !$scope.tourGuideShowing && $scope.templateHolderFields.length > 0) {
                $timeout(function () {
                    jQuery('.popup-template-fields').nbShowPopup();
                    $scope.firstTimeShowTemplateFiledsPopup = false;
                }, 400);
            }
            if (angular.isDefined(force)) {
                jQuery('.popup-template-fields').nbShowPopup();
            }
        };
        $scope.updateTemplateFields = function () {
            if ($scope.templateHolderFields.length > 0) {
                _.each($scope.templateHolderFields, function (field, index) {
                    if (field.value != '') {
                        _.each($scope.stages, function (stage, index) {
                            var _canvas = stage.canvas;
                            _canvas.forEachObject(function (obj) {
                                if (angular.isDefined(obj.field_mapping) && field.key == obj.field_mapping) {
                                    obj.text = field.value;
                                }
                            });
                            _canvas.calcOffset();
                            _canvas.requestRenderAll();
                        });
                    }
                });
            }
            jQuery('.popup-template-fields .close-popup').triggerHandler('click');
        };
        $scope.duplicateStageIndex = -1;
        $scope.addStage = function (duplicate, switchStage = true) {
            var new_stage = {}, new_side_config = {}, stageLen = $scope.stages.length,
                currentStage = $scope.currentStage;
            var _canvas = $scope.stages[$scope.currentStage].canvas;
            angular.copy($scope.stages[$scope.currentStage], new_stage);
            if (angular.isDefined($scope.settings.product_data.option.new_side_name)) {
                if (angular.isUndefined($scope.settings.product_data.origin_product)) {
                    $scope.settings.product_data.origin_product = [];
                    angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
                }
                new_stage.config.name = $scope.settings.product_data.option.new_side_name;
                var max_number_side = parseInt($scope.settings.product_data.option.max_number_side);
                if (($scope.settings.product_data.origin_product.length + max_number_side) == $scope.stages.length) {
                    $scope.resource.canAdd = false;
                    return;
                }
            }
            $scope.preventLoadDesign = true;
            angular.copy($scope.settings.product_data.product[$scope.currentStage], new_side_config);
            $scope.settings.product_data.product.splice($scope.currentStage + 1, 0, new_side_config);
            $scope.resource.config.qty++;
            if (duplicate) {
                if (stageLen > ($scope.currentStage + 1)) {
                    $scope.duplicateStageIndex = $scope.currentStage + 1;
                }
                $scope.resource.jsonDesign[$scope.currentStage + 1] = {};
                angular.copy(_canvas.toJSON($scope.includeExport), $scope.resource.jsonDesign[$scope.currentStage + 1]);
            }
            $scope.stages.splice($scope.currentStage + 1, 0, new_stage);
            $scope.updateApp();
            if (angular.isDefined($scope.settings.product_data.option.max_number_side)) {
                if (($scope.settings.product_data.origin_product.length + parseInt($scope.settings.product_data.option.max_number_side)) == $scope.stages.length) {
                    $scope.resource.canAdd = false;
                }
            }
            ;
            if (switchStage) {
                $timeout(function () {
                    $scope.switchStage($scope.currentStage, 'next');
                    if (stageLen == (currentStage + 1)) {
                        $scope.contextAddLayers = 'template';
                        $scope.onloadTemplate = true;
                        $scope.stages[stageLen].canvas.loadFromJSON($scope.resource.jsonDesign[stageLen], function () {
                            $scope.onloadTemplate = false;
                            $scope.contextAddLayers = 'normal';
                        });
                    }
                }, 100);
            }
        };
        $scope.removeStage = function (index, switchStage = true) {
            var currentStage = angular.isDefined(index) ? index : $scope.currentStage;
            if ($scope.currentStage > 0) {
                $scope.currentStage--;
                if (switchStage) {
                    $scope.switchStage(currentStage, 'prev', 'top-bottom', true);
                }
            }
            $scope.saveDesign();
            $scope.settings.product_data.product.splice(currentStage, 1);
            $scope.stages.splice(currentStage, 1);
            $scope.updateApp();
            $scope.closePopup('.popup-nbd-delete-stage-alert');
            $scope.resource.config.qty--;
            $scope.resource.canAdd = true;
        };
        $scope.closePopup = function (popup) {
            jQuery(popup + ' .close-popup').triggerHandler('click');
        };
        $scope.resetStage = function () {
            var new_stage = {};
            angular.copy($scope.stages[0], new_stage);
            $scope.stages = [];
            $scope.stages.push(new_stage);
            $scope.currentStage = 0;
            $scope.preventLoadDesign = true;
        };
        $scope.setStageDimension = function (id) {
            id = angular.isDefined(id) ? id : $scope.currentStage;
            var _stage = $scope.stages[id];
            var currentWidth = _stage.config.width * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio,
                currentHeight = _stage.config.height * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
            $scope.stages[id]['canvas'].setDimensions({'width': currentWidth, 'height': currentHeight});
        };
        if (typeof nbod_addon_side_thumbnail != "undefined") {
            ////nbdesigner advanced
            $scope.getStageThumbnail = function (id) {
                id = angular.isDefined(id) ? id : $scope.currentStage;
                var _stage = $scope.stages[id];
                _canvas = $scope.stages[id]['canvas'];
                if (typeof _canvas == undefined) return;
                if (_canvas._objects.length == 0) {
                    var image = $scope.stages[id].config.bgImage;
                } else {
                    jQuery('.img_thumbnail_css.active').css('background', 'url(' + $scope.stages[id].config.bgImage + ')0% 50% /contain no-repeat');
                    var image = _canvas.toDataURL();
                }
                _stage.stage_thumbnail = image;
                return _stage.stage_thumbnail;
            };
        }
        $scope.switchStageTo = function (id, direction) {
            $scope.currentStage = id;
            jQuery('.stage').addClass('_nbd_hidden')
                .removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp')
                .removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
            var idCurrentStage = '#stage-container-' + id,
                fadeInClass = direction == 'left-right' ? 'fadeInRight' : 'fadeInUp';
            jQuery(idCurrentStage).removeClass('_nbd_hidden').addClass(fadeInClass);
            const stage = $scope.getCurrentStage();
            $scope.productChangeOptions = {
                ...$scope.productChangeOptions,
                width: Number(stage.config.pWidth),
                height: Number(stage.config.pHeight),
                unit: stage.config.unit,
                dpi: Number(stage.config.dpi) || 300,
            };
        };
        $scope.switchStage = function (id, command, direction, onRemoveStage) {
            var idCurrentStage = 'stage-container-' + id,
                next = parseInt(id) + 1;
            if (command == 'prev') {
                next = parseInt(id) - 1;
            }
            ;
            if (typeof nbod_addon_side_thumbnail != "undefined" || typeof kvlc_js_cusom != "undefined") {
                // nbdesigner-advanced
                if (command == 'index') {
                    next = parseInt(id);
                    if (next == $scope.currentStage) {
                        return;
                    }
                    idCurrentStage = 'stage-container-' + $scope.currentStage;
                }
            }
            ;
            jQuery('.temporary-hidden').addClass('nb-opacity-0');
            $timeout(function () {
                jQuery('.temporary-hidden').removeClass('nb-opacity-0');
            }, 600);
            jQuery('.nbd-stages .ps__scrollbar-x-rail, .nbd-stages .ps__scrollbar-y-rail').addClass('nbd-hiden');
            $timeout(function () {
                jQuery('.nbd-stages .ps__scrollbar-x-rail, .nbd-stages .ps__scrollbar-y-rail').removeClass('nbd-hiden');
            }, 700);
            direction = angular.isDefined(direction) ? direction : 'top-bottom';
            var fadeInNext = 'fadeInUp', fadeInPrev = 'fadeInDown', fadeOutNext = 'fadeOutDown',
                fadeOutPrev = 'fadeOutUp';
            if (direction == 'left-right') {
                fadeInNext = 'fadeInRight';
                fadeInPrev = 'fadeInLeft';
                fadeOutNext = 'fadeOutRight';
                fadeOutPrev = 'fadeOutLeft';
            }
            ;

            var idNextStage = 'stage-container-' + next;
            var currentStage = angular.element(document.getElementById(idCurrentStage)),
                nextStage = angular.element(document.getElementById(idNextStage));
            if (direction == 'left-right') {
                currentStage.removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp');
                nextStage.removeClass('fadeInUp').removeClass('fadeInDown').removeClass('fadeOutDown').removeClass('fadeOutUp');
            } else {
                currentStage.removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
                nextStage.removeClass('fadeInLeft').removeClass('fadeInRight').removeClass('fadeOutRight').removeClass('fadeOutLeft');
            }
            currentStage.addClass('animated');
            currentStage.removeClass(fadeInNext);
            currentStage.removeClass(fadeInPrev);
            nextStage.addClass('animated');
            nextStage.removeClass('_nbd_hidden');
            nextStage.removeClass(fadeOutNext);
            nextStage.removeClass(fadeOutPrev);
            if (command == 'prev') {
                currentStage.removeClass(fadeOutNext);
                currentStage.addClass(fadeOutPrev);
                nextStage.addClass(fadeInPrev);
            } else {
                currentStage.removeClass(fadeOutPrev);
                currentStage.addClass(fadeOutNext);
                nextStage.addClass(fadeInNext);
            }
            ;

            if (angular.isUndefined(onRemoveStage)) $scope.currentStage = next;
            if (appConfig.isVisual) {
                $scope.deactiveAllLayer();
            }
            $scope.renderStage();
            $scope.updateLayersList();
            $scope.setCurrentBackgoundGradientColor();
            const stage = $scope.getCurrentStage();
            $scope.productChangeOptions = {
                ...$scope.productChangeOptions,
                width: Number(stage.config.pWidth),
                height: Number(stage.config.pHeight),
                unit: stage.config.unit,
                dpi: Number(stage.config.dpi) || 300,
            };
        };

        $scope.handleCopyDesignToClipbordClicked = function () {
            const canvas = $scope.getCurrentStageCanvas();
            if (!canvas) {
                return;
            }
            canvas.getElement().toBlob(function (blob) {
                navigator.clipboard.write([
                    new ClipboardItem({
                        'image/png': blob
                    })
                ]);
                jQuery('.nbd-toasts__image-copy').nbToasts();
            });
        }

        $scope.stageEvent = {
            dropped: false,
            target: null,
            lastDistance: null,
            lastScaleX: null,
            lastScaleY: null
        };
        $scope.onDropOnCanvas = function (op) {
            $scope.stageEvent.dropped = true;
            if (op.target) {
                $scope.stageEvent.target = op.target;
            }
        };
        $scope.onDragenterOnCanvas = function (op) {
        };
        $scope.onDragleaveOnCanvas = function (op) {
        };
        $scope.onDrop = function (event) {
            event.preventDefault();
            var src = event.originalEvent.dataTransfer.getData("src"),
                download = event.originalEvent.dataTransfer.getData("download"),
                extenal = event.originalEvent.dataTransfer.getData("extenal"),
                type = event.originalEvent.dataTransfer.getData("type"),
                origin_url = event.originalEvent.dataTransfer.getData("origin_url"),
                width = event.originalEvent.dataTransfer.getData("origin_width"),
                height = event.originalEvent.dataTransfer.getData("origin_height");
            /*advanced*/
            if (typeof udc_nbd_js_config != 'undefined') {
                overlaytype = event.originalEvent.dataTransfer.getData("objecttype");
                overlayfile = event.originalEvent.dataTransfer.getData("objectfile");
            }
            switch (type) {
                case 'image':

                function addImage(maskId) {
                    if (extenal == 'true') {
                        if (angular.isDefined(maskId)) {
                            $scope.addImageFromUrl(download ? {url: {url: src, download}} : src, true, false, maskId);
                        } else {
                            $scope.addImageFromUrl(download ? {url: {url: src, download}} : src, true);
                        }
                    } else {
                        var data = src;
                        if (angular.isDefined(origin_url) && origin_url != '') {
                            var data = {
                                url: src,
                                src: src,
                                download,
                                origin_url: origin_url,
                                width: parseInt(width),
                                height: parseInt(height)
                            };
                        }
                        if (angular.isDefined(maskId)) {
                            $scope.addImageFromUrl(data, false, false, maskId);
                        } else {
                            $scope.addImageFromUrl(data, false);
                        }
                    }
                    ;
                }

                    var interval = $interval(function () {
                        if ($scope.stageEvent.dropped) {
                            $interval.cancel(interval);
                            if (!!$scope.stageEvent.target && !!$scope.stageEvent.target.get('itemId') && !!$scope.stageEvent.target.get('maskId')) {
                                addImage($scope.stageEvent.target.get('maskId'));
                            } else {
                                addImage();
                            }
                            $scope.stageEvent.dropped = false;
                            $scope.stageEvent.target = null;
                        }
                    }, 50);
                    break;
                case 'svg':
                    if (extenal == 'true') {
                        $scope.addSvgFromMedia({url: src});
                        break;
                    }
                    $scope.addImageFromUrl(src, false);
                    break;
                case 'typo':
                    $scope.insertTypography({folder: src});
                    break;
            }
            ;
            /*advanced*/
            if (typeof udc_nbd_js_config != 'undefined') {
                switch (type) {
                    case 'elementimage':
                        $scope.addImagetocanvas(src);
                        break;
                    case 'overlay':
                        $scope.addOverlayFromUrl(overlaytype, overlayfile);
                        break;
                }
            }
        };
        if (typeof checkBox != "undefined") {
            $scope.JtextBox = function () {
                var textToCanVas = $scope.stages[$scope.currentStage].canvas;
                var textobject = textToCanVas.getActiveObject();
                if (typeof textobject.checkTexBox == "undefined") {
                    textobject.checkTexBox = false;
                } else {
                    if (textobject.checkTexBox && textobject.checkTexBox == true) {
                        textobject.text = textobject.text.toLowerCase();
                        $scope.capital = false;
                        textobject.checkTexBox = false;
                    } else {
                        textobject.checkTexBox = true
                        $scope.capital = true;
                        textobject.text = textobject.text.toUpperCase();
                    }
                    $scope.renderStage();
                }
            }
        }
        if (typeof checkBox != "undefined") {
            $scope.inputCellValue = function () {
                var a = $("#CellValue").val();
                var textToCanVas = $scope.stages[$scope.currentStage].canvas;
                var textobject = textToCanVas.getActiveObject();
                textobject.cellValue = true;
                if (textobject.cellValue) {
                    textobject.valueOfinput = a;
                    if (a > 0) {
                        if (typeof textobject.temporary == "undefined") {
                            textobject.temporary = "";
                        } else {
                            if (textobject.temporary == "") {
                                textobject.temporary = textobject.text;
                            } else {
                                textobject.text = textobject.temporary;
                            }
                            textobject.text = textobject.temporary;
                            textobject.text = textobject.text.substr(0, a);
                        }
                    }
                }
                $scope.renderStage();
            }
            $scope.LockFont = function () {
                var textToCanVas = $scope.stages[$scope.currentStage].canvas;
                var textobject = textToCanVas.getActiveObject();
                if (typeof textobject.lockFontEdit == "undefined") {
                    $scope.lockFont = true;
                    textobject.lockFontEdit = true;
                    jQuery(".item-font-size").css("display", "none");
                    $scope.renderStage();
                } else {
                    if (textobject.lockFontEdit && textobject.lockFontEdit == true) {
                        $scope.lockFont = false;
                        textobject.lockFontEdit = false;
                        jQuery(".item-font-size").css("display", "inline-block");
                    } else {
                        $scope.lockFont = true;
                        textobject.lockFontEdit = true;
                        jQuery(".item-font-size").css("display", "none");
                    }
                    $scope.renderStage();
                }
            }
        }
        $scope.onMouseDown = function (id, options) {
            /* NBDesigner Advanced */
            if (typeof hvc_app_modern_js != "undefined") {
                var item = options.target;
                if (item) {
                    var val = (typeof item.scaleM !== "undefined" ? item.scaleM : 10);
                    jQuery('.item-cuttom-scale input.slide-input').val(val);
                }
            }
            if (typeof checkBox != "undefined") {
                if (options.target != null) {
                    if (options.target.valueOfinput) {
                        $("#CellValue").val(options.target.valueOfinput);
                    }
                    if (typeof options.target.valueOfinput == "undefined") {
                        $("#CellValue").val("");
                    }
                    $scope.capital = options.target.checkTexBox;
                    $scope.lockFont = options.target.lockFontEdit;
                    if (options.target.lockFontEdit == true) {
                        jQuery(".item-font-size").css("display", "none");
                    } else {
                        jQuery(".item-font-size").css("display", "inline-block");
                    }
                }
            }
            $scope.stages[$scope.currentStage].states.isShowToolBox = true;
            if (checkMobileDevice()) {
                jQuery('.nbd-main-menu .menu-item').removeClass('active');
            }
            $scope.updateApp();
        };
        $scope.onDblClick = function (options) {
            var item = options.target;
            if (item) {
                if (item.type === 'image') {
                    $scope.initCrop();
                } else if (item.type === 'activeSelection') {
                    $scope.deactiveAllLayer();
                } else if (!!item.get('maskId') && !$scope.stages[$scope.currentStage].states.lockMask) {
                    $scope.editMask();
                    var _stage = $scope.stages[$scope.currentStage];
                    _stage.states.corners = [];
                } else if (item.type === 'group') {
                    $scope.handleGroupDoubleClick(options);
                }
            }
        };
        $scope.onMouseOverStage = function (id, options) {
            if (options.e.buttons === 1) {
                let evt;
                if ($scope.lastClick) {
                    evt = new MouseEvent("mousedown", {
                        clientX: $scope.lastClick.clientX,
                        clientY: $scope.lastClick.clientY
                    });
                } else {
                    evt = new MouseEvent("mousedown", {
                        clientX: options.e.clientX,
                        clientY: options.e.clientY
                    });
                }
                const target = options.target;
                if (target && target.selectable) {
                    target.set({
                        selectable: false
                    });
                    options.e.currentTarget.dispatchEvent(evt);
                    target.set({
                        selectable: true
                    });
                } else {
                    options.e.currentTarget.dispatchEvent(evt);
                }
            }
            if (options.target) {
                var item = options.target;
                $scope.updateBoundingRect(item);
                $scope.updateApp();
            }
        };
        $scope.onMouseOutStage = function (id, options) {
            if (options.target) {
                angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});
            }
            $scope.updateApp();
        };
        $scope.onMouseMoveStage = function (id, options) {
            if ($scope.settings.showRuler && appConfig.isModern) {
                var _stage = $scope.stages[$scope.currentStage];
                if (_stage.hozRuler) {
                    var pointer = _stage.canvas.getPointer(options.e);
                    var x = (pointer.x + _stage.config.top) * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio,
                        y = (pointer.y + _stage.config.top) * _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
                    _stage.hozRuler.updateCursorIndicator({x: x, y: y});
                    _stage.verRuler.updateCursorIndicator({x: x, y: y});
                }
            }
            if (options.target && options.e.touches && options.e.touches.length == 2) {
                var item = options.target;
                if (item && item.type != 'activeSelection') {
                    var scaleX = item.get('scaleX'),
                        scaleY = item.get('scaleY'),
                        pageX1 = options.e.touches[0].pageX,
                        pageY1 = options.e.touches[0].pageY,
                        pageX2 = options.e.touches[1].pageX,
                        pageY2 = options.e.touches[1].pageY,
                        distance = Math.sqrt((pageX1 - pageX2) * (pageX1 - pageX2) + (pageY1 - pageY2) * (pageY1 - pageY2));
                    distance = distance == 0 ? 1 : distance;
                    if (!$scope.stageEvent.lastDistance) {
                        $scope.stageEvent.lastDistance = distance;
                        $scope.stageEvent.lastScaleX = scaleX;
                        $scope.stageEvent.lastScaleY = scaleY;
                    }
                    var ratio = distance / $scope.stageEvent.lastDistance;
                    ratio = ratio > 3 ? 3 : ratio;
                    item.set({
                        scaleX: $scope.stageEvent.lastScaleX * ratio,
                        scaleY: $scope.stageEvent.lastScaleY * ratio
                    });
                    item.setCoords();
                    $scope.adjustMaskedLayers(item, 'at');
                    $scope.renderStage();
                }
            }
        };
        $scope.onMouseUpStage = function (id, options) {
            var _stage = $scope.stages[$scope.currentStage];
            /*
         * Hide bounding rect, coordinates label, snap lines, rotate label
         */
            angular.merge(_stage.states.boundingObject, {visibility: 'hidden'});
            angular.merge(_stage.states.coordinates, {style: {visibility: 'hidden'}});
            var position = {
                ht: {top: -9999},
                hb: {top: -9999},
                hc: {top: -9999},
                vl: {left: -9999},
                vr: {left: -9999},
                vc: {left: -9999},
                hcc: {top: -9999},
                vcc: {left: -9999},
                vel: {left: -9999},
                ver: {left: -9999},
                het: {top: -9999},
                heb: {top: -9999}
            };
            angular.merge(_stage.states.snaplines, position);
            angular.merge(_stage.states.rotate, {style: {visibility: 'hidden'}});
            /* get layer parameters before modify */
            var _canvas = _stage.canvas,
                objects = _canvas.getActiveObjects();
            _stage.tempParameters = null;
            if (objects.length == 1) {
                _stage.tempParameters = JSON.stringify(objects[0].toJSON());
            }
            /*advanced*/
            if (typeof add_change_fonts_colors != "undefined" || typeof udc_nbd_js_config != "undefined") {
                var item = options.target;
                if (item && item.selectionStart != item.selectionEnd) {
                    angular.forEach(item.getSelectionStyles()[0], function (ele, key) {
                        _stage.states.text[key] = ele;
                        if (key == 'fontSize') {
                            _stage.states.text.ptFontSize = (ele / _stage.states.ratioConvertFont).toFixed(2);
                        }
                        if (key == 'fontFamily') {
                            _stage.states.text.font.alias = ele;
                            _stage.states.text.font.name = ele;
                        }
                    });
                }
            }
            /* Delete layer if out of stage fully */
            if (options.target) {
                if (!options.target.isOnScreen()) $scope.deleteLayers();
            }

            $scope.stageEvent.lastDistance = null;
            $scope.stageEvent.lastScaleX = null;
            $scope.stageEvent.lastScaleY = null;

            if ($scope.settings.nbdesigner_always_show_layer_action == 'yes') {
                $scope.updateCorners();
            }

            $scope.updateApp();
        };
        $scope.beforeObjectModify = function (item) {
            /*$scope.setHistory({
            element: item,
            parameters: JSON.stringify(item.toJSON()),
            interaction: 'modify'
        });*/
        };
        $scope.afterObjectModify = function () {
            $scope.setHistory($scope.currentStage, true);
            $scope.stageDesignChanged();
        };
        $scope.stageDesignChanged = function () {
            $scope.stickerCutline.active = false;
        };
        $scope.onPathCreated = function (id, options) {
        };
        $scope.onObjectAdded = function (id, options) {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage['canvas'],
                item = options.target,
                d = new Date(),
                itemId = d.getTime() + Math.floor(Math.random() * 1000);
            if ($scope.contextAddLayers == 'normal' || $scope.contextAddLayers == 'copy') {
                if (!$scope.canAddMoreLayer()) {
                    _canvas.remove(item);
                    return
                }
                ;
            }
            if ($scope.contextAddLayers == 'normal' || $scope.contextAddLayers == 'copy' || $scope.contextAddLayers == 'template') {
                if (angular.isUndefined(item.get('itemId'))) {
                    item.set({"itemId": itemId});
                }
            }
            ;
            if ($scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status) {
                _stage.states.isShowToolBox = true;
                _canvas.viewportCenterObject(item);
                $scope.toggleTip();
            }
            var type = item.get('type');
            if ($scope.resource.upload.ilr) {
                item.set({ilr: true});
                $scope.resource.upload.ilr = false;
            }
            if (type == 'i-text' || type == 'textbox' || type == 'text' || type == 'curvedText') item.initDimensions();
            item.setCoords();
            if ((['normal', 'copy', 'undo', 'redo'].indexOf($scope.contextAddLayers) > -1) && _stage.config.area_design_type == "2") $scope.setStackLayerAlwaysOnTop();
            var top = item.get('top'),
                left = item.get('left');
            if ($scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status) {
                item.set({top: top - 50});
                item.animate('top', top, {
                    duration: 200,
                    onChange: function () {
                        $scope.renderStage();
                    },
                    onComplete: function () {
                        if (item.isBgImg) {
                            $scope.setStackLayerAlwaysOnBottom();
                        } else {
                            _canvas.setActiveObject(item);
                        }
                        /*$scope.setHistory({
                        element: item,
                        parameters: JSON.stringify(item.toJSON()),
                        interaction: 'add'
                    });*/
                        $scope.setHistory($scope.currentStage, true);
                        $scope.stages[$scope.currentStage].tempParameters = JSON.stringify(item.toJSON());
                        if (type == 'i-text' || type == 'textbox') {
                            item.selectAll();
                            item.enterEditing();
                        }
                        $scope.renderStage();
                        $scope.afterAddNewObject();
                    },
                    easing: FabricWindow.util.ease['easeInQuad']
                });
                $scope.stages[$scope.currentStage].states.isActiveLayer = true;
            } else if ($scope.contextAddLayers == 'copy') {
                item.set({top: top - 20, left: left - 20});
                item.animate({'top': top, 'left': left}, {
                    duration: 200,
                    onChange: function () {
                        $scope.renderStage();
                    },
                    onComplete: function () {
                        /*$scope.setHistory({
                        element: item,
                        parameters: JSON.stringify(item.toJSON()),
                        interaction: 'add'
                    });*/
                        $scope.setHistory($scope.currentStage, true);
                        $scope.stages[$scope.currentStage].tempParameters = JSON.stringify(item.toJSON());
                        $scope.renderStage();
                    },
                    easing: FabricWindow.util.ease['easeInQuad']
                });
            } else {
                $scope.renderStage();
            }
            ;
            if (!$scope.onloadTemplate) {
                if ($scope.onUnloadGroup.status) {
                    if (angular.isDefined($scope.onUnloadGroup.prevIndex)) {
                        item.moveTo(parseInt($scope.onUnloadGroup.prevIndex) + $scope.onUnloadGroup.length - $scope.onUnloadGroup.remain);
                    }
                    if (type == 'i-text' || type == 'textbox' || type == 'text' || type == 'curvedText') {
                        item.set({editable: true});
                        if (typeof nbptemp_ai_to_svg != 'undefined' || typeof nbpdf_ai_to_svg != 'undefined') {
                            item.set({editable: true, clipPath: null});
                        }
                    }
                    if ($scope.onUnloadGroup.remain > 1) {
                        $scope.onUnloadGroup.remain -= 1;
                    } else {
                        $scope.onUnloadGroup = {
                            status: false,
                            remain: 0
                        };
                        $scope.contextAddLayers = 'normal';
                        $scope.setHistory($scope.currentStage, true);
                    }
                } else {
                    $scope.contextAddLayers = 'normal';
                }
            }
            if ($scope.contextAddLayers == 'normal' && !$scope.resource.drawMode.status) {
                $scope.showDesignTab();
            }
            $scope.forceForeground(item);
            $scope.updateLayersList();
            $scope.stageDesignChanged();
        };
        $scope.onObjectRemoved = function (id, options) {
            $scope.stageDesignChanged();
        };
        $scope.afterAddNewObject = function () {
        };
        $scope.showDesignTab = function () {
            if (checkMobileDevice()) {
                jQuery('#design-tab').triggerHandler('click');
            }
            ;
        };
        $scope.disablePreventClickMode = function () {
            jQuery('.tabs-content').removeClass('nbd-prevent-click');
        };
        $scope.onObjectScaling = function (id, options) {
            var item = options.target;
            $scope.adjustMaskedLayers(item);
            $scope.updateAssociateLayer(item);
            $scope.stages[$scope.currentStage].states.isShowToolBox = false;
            $scope.stages[$scope.currentStage].states.corners = [];
        };
        $scope.onObjectScaled = function (id, options) {
            var item = options.target;
            $scope.stages[$scope.currentStage].states.isShowToolBox = true;
            $scope.setPositionToolbox();
            $scope.adjustMaskedLayers(item, 'at');
        };
        $scope.onObjectMoving = function (id, options) {
            var item = options.target;
            if (item.maskId || item.isMask) {
                $scope.adjustMaskedLayers(item);
            }
            $scope.updateAssociateLayer(item);
            $scope.stages[$scope.currentStage].states.isShowToolBox = false;
            $scope.stages[$scope.currentStage].states.corners = [];
        };
        $scope.isGroup = function (item) {
            return item && item.type === 'group';
        }
        $scope.isActiveSelection = function (item) {
            return item && item.type === 'activeSelection';
        }
        $scope.onObjectMoved = function (id, options) {
            var item = options.target;
            $scope.stages[$scope.currentStage].states.isShowToolBox = true;
            $scope.setPositionToolbox();
            $scope.adjustMaskedLayers(item, 'at');
        };
        $scope.onObjectRotating = function (id, options) {
            var item = options.target;
            $scope.updateAssociateLayer(item);
            $scope.updateAngleLabel(item);
            $scope.stages[$scope.currentStage].states.corners = [];
        };
        $scope.makeActiveSelectionMasksMovable = function (activeSelection, moveToIndex = true) {
            if (!activeSelection || (!$scope.isActiveSelection(activeSelection) && !$scope.isGroup(activeSelection))) {
                return;
            }
            const maskedObjects = activeSelection.getObjects()
                .filter((object) => !!object.clipPath && object.maskId);
            if (!maskedObjects.length || activeSelection.getObjects().length <= 1) {
                $scope.stages[$scope.currentStage].states.isGrouppedSelection = false;
                return;
            } else if ($scope.isGroup(activeSelection)) {
                const canvas = $scope.getCurrentStageCanvas();
                canvas.discardActiveObject();
                const selection = new fabric.ActiveSelection([activeSelection], {
                    canvas
                });
                maskedObjects.forEach((o) => {
                    const maskId = o.maskId;
                    const maskObjIndex = $scope.getLayerById(maskId);
                    const maskLayer = canvas.item(maskObjIndex);
                    maskLayer.set({
                        selectable: true, hasRotatingPoint: false,
                    });
                    selection.addWithUpdate(maskLayer);
                    $scope.movableMasks.push(maskLayer);
                });
                canvas.setActiveObject(selection);
                $scope.stages[$scope.currentStage].states.isGroup = false;
                $scope.stages[$scope.currentStage].states.isGrouppedSelection = true;
                return;
            }
            const stage = $scope.stages[$scope.currentStage];
            const _canvas = stage['canvas'];
            maskedObjects.forEach((object) => {
                const maskId = object.maskId;
                const maskObjIndex = $scope.getLayerById(maskId);
                const maskLayer = _canvas.item(maskObjIndex);
                if (moveToIndex) {
                    object.moveTo(maskObjIndex);
                }
                if ($scope.isGroup(activeSelection)) {
                    maskLayer.set({
                        absolutePositioned: false
                    });
                }
                ;
                maskLayer.set({selectable: true, hasRotatingPoint: false});
                activeSelection.addWithUpdate(maskLayer);
                $scope.movableMasks.push(maskLayer);
            });
        };

        $scope.clearMovableMasks = function () {
            $scope.movableMasks.forEach((mask, index) => {
                mask.set({selectable: false});
                $scope.movableMasks.splice(index, 1);
            });
        }
        $scope.adjustMaskedLayers = function (obj, context) {
            if (obj.type === 'activeSelection' || obj.type === 'group') {
                return;
            }
            var _canvas = this.stages[$scope.currentStage].canvas;

            function adjustMaskedLayer(item) {
                if (!!item.get('maskId')) {
                    var maskLayerIndex = $scope.getLayerById(item.get('maskId'));
                    const maskLayer = _canvas.item(maskLayerIndex);
                    if (typeof maskLayerIndex != "undefined") {
                        var maskLeft = maskLayer.get('left'),
                            originX = maskLayer.get('originX'),
                            originY = maskLayer.get('originY'),
                            angle = maskLayer.get('angle'),
                            maskTop = maskLayer.get('top'),
                            maskWidth = maskLayer.get('width') * maskLayer.get('scaleX'),
                            maskHeight = maskLayer.get('height') * maskLayer.get('scaleY'),
                            scaleX = item.get('scaleX'),
                            scaleY = item.get('scaleY'),
                            imWidth = item.get('width'),
                            imHeight = item.get('height'),
                            width = item.get('width') * scaleX,
                            height = item.get('height') * scaleY,
                            left = item.get('left'),
                            top = item.get('top'),
                            realLeft = item.originX === 'center' ? left - width / 2 : left,
                            realTop = item.originY === 'center' ? top - height / 2 : top;

                        function lessThan(x, y) {
                            var epsilon = 0.00001;
                            return x < y && Math.abs(x - y) > epsilon;
                        };

                        if (lessThan(width, maskWidth) || lessThan(height, maskHeight)) {
                            if (lessThan(width, maskWidth)) {
                                var _scaleX = maskWidth / item.get('width');
                                item.set({
                                    left: angle ? maskLeft : maskLeft + maskWidth / 2,
                                    scaleX: _scaleX
                                });
                                if (imWidth < imHeight && scaleY < _scaleX) {
                                    item.set({
                                        scaleY: _scaleX
                                    });
                                }
                            }
                            if (lessThan(height, maskHeight)) {
                                var _scaleY = maskHeight / item.get('height');
                                item.set({
                                    top: angle ? maskTop : maskTop + maskHeight / 2,
                                    scaleY: _scaleY
                                });
                                if (imWidth > imHeight && scaleX < _scaleY) {
                                    item.set({
                                        scaleX: _scaleY
                                    });
                                }
                            }
                        } else {
                            if (realLeft > maskLeft) {
                                item.set({
                                    left: left - (realLeft - maskLeft)
                                });
                            }
                            if (realTop > maskTop) {
                                item.set({
                                    top: top - (realTop - maskTop)
                                });
                            }
                            if ((realLeft + width) < (maskLeft + maskWidth)) {
                                item.set({
                                    left: left + (maskLeft + maskWidth - realLeft - width)
                                });
                            }
                            if ((realTop + height) < (maskTop + maskHeight)) {
                                item.set({
                                    top: top + (maskTop + maskHeight - realTop - height)
                                });
                            }
                        }
                        item.setCoords();
                    }
                } else if (!!item.get('isMask')) {
                    var maskId = item.get('itemId'),
                        maskedLayer = $scope.getMaskedLayerByMaskId(maskId);
                    if (typeof maskedLayer != "undefined") {
                        var maskLeft = item.get('left'),
                            maskTop = item.get('top'),
                            maskWidth = item.get('width') * item.get('scaleX'),
                            maskHeight = item.get('height') * item.get('scaleY'),
                            scaleX = maskedLayer.get('scaleX'),
                            scaleY = maskedLayer.get('scaleY'),
                            width = maskedLayer.get('width') * scaleX,
                            height = maskedLayer.get('height') * scaleY,
                            newWidth = width,
                            newHeight = height;
                        if (width < maskWidth || height < maskHeight) {
                            if ((width / height) > (maskWidth / maskHeight)) {
                                newHeight = maskHeight;
                                newWidth = width / height * newHeight;
                            } else {
                                newWidth = maskWidth;
                                newHeight = height / width * newWidth;
                            }
                        }
                        maskedLayer.set({
                            left: maskLeft + maskWidth / 2,
                            top: maskTop + maskHeight / 2,
                            scaleX: newWidth / maskedLayer.get('width'),
                            scaleY: newHeight / maskedLayer.get('height')
                        });
                        maskedLayer.setCoords();
                    }
                }
            }

            if (obj.type == 'activeSelection') {
                if (context == 'at') {
                    $scope.deactiveAllLayer();
                    obj.forEachObject(function (o) {
                        if (!!o.get('maskId')) adjustMaskedLayer(o, obj);
                    });
                }
            } else {
                adjustMaskedLayer(obj);
            }
        };
        $scope.updateAssociateLayer = function (item) {
            if (item) {
                var d = new Date(),
                    t = d.getTime();
                /*advanced*/
                if (typeof udc_nbd_js_config != 'undefined') {
                    if ($scope.stages[$scope.currentStage].states.coordinates.lastCheck == 'undefined') {
                        item.setCoords();
                        $scope.updateCoordenatesLabel(item);
                        $scope.updateBoundingRect(item);
                        $scope.updateSnapLines();
                        $scope.updateUploadZone(item);
                        $scope.updateApp();
                        return;
                    }
                }
                if ($scope.stages[$scope.currentStage].states.coordinates.lastCheck < (t - 20)) {
                    item.setCoords();
                    $scope.stages[$scope.currentStage].states.coordinates.lastCheck = t;
                    $scope.updateCoordenatesLabel(item);
                    $scope.updateBoundingRect(item);
                    $scope.snapTo(item);
                    $scope.updateSnapLines();
                    $scope.updateUploadZone(item);
                    $scope.updateApp();
                }
            }
        };
        $scope.snapLayer = function (item) {
            if (item) {
                var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                    stage = $scope.stages[$scope.currentStage],
                    left = item.get('left'),
                    top = item.get('top'),
                    translateLeft = 0,
                    translateTop = 0,
                    threshold = 4,
                    scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                var bound = item.getBoundingRect(true);
                switch ($scope.settings.snapMode.type) {
                    case 'layer':
                        _canvas.forEachObject(function (obj) {
                            if (obj === item) return;
                            var _bound = obj.getBoundingRect(true);
                            if (Math.abs(bound.left - _bound.left) < threshold) {
                                translateLeft = bound.left - _bound.left;
                            }
//                        if(Math.abs(bound.left + bound.width - _bound.left) < 1){
//                            if( Math.abs(bound.left + bound.width - _bound.left) < Math.abs(translateLeft)  ) translateLeft = bound.left + bound.width - _bound.left;
//                        }
//                        if(Math.abs(bound.left - _bound.left - _bound.width) < 1){
//                            if( Math.abs(bound.left - _bound.left - _bound.width) < Math.abs(translateLeft)  ) translateLeft = bound.left - _bound.left - _bound.width;
//                        }
//                        if(Math.abs(bound.left + bound.width - _bound.left - _bound.width) < 1){
//                            if( Math.abs(bound.left + bound.width - _bound.left - _bound.width) < Math.abs(translateLeft)  ) translateLeft = bound.left + bound.width - _bound.left - _bound.width;
//                        }
//                        if(Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < 1){
//                            if( Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < Math.abs(translateLeft)  ) translateLeft = bound.left + bound.width / 2 - _bound.left - _bound.width / 2;
//                        }


//                        if(Math.abs(bound.top - _bound.top) < 1)  position.ht.top = _bound.top;
//                        if(Math.abs(bound.top + bound.height - _bound.top) < 1) position.ht.top = _bound.top;
//                        if(Math.abs(bound.top - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
//
//                        if(Math.abs(bound.top + bound.height - _bound.top - _bound.height) < 1)  position.hb.top = _bound.top + _bound.height;
//
//                        if(Math.abs(bound.top + bound.height / 2 - _bound.top - _bound.height / 2) < 1) position.hc.top = _bound.top + _bound.height / 2;
                        });
                        item.set({
                            left: item.left - translateLeft
                        });
                        break;
                    case 'bounding':
                        if (Math.abs(bound.left - _canvas.width) < threshold) {
                            translateLeft = (bound.left - _canvas.width) / scale;
                        } else if (Math.abs(bound.left + bound.width - _canvas.width) < threshold) {
                            translateLeft = (_canvas.width - bound.width - bound.left) / scale;
                        } else if (Math.abs(item.left) < threshold) {
                            translateLeft = item.left;
                        }
//                    if(  Math.abs( bound.top - _canvas.height ) < threshold ){
//                        translateTop = ( bound.top - _canvas.height ) / scale;
//                    }else if( Math.abs( bound.top + bound.height - _canvas.height ) < threshold ){
//                        translateTop = ( _canvas.height - bound.height) / scale;
//                    }else if( Math.abs( item.top ) < threshold ){
//                        translateTop = item.top;
//                    }
                        break;
                    case 'grid':
                        var grid = 10;
                        if ((item.left * scale - Math.round(item.left * scale / grid) * grid) < threshold) {
                            item.set({
                                left: Math.round(item.left * scale / grid) * grid / scale
                            });
                            item.setCoords();
                        }
                        if ((item.top * scale - Math.round(item.top * scale / grid) * grid) < threshold) {
                            item.set({
                                top: Math.round(item.top * scale / grid) * grid / scale
                            });
                            item.setCoords();
                        }
                        break;
                }
//            if( $scope.settings.snapMode == 'layer' || $scope.settings.snapMode == 'bounding' ){
//                item.set({
//                    left: item.left - translateLeft,
//                    top: item.top - translateTop
//                });
//                item.setCoords();
//                console.log(item.getBoundingRect(true));
//                console.log(item.width * item.scaleX);
//            }
            }
            $scope.afterObjectModify();
        };
        $scope.updateUploadZone = function (item) {
            var type = item.get('type'),
                elementUpload = item.get('elementUpload');
            if ((type == 'image' || type == 'custom-image') && elementUpload) {
                angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {
                    visibility: 'visible',
                    top: item.oCoords.tl.y - 1,
                    left: item.oCoords.tl.x - 1,
                    width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2)) + 2,
                    height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2)) + 2,
                    transform: "rotate(" + item.angle + "deg)"
                });
            } else {
                angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'});
            }
        };
        $scope.updateMaskZone = function (item) {
            var type = item.get('type'),
                isMask = item.get('isMask');
            if (isMask) {

            }
        };
        $scope.updateAngleLabel = function (item) {
            if (item) {
                angular.merge($scope.stages[$scope.currentStage].states.rotate, {
                    style: {
                        transform: "rotate(" + item.angle + "deg)",
                        top: item.oCoords.mtr.y,
                        left: item.oCoords.mtr.x,
                        visibility: 'visible'
                    },
                    angle: fabric.util.toFixed(item.angle, 0)
                });
            } else {
                angular.merge($scope.stages[$scope.currentStage].states.rotate, {style: {visibility: 'hidden'}});
            }
        };
        $scope.updateCoordenatesLabel = function (item) {
            if (item && !item.isImageCropper) {
                var top = item.oCoords.tl.y,
                    left = item.oCoords.tl.x;
                if ((item.angle > 315 && item.angle < 360) || (item.angle > 45 && item.angle < 90)
                    || (item.angle > 135 && item.angle < 180) || (item.angle > 225 && item.angle < 270)) {
                    if (item.oCoords.tr.x < left) {
                        top = item.oCoords.tr.y;
                        left = item.oCoords.tr.x;
                    }
                    if (item.oCoords.br.x < left) {
                        top = item.oCoords.br.y;
                        left = item.oCoords.br.x;
                    }
                    if (item.oCoords.bl.x < left) {
                        top = item.oCoords.bl.y;
                        left = item.oCoords.bl.x;
                    }
                } else {
                    if (item.oCoords.tr.y < top) {
                        top = item.oCoords.tr.y;
                        left = item.oCoords.tr.x;
                    }
                    if (item.oCoords.br.y < top) {
                        top = item.oCoords.br.y;
                        left = item.oCoords.br.x;
                    }
                    if (item.oCoords.bl.y < top) {
                        top = item.oCoords.bl.y;
                        left = item.oCoords.bl.x;
                    }
                }
                angular.merge($scope.stages[$scope.currentStage].states.coordinates, {
                    style: {
                        visibility: 'visible',
                        top: top,
                        left: left
                    },
                    top: parseInt(top),
                    left: parseInt(left)
                });
            }
        };
        $scope.updateBoundingRect = function (item) {
            var stage = $scope.stages[$scope.currentStage];
            if (item && !item.isImageCropper) {
                angular.merge(stage.states.boundingObject, {
                    visibility: 'visible',
                    top: item.oCoords.tl.y - 1,
                    left: item.oCoords.tl.x - 1,
                    width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2)) + 2,
                    height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2)) + 2,
                    transform: "rotate(" + item.angle + "deg)"
                });
                /*advanced*/
                if (typeof ggct_nbd_js_config_design != "undefined") {
                    if (item.type == 'image') {
                        angular.merge(stage.states.boundingObject, {
                            'src': item.src
                        });
                    }
                }
                stage.states.boundingRealSize = {
                    size: (item.width * item.scaleX / stage.config.cwidth * stage.config.pWidth).toFixed(2) + 'x' + (item.height * item.scaleY / stage.config.cheight * stage.config.pHeight).toFixed(2) + '' + $scope.settings.nbdesigner_dimensions_unit,
                    transform: (item.angle > 270 || item.angle < 90) ? "rotate(0deg)" : "rotate(180deg)"
                };
                if (typeof custom_richard == 'undefined') {
                    /*advanced*/
                    stage.states.boundingRealSize = {
                        size: (item.width * item.scaleX / stage.config.cwidth * stage.config.pWidth).toFixed(2) + 'x' + (item.height * item.scaleY / stage.config.cheight * stage.config.pHeight).toFixed(2) + '' + $scope.settings.nbdesigner_dimensions_unit,
                        transform: (item.angle > 270 || item.angle < 90) ? "rotate(0deg)" : "rotate(180deg)"
                    };
                }
                if (typeof custom_richard != 'undefined') {
                    /*advanced*/
                    var top = item.oCoords.tl.y,
                        left = item.oCoords.tl.x;
                    if ((item.angle > 315 && item.angle < 360) || (item.angle > 45 && item.angle < 90)
                        || (item.angle > 135 && item.angle < 180) || (item.angle > 225 && item.angle < 270)) {
                        if (item.oCoords.tr.x < left) {
                            top = item.oCoords.tr.y;
                            left = item.oCoords.tr.x;
                        }
                        if (item.oCoords.br.x < left) {
                            top = item.oCoords.br.y;
                            left = item.oCoords.br.x;
                        }
                        if (item.oCoords.bl.x < left) {
                            top = item.oCoords.bl.y;
                            left = item.oCoords.bl.x;
                        }
                    } else {
                        if (item.oCoords.tr.y < top) {
                            top = item.oCoords.tr.y;
                            left = item.oCoords.tr.x;
                        }
                        if (item.oCoords.br.y < top) {
                            top = item.oCoords.br.y;
                            left = item.oCoords.br.x;
                        }
                        if (item.oCoords.bl.y < top) {
                            top = item.oCoords.bl.y;
                            left = item.oCoords.bl.x;
                        }
                    }
                    angular.merge($scope.stages[$scope.currentStage].states.coordinates, {
                        style: {
                            visibility: 'visible',
                            top: top + 15,
                            left: left + item.width * stage.config.pWidth / stage.config._width / 2 + 120,
                            fontSize: '16px'
                        },
                        left: 'Mitte:',
                        top: Math.round(left * stage.config.pWidth / stage.config.width + item.width * stage.config.pWidth / stage.config._width / 2) + " " + $scope.settings.nbdesigner_dimensions_unit
                    });
                    $scope.mitte = Math.round(left * stage.config.pWidth / stage.config.width + item.width * stage.config.pWidth / stage.config._width / 2) + " " + $scope.settings.nbdesigner_dimensions_unit;
                    document.cookie = "mitte=" + $scope.mitte + ";path=/";
                }
                $scope.updateApp();
            } else {
                angular.merge(stage.states.boundingObject, {visibility: 'hidden'});
                angular.merge(stage.states.coordinates, {visibility: 'hidden'});
            }
        };
        $scope.updateCorners = function () {
            if (checkMobileDevice()) return;
            var stage = $scope.stages[$scope.currentStage];
            stage.states.corners = [];

            function getCornerCursor(corner) {
                if (corner === 'mtr') {
                    return 'crosshair';
                } else {
                    var cursorOffset = {
                            mt: 0,
                            tr: 1,
                            mr: 2,
                            br: 3,
                            mb: 4,
                            bl: 5,
                            ml: 6,
                            tl: 7
                        },
                        cursorMap = [
                            'n-resize',
                            'ne-resize',
                            'e-resize',
                            'se-resize',
                            's-resize',
                            'sw-resize',
                            'w-resize',
                            'nw-resize'
                        ],
                        n = Math.round((item.angle % 360) / 45);
                    if (n < 0) {
                        n += 8;
                    }
                    n += cursorOffset[corner];
                    n %= 8;
                    return cursorMap[n];
                }
            }

            var item = stage.canvas.getActiveObject();
            if (item) {
                var controls = item.get('_controlsVisibility');
                var items = stage.canvas.getActiveObjects();
                if (controls || items.length) {
                    var canvasWidth = stage.config.width * stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                        canvasHeight = stage.config.height * stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                    ['tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'].forEach(function (control) {
                        if ((controls && controls[control]) || items.length) {
                            if (item.oCoords[control]) {
                                var _style = {
                                    left: item.oCoords[control].x - fabric.Object.prototype.cornerSize / 2,
                                    top: item.oCoords[control].y - fabric.Object.prototype.cornerSize / 2,
                                    width: fabric.Object.prototype.cornerSize,
                                    height: fabric.Object.prototype.cornerSize,
                                    cursor: getCornerCursor(control)
                                };
                                if (item.oCoords[control].x < 0 || item.oCoords[control].x > canvasWidth || item.oCoords[control].y < 0 || item.oCoords[control].y > canvasHeight) {
                                    stage.states.corners.push({
                                        type: control,
                                        style: _style
                                    })
                                }
                            }
                        }
                    });
                    if (stage.states.corners.length) {
                        stage.states.corners.push({
                            type: '',
                            style: {
                                top: item.oCoords.tl.y - 1,
                                left: item.oCoords.tl.x - 1,
                                width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2)) + 2,
                                height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2)) + 2,
                                transform: "rotate(" + item.angle + "deg)"
                            }
                        })
                    }
                }
            }

            $scope.updateApp();
        };
        $scope.snapTo = function (item) {
            if (!$scope.settings.snapMode.status) {
                return;
            }
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (item) {
                var bound = item.getBoundingRect();
                _canvas.forEachObject(function (obj) {
                    if (obj === item) return;
                    var _bound = obj.getBoundingRect();
                    if (Math.abs(bound.left - _bound.left) < 1) {
                        item.set({
                            lockMovementX: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementX: false
                            });
                        }, SNAP_TIMER);
                        return;
                    } else if (Math.abs(bound.left + bound.width - _bound.left) < 1) {
                        item.set({
                            lockMovementX: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementX: false
                            });
                        }, SNAP_TIMER);
                    } else if (Math.abs(bound.left - _bound.left - _bound.width) < 1) {
                        item.set({
                            lockMovementX: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementX: false
                            });
                        }, SNAP_TIMER);
                    } else if (Math.abs(bound.top - _bound.top) < 1) {
                        item.set({
                            lockMovementY: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementY: false
                            });
                        }, SNAP_TIMER);
                    } else if (Math.abs(bound.top + bound.height - _bound.top) < 1) {
                        item.set({
                            lockMovementY: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementY: false
                            });
                        }, SNAP_TIMER);
                    } else if (Math.abs(bound.top - _bound.top - _bound.height) < 1) {
                        item.set({
                            lockMovementY: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementY: false
                            });
                        }, SNAP_TIMER);
                    } else if (Math.abs(bound.left + bound.width - _bound.left - _bound.width) < 1) {
                        item.set({
                            lockMovementX: true
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementX: false
                            });
                        }, SNAP_TIMER);
                        return;
                    } else if (Math.abs(bound.top + bound.height - _bound.top - _bound.height) < 1) {
                        item.set({
                            lockMovementY: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementY: false
                            });
                        }, SNAP_TIMER);
                    } else if (Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < 1) {
                        item.set({
                            lockMovementX: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementX: false
                            });
                        }, SNAP_TIMER);
                    } else if (Math.abs(bound.top + bound.height / 2 - _bound.top - _bound.height / 2) < 1) {
                        item.set({
                            lockMovementY: true,
                        });
                        setTimeout(() => {
                            item.set({
                                lockMovementY: false
                            });
                        }, SNAP_TIMER);
                    }
                });
                if (Math.abs(bound.left + bound.width / 2 - _canvas.width / 2) < 1) {
                    item.set({
                        lockMovementX: true,
                    });
                    setTimeout(() => {
                        item.set({
                            lockMovementX: false
                        });
                    }, SNAP_TIMER);
                }
                if (Math.abs(bound.top + bound.height / 2 - _canvas.height / 2) < 1) {
                    item.set({
                        lockMovementY: true,
                    });
                    setTimeout(() => {
                        item.set({
                            lockMovementY: false
                        });
                    }, SNAP_TIMER);
                    return;
                }

                if (Math.abs(bound.left) < 1) {
                    item.set({
                        lockMovementX: true,
                    });
                    setTimeout(() => {
                        item.set({
                            lockMovementX: false
                        });
                    }, SNAP_TIMER);
                    return;
                }
                if (Math.abs(bound.top) < 1) {
                    item.set({
                        lockMovementY: true,
                    });
                    setTimeout(() => {
                        item.set({
                            lockMovementY: false
                        });
                    }, SNAP_TIMER);
                    return;
                }
                if (Math.abs(bound.left + bound.width - _canvas.width) < 1) {
                    item.set({
                        lockMovementX: true,
                    });
                    setTimeout(() => {
                        item.set({
                            lockMovementX: false
                        });
                    }, SNAP_TIMER);
                    return;
                }
                if (Math.abs(bound.top + bound.height - _canvas.height) < 1) {
                    item.set({
                        lockMovementY: true,
                    });
                    setTimeout(() => {
                        item.set({
                            lockMovementY: false
                        });
                    }, SNAP_TIMER);
                    return;
                }
            }
        }
        $scope.updateSnapLines = function () {
            var _canvas = this.stages[$scope.currentStage]['canvas'],
                item = _canvas.getActiveObject(),
                position = {
                    ht: {top: -9999},
                    hb: {top: -9999},
                    hc: {top: -9999},
                    vl: {left: -9999},
                    vr: {left: -9999},
                    vc: {left: -9999},
                    hcc: {top: -9999},
                    vcc: {left: -9999},
                    vel: {left: -9999},
                    ver: {left: -9999},
                    het: {top: -9999},
                    heb: {top: -9999}
                };
            if (item) {
                var bound = item.getBoundingRect();
                _canvas.forEachObject(function (obj) {
                    if (obj === item) return;
                    var _bound = obj.getBoundingRect();
                    if (Math.abs(bound.left - _bound.left) < 1) position.vl.left = _bound.left;
                    if (Math.abs(bound.left + bound.width - _bound.left) < 1) position.vr.left = _bound.left;
                    if (Math.abs(bound.left - _bound.left - _bound.width) < 1) position.vl.left = _bound.left + _bound.width;
                    if (Math.abs(bound.top - _bound.top) < 1) position.ht.top = _bound.top;
                    if (Math.abs(bound.top + bound.height - _bound.top) < 1) position.ht.top = _bound.top;
                    if (Math.abs(bound.top - _bound.top - _bound.height) < 1) position.hb.top = _bound.top + _bound.height;
                    if (Math.abs(bound.left + bound.width - _bound.left - _bound.width) < 1) position.vr.left = _bound.left + _bound.width;
                    if (Math.abs(bound.top + bound.height - _bound.top - _bound.height) < 1) position.hb.top = _bound.top + _bound.height;
                    if (Math.abs(bound.left + bound.width / 2 - _bound.left - _bound.width / 2) < 1) position.vc.left = _bound.left + _bound.width / 2;
                    if (Math.abs(bound.top + bound.height / 2 - _bound.top - _bound.height / 2) < 1) position.hc.top = _bound.top + _bound.height / 2;
                });
                if (Math.abs(bound.left + bound.width / 2 - _canvas.width / 2) < 1) position.vcc.left = _canvas.width / 2;
                if (Math.abs(bound.top + bound.height / 2 - _canvas.height / 2) < 1) position.hcc.top = _canvas.height / 2;

                if (Math.abs(bound.left) < 1) position.vel.left = 0;
                if (Math.abs(bound.top) < 1) position.het.top = 0;
                if (Math.abs(bound.left + bound.width - _canvas.width) < 1) position.ver.left = _canvas.width;
                if (Math.abs(bound.top + bound.height - _canvas.height) < 1) position.heb.top = _canvas.height;

                angular.merge($scope.stages[$scope.currentStage].states.snaplines, position);
            }
        };
        $scope.updateWarning = function (item) {
            if ($scope.settings.showWarning.oos) {
                var stage = $scope.stages[$scope.currentStage];
                var _canvas = stage['canvas'],
                    bound = item.getBoundingRect();
                if (bound.left < 0 || bound.top < 0 || (bound.left + bound.width) > (_canvas.width) || (bound.top + bound.height) > (_canvas.height)) {
                    stage.states.oos = true;
                } else {
                    stage.states.oos = false;
                }
                $scope.updateApp();
            }
        };
        $scope.onObjectModified = function (id, options) {
            var item = options.target;
            var newAngle = item.angle;
            newAngle = (Math.abs(item.angle - 0) <= 1 || Math.abs(item.angle - 360) <= 1) ? 0 : (Math.abs(item.angle - 180) <= 1 ? 180 : newAngle);
            item.set({angle: newAngle, dirty: true});
            /*if( $scope.stages[$scope.currentStage].tempParameters ){
            $scope.setHistory({
                element: item,
                parameters: $scope.stages[$scope.currentStage].tempParameters,
                interaction: 'modify'
            });
            $scope.stages[$scope.currentStage].tempParameters = null;
        }*/
            $scope.setHistory($scope.currentStage, true);
            if ($scope.stages[$scope.currentStage].states.isText && $scope.stages[$scope.currentStage].states.type != 'curvedText' && NBDESIGNCONFIG.nbdesigner_enable_text_free_transform == 'no') {
                var newFontSize = item.fontSize * item.scaleX;
                var initialScaleX = item.scaleX;
                var newPtFontSize = newFontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont;
                var minSize = arrayMin($scope.listFontSizeInPt),
                    maxSize = arrayMax($scope.listFontSizeInPt);
                if ($scope.forceMinSize && minSize > newPtFontSize) {
                    newPtFontSize = minSize;
                    newFontSize = newPtFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
                }
                if ($scope.forceMaxSize && maxSize < newPtFontSize) {
                    newPtFontSize = maxSize;
                    newFontSize = newPtFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
                }
                newPtFontSize = newPtFontSize.toFixed(2);
                item.set({
                    dirty: true,
                    scaleX: 1,
                    scaleY: 1,
                    fontSize: newFontSize,
                    ptFontSize: newPtFontSize,
                    width: item.width * initialScaleX
                });
                if (item.styles && Object.keys(item.styles).length) {
                    let updatedStyles = {...item.styles};
                    for (const line of Object.keys(updatedStyles)) {
                        for (const char of Object.keys(updatedStyles[line])) {
                            const charStyles = updatedStyles[line][char];
                            if (charStyles.hasOwnProperty('fontSize')) {
                                updatedStyles[line][char].fontSize = Number(
                                    parseInt(charStyles.fontSize, 10) * initialScaleX
                                ).toFixed(2);
                            }
                        }
                    }
                    item.set({
                        styles: updatedStyles
                    });
                }
                $scope.stages[$scope.currentStage].states.text.fontSize = newFontSize;
                $scope.stages[$scope.currentStage].states.text.ptFontSize = newPtFontSize;
            }

            $scope.updateWarning(item);
            $scope.stageDesignChanged();

            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage['canvas'];
            $scope.originPDFs[$scope.currentStage] = [];
            _canvas.forEachObject(function (obj, index) {
                if (angular.isDefined(obj.origin_pdf)) {
                    $scope.originPDFs[$scope.currentStage].push({
                        index: index,
                        origin_pdf: obj.origin_pdf,
                        top: obj.oCoords.tl.y / _stage.config.cheight * _stage.config.pHeight,
                        left: obj.oCoords.tl.x / _stage.config.cwidth * _stage.config.pWidth,
                        width: obj.width * obj.scaleX / _stage.config.cwidth * _stage.config.pWidth,
                        height: obj.height * obj.scaleY / _stage.config.cheight * _stage.config.pHeight
                    });
                }
            });
            $scope.updateLayerPositionObject(item);
        };
        $scope.updateLayerPositionObject = function (item) {
            if (!item) {
                return;
            }
            const {top, left, offsetX, offsetY} = item;
            const width = item.getScaledWidth();
            const height = item.getScaledHeight();
            $scope.layerPosition = {
                x: +left.toFixed(2),
                y: +top.toFixed(2),
                w: +width.toFixed(2),
                h: +height.toFixed(2),
                offsetX: offsetX || 0.5,
                offsetY: offsetY || 0.5
            };
        }
        $scope.toggleLayerLock = function (e) {
            e.stopPropagation();
            const canvas = $scope.getCurrentStageCanvas();
            const activeObjects = canvas.getActiveObjects();
            if (!activeObjects || !activeObjects.length) {
                return;
            }
            activeObjects.forEach((o) => {
                const index = $scope.getLayerById(o.itemId);
                if (index === 'undefined') {
                    return;
                }
                const item = canvas.item(index);
                if (!item) {
                    return;
                }
                $scope.setLayerAttribute('selectable', !item.selectable, index, index);
            });

        }
        $scope.isActiveLayer = function (layer) {
            if (!layer) {
                return false;
            }
            if ($scope.stages[$scope.currentStage].states.isLayer && $scope.stages[$scope.currentStage].states.itemId == layer.itemId) {
                return true;
            } else if (!$scope.stages[$scope.currentStage].states.isLayer && $scope.stages[$scope.currentStage].states.activeIds) {
                return $scope.stages[$scope.currentStage].states.activeIds.includes(layer.itemId);
            }
            return false;
        }
        $scope.updateTextPxFontSize = function (item) {
            var textTypes = ['i-text', 'text', 'textbox'],
                itemType = item.get('type');
            if (textTypes.indexOf(itemType) > -1) {
                /*advanced*/
                if (typeof udc_nbd_js_config != 'undefined') {
                    if (NBDESIGNCONFIG.nbdesigner_enable_text_free_transform == 'no') {
                        var newFontSize = item.fontSize * item.scaleX;
                        var lastScaleX = item.scaleX;
                        var newPtFontSize = newFontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont;
                        newPtFontSize = newPtFontSize.toFixed(2);
                        item.set({
                            dirty: true,
                            scaleX: 1,
                            scaleY: 1,
                            fontSize: newFontSize,
                            ptFontSize: newPtFontSize,
                            width: item.width * lastScaleX
                        });
                    }
                    return;
                }
                if (NBDESIGNCONFIG.nbdesigner_enable_text_free_transform == 'no') {
                    var lastScaleX = item.scaleX,
                        ptFontSize = item.ptFontSize,
                        newFontSize = ptFontSize * $scope.stages[$scope.currentStage].states.ratioConvertFont;
                    item.set({
                        dirty: true,
                        fontSize: newFontSize,
                    });
                }
            }
        };
        $scope.onBeforeRender = function (id, options) {
        };
        $scope.onAfterRender = function (id, options) {
            /*Edit field option visual design*/
            if (typeof bdesign_customize_visual_option != "undefined") {
                jQuery("#sortable").sortable({
                    containment: '#sortable',
                    stop: function (event, ui) {
                        var srcIndex = jQuery(this).attr('data-prev-index'),
                            oldIndex = jQuery(this).attr('data-previndex'),
                            newIndex = ui.item.index(),
                            dstIndex = 0;
                        if (oldIndex > newIndex) {
                            dstIndex = jQuery(ui.item).next().attr('data-index')
                        } else {
                            dstIndex = jQuery(ui.item).prev().attr('data-index')
                        }
                        ;
                        jQuery(this).removeAttr('data-previndex');
                        jQuery(this).removeAttr('data-prev-index');
                        $scope.sortLayer(srcIndex, dstIndex);
                    },
                    start: function (e, ui) {
                        jQuery(this).attr('data-prev-index', jQuery(ui.item).attr('data-index'));
                        jQuery(this).attr('data-previndex', ui.item.index());
                    },
                });
            }
            const stage = $scope.stages[id];
            if (!stage) return;
            const _canvas = stage['canvas'];

            function checkLayerById(id) {
                var check = false;
                _canvas.forEachObject(function (obj) {
                    if (obj.get('itemId') == id) check = true;
                });
                return check;
            }

            $scope.stages[$scope.currentStage].states.lostCharLayers = $scope.stages[$scope.currentStage].states.lostCharLayers.filter(function (layerId) {
                return checkLayerById(layerId);
            });
        };
        $scope.onSelectionCleared = function (id, options) {
            $scope.stages[$scope.currentStage].states.activeIds = [];
            $scope.clearMovableMasks();
            $scope.stages[$scope.currentStage].states.isActiveLayer = false;
            $scope.stages[$scope.currentStage].states.itemId = null;
            $scope.stages[$scope.currentStage].states.isEditing = false;
            angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'});
            $scope.stages[$scope.currentStage].states.elementUpload = false;
            $scope.stages[$scope.currentStage].states.oos = false;
            $scope.stages[$scope.currentStage].states.ilr = false;
            $scope.updateMaskLayer();
        };
        $scope.onEditingEntered = function (id, options) {
            $scope.stages[$scope.currentStage].states.isEditing = true;
            $scope.updateApp();
        };
        $scope.onEditingExited = function (id, options) {
            $scope.stages[$scope.currentStage].states.isEditing = false;
            var item = options.target;
            if (item) {
                $scope.updateLayersList();
            }
            $scope.updateApp();
        };
        $scope.onSelectionChanged = function (id, options) {
            $scope.getCurrentLayerInfo();
            var item = options.target;
            $scope.updateUploadZone(item);
            $scope.updateWarning(item);
            if ($scope.stages[$scope.currentStage].states.isGroup) {
                $scope.stages[$scope.currentStage].states.ilr = false;
            } else if (($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && NBDESIGNCONFIG.nbdesigner_clipart_rotate == '0') {
                $scope.hideRotateControl(item);
            }
            if ($scope.stages[$scope.currentStage].states.isMask) {
                $scope.hideRotateControl(item);
            }
            if (item.type === 'textbox') {
                const fonts = $scope.getSelectionFonts(item);
                if (fonts.length > 1) {
                    $scope.stages[$scope.currentStage].states.text['hasMultipleFonts'] = true;
                } else {
                    $scope.stages[$scope.currentStage].states.text['hasMultipleFonts'] = false;
                    if (fonts[0]) {
                        $scope.stages[$scope.currentStage].states.text['font'] = $scope.getFontInfo(fonts[0]);
                    }
                }
            }
            if (item.type === 'activeSelection' || item.type === 'group') {
                $scope.makeActiveSelectionMasksMovable(item);
            }
        };
        $scope.onSelectionUpdated = function (id, options) {
            $scope.stages[$scope.currentStage].states.isGrouppedSelection = false;
            var item = options.target;
            $scope.clearMovableMasks();
            if (item.type === 'textbox' || item.type === 'i-text' || item.type === 'text' || item.type === 'curvedText') {
                $scope.stages[$scope.currentStage].states.text = {
                    font: $scope.getFontInfo(item.get('fontFamily')),
                    is_uppercase: $scope.isUpperCase(item),
                    hasMultipleFonts: $scope.getFontsCount(item) > 1,
                    charSpacing: item.charSpacing || 0,
                    spacing: item.spacing || 0,
                    lineHeight: item.lineHeight || 1.4,
                    strokeWidth: item.strokeWidth || 0,
                    radius: item.radius || 100
                };
            }
            $scope.stages[$scope.currentStage].states.linearGradientAngle = item.get('linearGradientAngle') || 0;
            $scope.getCurrentLayerInfo();
            $scope.updateUploadZone(options.target);
            $scope.updateWarning(options.target);
            if ($scope.stages[$scope.currentStage].states.isGroup) {
                $scope.stages[$scope.currentStage].states.ilr = false;
            }
            if (item.type === 'image' && $scope.imageSelectionMask) {
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'];
                _canvas.remove(item);
                _canvas.setActiveObject($scope.imageSelectionMask);
                const maskId = $scope.imageSelectionMask.get('maskId');
                const src = item.getSrc();
                $scope.addImage({src, url: src}, false, false, false, false, maskId);
                return;
            }
            if (($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && NBDESIGNCONFIG.nbdesigner_clipart_rotate == '0') {
                if (!!item.get('itemId')) $scope.hideRotateControl(item);
            }
            if ($scope.stages[$scope.currentStage].states.isMask) {
                if (!!item.get('itemId')) $scope.hideRotateControl(item);
            } else {
                if (!!item.get('itemId')) $scope.updateMaskLayer(item);
            }

            if (GRADIENT_AWARE_TYPES.includes(item.type)) {
                GRADIENT_AWARE_SHAPES.includes(item.type) ?
                    $scope.setCurrentShapeGradientColor(item) :
                    $scope.setCurrentTextGradientColor(item);
                $scope.handleGradientColor(item);
            }
            $scope.applyStrokeColor(item.stroke);
            $scope.applyStrokeWidth(item.strokeWidth);
            $scope.applyShapeBorderRadius(item.borderRadius || {radius: item.rx});
            $scope.applyImageBorderRadius(item.borderRadius);
            $scope.applyShadowColor(item.shadow);
            $scope.updateLayerPositionObject(item);
        };
        $scope.onSelectionCreated = function (id, options) {
            $scope.stages[$scope.currentStage].states.isGrouppedSelection = false;
            var item = options.target;
            $scope.clearMovableMasks();
            if (item.type === 'textbox' || item.type === 'i-text' || item.type === 'text' || item.type === 'curvedText') {
                $scope.stages[$scope.currentStage].states.text = {
                    font: $scope.getFontInfo(item.get('fontFamily')),
                    is_uppercase: $scope.isUpperCase(item),
                    hasMultipleFonts: $scope.getFontsCount(item) > 1,
                    charSpacing: item.charSpacing || 0,
                    spacing: item.spacing || 0,
                    lineHeight: item.lineHeight || 1.4,
                    strokeWidth: item.strokeWidth || 0,
                    radius: item.radius || 100
                };
            }
            $scope.stages[$scope.currentStage].states.linearGradientAngle = item.get('linearGradientAngle') || 0;
            $scope.getCurrentLayerInfo();
            $scope.updateUploadZone(options.target);
            $scope.updateWarning(options.target);
            $scope.toggleTip();
            $scope.updateMaskLayer(item);
            if (($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isPath) && NBDESIGNCONFIG.nbdesigner_clipart_rotate == '0') {
                $scope.hideRotateControl(item);
            }
            if ($scope.stages[$scope.currentStage].states.isMask) {
                $scope.hideRotateControl(item);
            }
            if (item.type === 'activeSelection' || item.type === 'group') {
                $scope.makeActiveSelectionMasksMovable(item);
            }

            if (GRADIENT_AWARE_TYPES.includes(item.type)) {
                GRADIENT_AWARE_SHAPES.includes(item.type) ?
                    $scope.setCurrentShapeGradientColor(item) :
                    $scope.setCurrentTextGradientColor(item);
                $scope.handleGradientColor(item);
            }
            $scope.applyStrokeColor(item.stroke);
            $scope.applyStrokeWidth(item.strokeWidth);
            $scope.applyShapeBorderRadius(item.borderRadius || {radius: item.rx});
            $scope.applyImageBorderRadius(item.borderRadius);
            $scope.applyShadowColor(item.shadow);
            $scope.updateLayerPositionObject(item);
        };
        $scope.hideRotateControl = function (item) {
            if (item != null) {
                item.set({hasRotatingPoint: false});
            }
        };
        $scope.onTextChanged = function (id, options) {
            var item = options.target;
            if (typeof checkBox != "undefined") {
                if (typeof item.valueOfinput != "undefined") {
                    if (typeof item.temporary == "undefined") {
                        item.temporary = "";
                    } else {
                        if (item.text != item.temporary) {
                            item.temporary = item.text;
                            item.text = item.temporary;
                            item.text = item.text.substr(0, item.valueOfinput);
                        }
                    }
                }
                if (item.checkTexBox) {
                    item.text = item.text.toUpperCase();
                }
            }
            if (item) {
                $scope.normalizeText(item);
                if (angular.isDefined(item.field_mapping)) {
                    _.each($scope.stages, function (stage, index) {
                        var _canvas = stage.canvas;
                        _canvas.forEachObject(function (obj) {
                            if (angular.isDefined(obj.field_mapping) && item.field_mapping == obj.field_mapping) {
                                obj.text = item.text;
                            }
                        });
                    });
                }
                if ($scope.settings.nbdesigner_enable_text_check_lang == 'yes') {
                    $scope.checkCharacter(item);
                }
                $scope.updateLayersList();
            }
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});
            $scope.updateApp();
        };
        $scope.normalizeText = function (item) {
            if (!!String.prototype.normalize && item.text) {
                var normalizeText = item.text.normalize();
                if (item.text != normalizeText) {
                    item.text = normalizeText;
                }
            }
        };
        $scope.checkCharacter = function (object) {
            var font = _.filter($scope.resource.font.data, {alias: object.get('fontFamily')})[0];
            var arr = [],
                check = true,
                text = object.text.replace(/\r?\n|\r/gm, ''),
                fontWeight = object.get('fontWeight'),
                fontStyle = object.get('fontStyle'),
                itemId = object.get('itemId'),
                font_url = '';
            if (fontWeight == 'bold') {
                if (fontStyle == 'italic') {
                    font_url = font.file.bi;
                } else {
                    font_url = font.file.b;
                }
            } else {
                if (fontStyle == 'italic') {
                    font_url = font.file.i;
                } else {
                    font_url = font.file.r;
                }
            }
            if (font_url == 1) return;
            if (font.type != 'google') {
                font_url = NBDESIGNCONFIG['font_url'] + font_url;
            } else {
                font_url = font_url.replace('http:', 'https:');
            }
            opentype.load(font_url, function (err, font) {
                if (err) {
                    console.log(err);
                } else {
                    $scope.currentJsFont = font;
                    var glyphs = font.glyphs.glyphs;
                    _.each(glyphs, function (glyph, index) {
                        arr['g-' + glyph.unicode] = 1;
                    });
                    for (var i = 0; i < text.length; i++) {
                        var uc_index = 'g-' + text.charCodeAt(i);
                        if (angular.isUndefined(arr[uc_index])) {
                            check = false;
                        }
                    }
                    var _index = _.findIndex($scope.stages[$scope.currentStage].states.lostCharLayers, function (layerId) {
                        return layerId == itemId;
                    });
                    if (!check) {
                        object.set({lostChar: 1});
                        if (_index == -1) $scope.stages[$scope.currentStage].states.lostCharLayers.push(itemId);
                    } else {
                        delete object.lostChar;
                        if (_index > -1) $scope.stages[$scope.currentStage].states.lostCharLayers.splice(_index, 1);
                    }
                    $scope.updateLayersList();
                }
            });
        };
        $scope.currentJsFont = null;
        /*advanced*/
        if (typeof udc_nbd_js_config != 'undefined') {
            $scope.testopentype = function () {
                var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                    item = _canvas.getActiveObject(),
                    text = item.text,
                    fontSize = item.get('fontSize'),
                    color = item.get('fill'),
                    left = item.get('left'),
                    top = item.get('top'),
                    path = $scope.currentJsFont.getPath(text, 0, 0, fontSize),
                    matches = path.toSVG(6).match(/"(.*?)"/),
                    pathCmd = matches[1],
                    fPath = new fabric.Path(pathCmd, {
                        stroke: 'none',
                        strokeWidth: 0,
                        fill: color,
                        left: left,
                        top: top
                    });
                _canvas.add(fPath);
                $scope.renderStage();
            };
        }
        $scope.onClickDone = function () {
            $scope.stages[$scope.currentStage].states.isShowToolBox = false;
            $scope.updateApp();
            $scope.renderStage();
            jQuery('html,body').animate({
                scrollTop: jQuery("#nbd-vista-app").offset().top
            }, 'slow');
        };
        $scope.canAddMoreLayer = function () {
            $check = true;
            if ($scope.settings.nbdesigner_prevent_add_more_layer == 'yes' && !$scope.isTemplateMode) $check = false;
            return $check;
        }
        $scope.canDeleteLayer = function () {
            $check = true;
            if ($scope.settings.nbdesigner_prevent_delete_template_layer == 'yes' && !$scope.isTemplateMode) $check = false;
            return $check;
        }
        $scope.setPositionToolbox = function () {
            if (appConfig.isModern) return;
            $timeout(function () {
                var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                    object = _canvas.getActiveObject(),
                    objects = _canvas.getActiveObjects();

                var $vista = jQuery('.nbd-vista'),
                    $stageActive = jQuery('.nbd-vista .stage.nbd-active'),
                    $stageMainActive = jQuery('.nbd-vista .stage.nbd-active .stage-main'),
                    $layout = jQuery('.nbd-vista .nbd-layout'),
                    $toolMain = jQuery('.nbd-vista .v-toolbox .nbd-nav-tab[data-tab="tab-main-box"]');

                var bound = object.getBoundingRect(),
                    stage = $scope.stages[$scope.currentStage];

                var ratioScale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                    paddingL = parseInt($stageActive.css('padding-left').slice(0, -2)),
                    paddingT = parseInt($stageActive.css('padding-top').slice(0, -2)),
                    paddingB = parseInt($stageActive.css('padding-bottom').slice(0, -2)),
                    paddingR = parseInt($stageActive.css('padding-right').slice(0, -2)),
                    pLeft = 0,
                    pTop = 0,
                    transform = 'translateX(-50%)',
                    _canvasWidth = _canvas.width,
                    _canvasHeight = _canvas.height,
                    mTop = stage.config.top * ratioScale,
                    mBottom = (stage.config.cheight - stage.config.top - stage.config.height) * ratioScale,
                    mRight = (stage.config.cwidth - stage.config.left - stage.config.width) * ratioScale,
                    mLeft = stage.config.left * ratioScale,
                    boundTop = bound.top + bound.height,
                    boundLeft = bound.left + bound.width,
                    _boundLeft = bound.left + bound.width / 2,
                    scrollXHeight = 5,
                    scrollYWidth = 5,
                    scrollTop = $stageActive.scrollTop(),
                    scrollLeft = $stageActive.scrollLeft();
                $toolMain.each(function (index, value) {
                    jQuery(this).triggerHandler('click');
                });

                if ($stageMainActive.height() > ($stageActive.height() - scrollXHeight)) {
                    if (($stageMainActive.height() - mBottom) > ($stageActive.outerHeight() + scrollTop - paddingT)) {
                        if ((boundTop + mTop) > ($stageActive.outerHeight() + scrollTop)) {
                            pTop = $stageActive.outerHeight();
                        } else {
                            pTop = boundTop + mTop - scrollTop + paddingT;
                        }
                    } else {
                        if (boundTop > _canvas.height) {
                            pTop = $stageMainActive.height() - mBottom - scrollTop + paddingT;
                        } else {
                            pTop = boundTop + mTop - scrollTop + paddingT;
                        }
                    }
                } else {
                    if ((bound.top + bound.height) > _canvas.height) {
                        pTop = _canvas.height + paddingT + mTop;
                    } else {
                        pTop = boundTop + paddingT + mTop;
                    }
                }
                pTop += 7;
                stage.states.toolboxTriangle = 'center';
                if ($stageMainActive.width() > ($stageActive.width() - scrollYWidth)) {
                    if ((_boundLeft + mLeft - scrollLeft + paddingL) < 0) {
                        pLeft = 0;
                        transform = 'translateX(0)';
                    } else if ((_boundLeft + mLeft - scrollLeft + paddingL - $stageActive.outerWidth()) > 0) {
                        pLeft = $stageActive.outerWidth();
                        transform = 'translateX(-100%)';
                    } else {
                        pLeft = _boundLeft + mLeft - scrollLeft + paddingL;
                    }
                } else {
                    if (_boundLeft < 0) {
                        pLeft = ($stageActive.outerWidth() - $stageMainActive.width()) / 2 + mLeft;
                        transform = 'translateX(0)';
                    } else if (_boundLeft > _canvas.width) {
                        pLeft = ($stageActive.outerWidth() - $stageMainActive.width()) / 2 + mLeft + _canvas.width;
                        transform = 'translateX(-100%)';
                    } else {
                        pLeft = ($stageActive.outerWidth() - $stageMainActive.width()) / 2 + mLeft + _boundLeft;
                    }
                }
                pLeft -= 7;
                if (pLeft + 160 > $stageActive.outerWidth()) {
                    pLeft = $stageActive.outerWidth();
                    transform = 'translateX(-100%)';
                }
                ;
                if (pLeft < 160) {
                    transform = 'translateX(0)';
                    pLeft = 0;
                }
                ;
                stage.states.toolboxStyle = {
                    top: pTop,
                    left: pLeft,
                    transform: transform
                };
            });
        };
        $scope.getCurrentLayerInfo = function () {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                object = _canvas.getActiveObject(),
                objects = _canvas.getActiveObjects();
            /*advanced*/
            if (typeof hvc_app_modern_js != "undefined") {
                $scope.stages[$scope.currentStage].states.enableScale = true;
            }
            ['isActiveLayer', 'enableRotate', 'enableOpacity', 'enableChangePathColor', 'enableShadow'].forEach(function (key) {
                $scope.stages[$scope.currentStage].states[key] = true;
            });
            ['isGroup', 'isNativeGroup', 'isLayer', 'isText', 'isImage', 'isPath', 'isShape', 'isEditing', 'isMask', 'isMasked', 'lockMask', 'isEmptyMask', 'isTemMask', 'elementUpload', 'isGroupText', 'srcChanged'].forEach(function (key) {
                $scope.stages[$scope.currentStage].states[key] = false;
            });
            /*advanced*/
            if (typeof udc_nbd_js_config != 'undefined') {
                $scope.stages[$scope.currentStage].states.isBGimage = false;
            }
            if (appConfig.isVisual) $scope.setPositionToolbox();
            if (objects.length > 1) {
                $scope.stages[$scope.currentStage].states.isGroup = true;
                $scope.stages[$scope.currentStage].states.isInGroup = false;
                $scope.stages[$scope.currentStage].states.activeIds = objects.map((o) => o.itemId);
                const textType = ['i-text', 'text', 'textbox', 'curvedText'];
                if (appConfig.isVisual) {
                    _.each(objects, function (item, key) {
                        if (!_.includes(textType, item.get('type'))) {
                            $scope.stages[$scope.currentStage].states.isGroupText = false;
                            return false;
                        }
                    });
                }
                $scope.stages[$scope.currentStage].states.isTextGroup = objects
                    .every((o) => textType.includes(o.type));
                if ($scope.stages[$scope.currentStage].states.isTextGroup) {
                    const fonts = objects.reduce((fonts, o) => {
                        return [...new Set([...fonts, ...$scope.getSelectionFonts(o)])];
                    }, []);
                    if (fonts.length > 1) {
                        $scope.stages[$scope.currentStage].states.text['hasMultipleFonts'] = true;
                    }
                    $scope.stages[$scope.currentStage].states.isTextGroupBoldDisabled = objects.some((o) => {
                        const font = $scope.getFontInfo(o.fontFamily);
                        return !(font.file.b && (o.fontStyle != 'italic' || (o.fontStyle == 'italic' && font.file.bi)));
                    });
                    $scope.stages[$scope.currentStage].states.isTextGroupItalicDisabled = objects.some((o) => {
                        const font = $scope.getFontInfo(o.fontFamily);
                        return !(font.file.i && (o.fontWeight != 'bold' || (o.fontWeight == 'bold' && font.file.bi)));
                    });
                }
            } else {
                if (objects[0] && objects[0].group) {
                    $scope.stages[$scope.currentStage].states.isInGroup = true;
                } else {
                    $scope.stages[$scope.currentStage].states.isInGroup = false;
                }
                $scope.stages[$scope.currentStage].states.isLayer = true;
                if (!objects.length) {
                    $scope.stages[$scope.currentStage].states.activeIds = [];
                } else {
                    $scope.stages[$scope.currentStage].states.activeIds = [];
                    $scope.stages[$scope.currentStage].states.itemId = objects[0].itemId;
                    $scope.updateApp();
                }
                if (object) {
                    if (!object.get('itemId')) {
                        var d = new Date(),
                            itemId = d.getTime() + Math.floor(Math.random() * 1000);
                        object.set({"itemId": itemId});
                    }
                    ['isMask', 'isTemMask', 'srcChanged', 'isEmptyMask', 'lockMask', 'isImageCropper', 'isBgImg'].forEach(function (key) {
                        if (object.get(key)) {
                            $scope.stages[$scope.currentStage].states[key] = true;
                        }
                    });
                    if (!!object.get('maskId')) {
                        $scope.stages[$scope.currentStage].states.isMasked = true;
                    }

                    $scope.stages[$scope.currentStage].states.ilr = angular.isDefined(object.get('ilr')) ? object.get('ilr') : false;
                    $scope.stages[$scope.currentStage].states.forceLock = angular.isDefined(object.get('forceLock')) ? object.get('forceLock') : false;
                    $scope.stages[$scope.currentStage].states.opacity = fabric.util.toFixed(object.get('opacity') * 100);
                    ['type', 'itemId', 'lockMovementX', 'lockMovementY', 'lockScalingX', 'lockScalingY', 'lockRotation', 'lockUniScaling', 'selectable', 'visible', 'angle', 'excludeFromExport', 'field_mapping', 'isQrcode', 'qrContent', 'isBarcode', 'barCodeContent', 'v_card'].forEach(function (key) {
                        var val = object.get(key);
                        if (key == 'angle' && val < 0) {
                            val += 360;
                        }
                        $scope.stages[$scope.currentStage].states[key] = val;
                    });
                    /*Edit field option visual design*/
                    if (typeof bdesign_customize_visual_option != "undefined") {
                        ['hidePhoneEmpty', 'hideMobileEmpty'].forEach(function (key) {
                            var val = object.get(key);
                            $scope.stages[$scope.currentStage].states[key] = val;
                        });
                    }
                    switch (object.type) {
                        case 'i-text':
                        case 'text':
                        case 'textbox':
                        case 'curvedText':
                            $scope.handleGradientColor(object);
                            $scope.stages[$scope.currentStage].states.text = {...$scope.defaultStageStates.text, ...$scope.stages[$scope.currentStage].states.text};
                            $scope.addColor(tinycolor(object.get('fill')).toHexString());
                            $scope.stages[$scope.currentStage].states.isText = true;
                            $scope.stages[$scope.currentStage].states.isEditing = object.isEditing ? object.isEditing : false;
                            $scope.stages[$scope.currentStage].states.fixedWidth = angular.isDefined(object.fixedWidth) ? object.fixedWidth : false;
                            ['fontFamily', 'ptFontSize', 'fontSize', 'editable', 'isList', 'textAlign', 'fontWeight', 'textDecoration', 'fontStyle', 'spacing', 'lineHeight', 'fill', 'charSpacing', 'textBackgroundColor', 'stroke', 'strokeWidth', 'text', 'overline', 'underline', 'linethrough'].forEach(function (key) {
                                $scope.stages[$scope.currentStage].states.text[key] = object.get(key);
                            });
                            if (angular.isUndefined($scope.stages[$scope.currentStage].states.text.ptFontSize)) {
                                $scope.stages[$scope.currentStage].states.text.ptFontSize = ($scope.stages[$scope.currentStage].states.text.fontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont).toFixed(2);
                            }
                            if ($scope.stages[$scope.currentStage].states.text.textBackgroundColor == '') $scope.stages[$scope.currentStage].states.text.textBackgroundColor = '#ffffff';
                            if (!$scope.stages[$scope.currentStage].states.text.stroke) $scope.stages[$scope.currentStage].states.text.stroke = '#ffffff';
                            /*advanced*/
                            if (typeof kvlc_js_cusom != "undefined") {
                                jQuery('#currentFont').text($scope.stages[$scope.currentStage].states.text.font.name);
                                jQuery('#currentFont').css({'font-family': $scope.stages[$scope.currentStage].states.text.font.alias});
                                jQuery('#custom-label').val(object.text);
                                jQuery('#currentFontSize').val($scope.stages[$scope.currentStage].states.text.ptFontSize);
                            }
                            if (object.type == 'curvedText') {
                                ['reverse', 'spacing', 'radius'].forEach(function (key) {
                                    $scope.stages[$scope.currentStage].states.text[key] = object.get(key);
                                });
                                $scope.stages[$scope.currentStage].states.text.rtl = angular.isDefined(object.rtl) ? object.rtl : false;
                                if ($scope.stages[$scope.currentStage].states.text.rtl) {
                                    $scope.stages[$scope.currentStage].states.text.text = $scope.stages[$scope.currentStage].states.text.text.split('').reverse().join('');
                                }
                                ;
                                $timeout(function () {
                                    jQuery('.item-curved').addClass('active');
                                    if ($scope.settings.is_mobile) jQuery('.main-toolbar').addClass('overflow-hidden');
                                }, 300);
                            } else {
                                if ($scope.settings.is_mobile) jQuery('.main-toolbar').removeClass('overflow-hidden');
                            }
                            ;
                            $scope.stages[$scope.currentStage].states.enableRotate = NBDESIGNCONFIG.nbdesigner_text_rotate == '1' ? true : false;
                            $scope.stages[$scope.currentStage].states.enableOpacity = NBDESIGNCONFIG.nbdesigner_text_opacity == '1' ? true : false;
                            $scope.stages[$scope.currentStage].states.enableShadow = (NBDESIGNCONFIG.nbdesigner_text_shadow == '1' && NBDESIGNCONFIG.nbdesigner_enable_cloud2print_api == 'yes') ? true : false;
                            break;
                        case 'image':
                        case 'custom-image':
                            $scope.stages[$scope.currentStage].states.elementUpload = angular.isDefined(object.get('elementUpload')) ? object.get('elementUpload') : false;
                            $scope.stages[$scope.currentStage].states.ilr = angular.isDefined(object.get('ilr')) ? object.get('ilr') : false;
                            $scope.stages[$scope.currentStage].states.isImage = true;
                            $scope.stages[$scope.currentStage].states.src = object.getSvgSrc();
                            $scope.stages[$scope.currentStage].states.origin_src = angular.isDefined(object.origin_src) ? object.origin_src : object.getSvgSrc();
                            if (angular.isDefined(object.origin_url)) {
                                $scope.stages[$scope.currentStage].states.origin_url = object.origin_url;
                                $scope.stages[$scope.currentStage].states.origin_width = object.origin_width;
                                $scope.stages[$scope.currentStage].states.origin_height = object.origin_height;
                            } else {
                                delete $scope.stages[$scope.currentStage].states.origin_url;
                                delete $scope.stages[$scope.currentStage].states.origin_width;
                                delete $scope.stages[$scope.currentStage].states.origin_height;
                            }
                            ['crop_left', 'crop_top', 'crop_width', 'crop_height', 'crop_scaleX', 'crop_scaleY'].forEach(function (key) {
                                if (angular.isDefined(object[key])) {
                                    $scope.stages[$scope.currentStage].states[key] = object[key];
                                }
                            });
                            $scope.stages[$scope.currentStage].states.filters = [];
                            if ($scope.settings.enableImageFilter) {
                                $scope.availableFilters.forEach(function (filter) {
                                    $scope.stages[$scope.currentStage].states.filters[filter] = $scope.checkActiveFilter(filter, object.filters);
                                });
                            }
                            /*advanced*/
                            if (typeof udc_nbd_js_config != "undefined") {
                                var filterCollection = object.filters;
                                $scope.checkGamma = false;
                                $scope.checkBlendColor = false;
                                $scope.checkBlendImage = false;
                                $timeout(function () {
                                    jQuery('#customize-filter-mask').perfectScrollbar('update');
                                });
                                if (object.filters.length > 0) {
                                    angular.forEach(filterCollection, function (value, key) {
                                        var type = value.type;
                                        angular.forEach($scope.matrixFilter, function (filter, k) {
                                            switch (type) {
                                                case "BlackWhite":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Invert":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Grayscale":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Kodachrome":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Technicolor":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Vintage":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Polaroid":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Brownie":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Sepia":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Sharpen":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                case "Emboss":
                                                    if (filter.type == type.toLowerCase()) {
                                                        $scope.matrixFilter[k].check = 1;
                                                    }
                                                    break;
                                                default:
                                                    $scope.matrixFilter[k].check = false;
                                                    break;
                                            }
                                        });
                                        angular.forEach($scope.attributeImage, function (attr, index) {
                                            switch (type) {
                                                case "Pixelate":
                                                    if (index === type.toLowerCase()) {
                                                        $scope.attributeImage[index] = value.blocksize;
                                                    }
                                                    break;
                                                case "Brightness":
                                                    if (index === type.toLowerCase()) {
                                                        angular.forEach(value, function (v, k) {
                                                            $scope.attributeImage[index] = parseFloat(value[k] * 100);
                                                        });
                                                    }
                                                    break;
                                                case "Saturation":
                                                    if (index === type.toLowerCase()) {
                                                        angular.forEach(value, function (v, k) {
                                                            $scope.attributeImage[index] = parseFloat(value[k] * 100);
                                                        });
                                                    }
                                                    break;
                                                case "Contrast":
                                                    if (index === type.toLowerCase()) {
                                                        angular.forEach(value, function (v, k) {
                                                            $scope.attributeImage[index] = parseFloat(value[k] * 100);
                                                        });
                                                    }
                                                    break;
                                                case "Blur":
                                                    if (index === type.toLowerCase()) {
                                                        angular.forEach(value, function (v, k) {
                                                            $scope.attributeImage[index] = parseFloat(value[k] * 100);
                                                        });
                                                    }
                                                    break;
                                                case "Noise":
                                                    if (index === type.toLowerCase()) {
                                                        angular.forEach(value, function (v, k) {
                                                            $scope.attributeImage[index] = value[k];
                                                        });
                                                    }
                                                    break;
                                                case "HueRotation":
                                                    if (index === type.toLowerCase()) {
                                                        $scope.attributeImage[index] = parseFloat(value.rotation * 100);
                                                    }
                                                    break;
                                                case "HueRotation":
                                                    if (index === type.toLowerCase()) {
                                                        $scope.attributeImage[index] = parseFloat(value.rotation * 100);
                                                    }
                                                    break;
                                                case "RemoveColor":
                                                    if (index === type.toLowerCase()) {
                                                        $scope.attributeImage[index] = value.distance;
                                                        $scope.currentColorCustomize = value.color;
                                                    }
                                                    break;
                                                case "Gamma":
                                                    angular.forEach(value, function (v, k) {
                                                        angular.forEach(value.gamma, function (va, ke) {
                                                            $scope.attributeImage.r = value.gamma[0];
                                                            $scope.attributeImage.g = value.gamma[1];
                                                            $scope.attributeImage.b = value.gamma[2];
                                                        });
                                                    });
                                                    $scope.checkGamma = true;
                                                    $timeout(function () {
                                                        jQuery('#customize-filter-mask').perfectScrollbar('update');
                                                    });
                                                    break;
                                                case "BlendColor":
                                                    $scope.attributeImage.apha = value.alpha;
                                                    $scope.attributeImage.color = value.color;
                                                    $scope.currentColorCustomizeBlend = $scope.attributeImage.color;
                                                    $scope.checkBlendColor = true;
                                                    $timeout(function () {
                                                        jQuery('#customize-filter-mask').perfectScrollbar('update');
                                                    });
                                                    break;
                                                case "BlendImage":
                                                    $scope.aphaImage = value.alpha;
                                                    $scope.checkBlendImage = true;
                                                    $timeout(function () {
                                                        jQuery('#customize-filter-mask').perfectScrollbar('update');
                                                    });
                                                    break;
                                                default:
                                                    $scope.checkGamma = false;
                                                    $scope.checkBlendColor = false;
                                                    $scope.checkBlendImage = false;
                                                    $timeout(function () {
                                                        jQuery('#customize-filter-mask').perfectScrollbar('update');
                                                    });
                                                    break;
                                            }
                                        });
                                        angular.forEach($scope.matrixFilter, function (val, index) {
                                            if (angular.isDefined(value.mode)) {
                                                switch (value.mode) {
                                                    case "luminosity":
                                                        if (val.type == value.mode.toLowerCase()) {
                                                            $scope.matrixFilter[index].check = true;
                                                        }
                                                        break;
                                                    case "average":
                                                        if (val.type == value.mode.toLowerCase()) {
                                                            $scope.matrixFilter[index].check = true;
                                                        }
                                                        break;
                                                    case "lightness":
                                                        if (val.type == value.mode.toLowerCase()) {
                                                            $scope.matrixFilter[index].check = true;
                                                        }
                                                        break;
                                                    default:
                                                        $scope.matrixFilter[index].check = false;
                                                        break;
                                                }
                                            }
                                        });
                                        angular.forEach($scope.blendImage, function (val_, inde_) {
                                            if (value.image) {
                                                switch (value.mode) {
                                                    case "multiply":
                                                        if (val_.value == value.mode.toLowerCase()) {
                                                            $scope.nameModeImage = $scope.blendImage[inde_].name;
                                                        }
                                                        break;
                                                    case "mask":
                                                        if (val_.value == value.mode.toLowerCase()) {
                                                            $scope.nameModeImage = $scope.blendImage[inde_].name;
                                                        }
                                                        break;
                                                }
                                            }
                                        });
                                        angular.forEach($scope.modeImage, function (value_, index_) {
                                            switch (value.mode) {
                                                case "add":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "diff":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "subtract":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "multiply":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "screen":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "lighten":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "darken":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "overlay":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "exclusion":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                                case "tint":
                                                    if (value_.value == value.mode.toLowerCase()) {
                                                        $scope.nameMode = $scope.modeImage[index_].name;
                                                    }
                                                    break;
                                            }
                                        });
                                    });
                                } else {
                                    $scope.currentColorCustomizeBlend = '#00f900';
                                    $scope.currentColorCustomize = $scope.settings.nbdesigner_default_color;
                                    angular.forEach($scope.matrixFilter, function (filter, k) {
                                        $scope.matrixFilter[k].check = false;
                                    });
                                }
                            }
                            break;
                        case 'line':
                            $scope.stages[$scope.currentStage].states.isShape = true;
                            if (NBDESIGNCONFIG.nbdesigner_clipart_change_path_color == '1') {
                                $scope.stages[$scope.currentStage].states.geoObject = {
                                    fill: object.get('fill'),
                                    stroke: object.get('stroke') ? object.get('stroke') : '#ffffff',
                                    strokeWidth: object.get('strokeWidth') ? object.get('strokeWidth') : 0,
                                    strokeDashArray: object.get('strokeDashArray') ? object.get('strokeDashArray') : ['0', '0'],
                                    strokeUniform: object.get('strokeUniform')
                                };
                            }
                            $scope.stages[$scope.currentStage].states.enableRotate = NBDESIGNCONFIG.nbdesigner_clipart_rotate == '1' ? true : false;
                            $scope.stages[$scope.currentStage].states.enableOpacity = NBDESIGNCONFIG.nbdesigner_clipart_opacity == '1' ? true : false;
                            break;
                        case 'path-group':
                        case 'path':
                        case 'group':
                        case 'rect':
                        case 'triangle':
                        case 'line':
                        case 'polygon':
                        case 'circle':
                        case 'ellipse':
                        case 'outlinecircle':
                        case 'polyline':

                            $scope.stages[$scope.currentStage].states.isPath = true;
                            $scope.handleGradientColor(object);
                            if (NBDESIGNCONFIG.nbdesigner_clipart_change_path_color == '1') {
                                $scope.stages[$scope.currentStage].states.svg.groupPath = $scope.getPathOfSvg(object);
                            } else {
                                $scope.stages[$scope.currentStage].states.svg.groupPath = [];
                            }
                            if (object.type == 'group') $scope.stages[$scope.currentStage].states.isNativeGroup = true;
                            $scope.stages[$scope.currentStage].states.enableRotate = NBDESIGNCONFIG.nbdesigner_clipart_rotate == '1' ? true : false;
                            $scope.stages[$scope.currentStage].states.enableOpacity = NBDESIGNCONFIG.nbdesigner_clipart_opacity == '1' ? true : false;
                            $timeout(() => {
                                $scope.updateScrollBar('.items-color-fill');
                            }, 200);
                            break;
                        default:
                            break;
                    }
                    /*advanced*/
                    if (typeof udc_nbd_js_config != 'undefined') {
                        switch (object.type) {
                            case('bg-image'):
                                $scope.stages[$scope.currentStage].states.isBGimage = true;
                                //$scope.stages[$scope.currentStage].states.isImage = true;
                                break;
                        }
                    }
                    if ($scope.stages[$scope.currentStage].states.enableShadow) {
                        if (object.shadow) {
                            var colorArr = fabric.Color.sourceFromRgb(object.shadow.color),
                                color = fabric.Color.fromRgb(object.shadow.color);
                            $scope.stages[$scope.currentStage].states.shadow = {
                                color: '#' + color.toHex(),
                                offsetX: object.shadow.offsetX,
                                offsetY: object.shadow.offsetY,
                                blur: object.shadow.blur,
                                opacity: colorArr[3]
                            }
                        } else {
                            $scope.stages[$scope.currentStage].states.shadow = angular.copy($scope.defaultStageStates.shadow);
                        }
                    }
                } else {
                    $scope.stages[$scope.currentStage].states.activeIds = [];
                }
            }
            $scope.updateApp();
        };
        /* Utility functions */
        $scope.tips = {
            total: 3,
            current: 1,
            firstTime: true
        };
        $scope.toggleTip = function (close) {
            var first_visitor = getCookie("nbdesigner_user");
            if (angular.isDefined(close)) {
                if (close) {
                    jQuery('.nbd-tip').removeClass('nbd-show');
                    if ($scope.tips.firstTime) {
                        $timeout(function () {
                            $scope.tips.current = 2;
                            $scope.toggleTip(false);
                        }, 10000);
                    }
                    $scope.tips.firstTime = false;
                } else {
                    jQuery('.nbd-tip').addClass('nbd-show');
                }
            } else {
                if (first_visitor == "") {
                    setCookie("nbdesigner_user", 'Hello World', 0.5);
                    jQuery('.nbd-tip').addClass('nbd-show');
                }
            }
        };

        $scope.getFontsCount = function (item) {
            const fonts = [item.fontFamily];
            const styles = item.styles;
            if (Object.keys(styles).length) {
                for (const line of Object.keys(styles)) {
                    for (const char of Object.keys(styles[line])) {
                        const charStyles = styles[line][char];
                        if (charStyles.hasOwnProperty('fontFamily')) {
                            fonts.push(charStyles.fontFamily);
                        }
                    }
                }
            }

            return [...new Set(fonts)].length;

        }

        $scope.getSelectionFonts = function (item) {
            const fonts = [];
            let styles;
            if (item.selectionStart !== item.selectionEnd) {
                styles = item.getSelectionStyles();
            } else {
                if (item.type === 'curvedText' || item.selectionStart !== item.findLineBoundaryRight(item.selectionStart)) {
                    styles = item.getSelectionStyles(item.selectionStart, item.selectionStart + 1);
                } else {
                    styles = item.getSelectionStyles(item.selectionStart - 1, item.selectionStart);
                }
            }
            if (Object.keys(styles).length) {
                for (const char of Object.keys(styles)) {
                    const charStyles = styles[char];
                    if (charStyles.hasOwnProperty('fontFamily')) {
                        fonts.push(charStyles.fontFamily);
                    } else {
                        fonts.push(item.fontFamily);
                    }
                }
            }
            const usedFonts = [...new Set(fonts)];
            return usedFonts.length ? usedFonts : [item.fontFamily];

        }
        /*advanced*/
        if (typeof hvc_app_modern_js != "undefined") {
            $scope.toggleTip2 = function () {
                if (jQuery('.nbd-tip2').hasClass('nbd-show')) {
                    jQuery('.nbd-tip2').removeClass('nbd-show');
                } else {
                    jQuery('.nbd-tip2').addClass('nbd-show');
                }
            };
        }
        $scope.nextTip = function () {
            $scope.tips.current = $scope.tips.current == $scope.tips.total ? 1 : ($scope.tips.current + 1);
        };
        $scope.startCountTime = function () {
            $scope.startTime = new Date();
        };
        $scope.endCountTime = function () {
            var endTime = new Date();
            console.log((endTime - $scope.startTime) + " ms");
        };
        $scope.getFontInfo = function (alias) {
            var font = _.filter($scope.resource.font.data, {alias: alias})[0],
                _font = angular.copy(font, _font);
            if (_font) {
                _font.file = {r: font.file.r};
                _font.file.i = angular.isDefined(font.file.i) ? font.file.i : 0;
                _font.file.b = angular.isDefined(font.file.b) ? font.file.b : 0;
                _font.file.bi = angular.isDefined(font.file.bi) ? font.file.bi : 0;
            } else {
                _font = {
                    name: 'Roboto',
                    alias: 'Roboto',
                    file: {r: 1, b: 1, i: 1, bi: 1},
                    cat: ["99"],
                    type: "google",
                    subset: "latin"
                };
            }
            return _font;
        };
        $scope.getPathOfSvg = function (object) {
            var groupPath = [];
            _.each(object._objects, function (path, index) {
                if (path.get('fill') != '') {
                    var color = tinycolor(path.get('fill')).toHexString();
                    $scope.addColor(color);
                    var findex;
                    if ((findex = _.findIndex(groupPath, ['color', color])) > -1) {
                        groupPath[findex]['index'].push(index);
                    } else {
                        groupPath.push({color: color, index: [index]});
                    }
                }
            });
            if (groupPath.length == 0) {
                if (object.get('fill')) {
                    $scope.addColor(tinycolor(object.get('fill')).toHexString());
                    groupPath.push({color: tinycolor(object.get('fill')).toHexString(), index: [-2]});
                }
            }
            if (groupPath.length == 0) {
                $scope.addColor(tinycolor(object.get('stroke')).toHexString());
                groupPath.push({color: tinycolor(object.get('stroke')).toHexString(), index: [-1]});
            }
            return groupPath;
        };
        $scope.isUpperCase = function (object) {
            var _isUpperCase = angular.isDefined(object.is_uppercase) ? object.is_uppercase : false;
            return _isUpperCase;
        };
        $scope.fitRectangle = function (x1, y1, x2, y2, fill) {
            var rec = {};
            if (x2 < x1 && y2 < y1) {
                if (fill) {
                    if (x1 / y1 > x2 / y2) {
                        rec.width = x2 * y1 / y2;
                        rec.height = y1;
                        rec.top = 0;
                        rec.left = (x1 * y2 - x2 * y1) / y2 / 2;
                    } else {
                        rec.width = x1;
                        rec.height = x1 * y2 / x2;
                        rec.top = (x2 * y1 - x1 * y2) / x2 / 2;
                        rec.left = 0;
                    }
                } else {
                    rec.top = (x1 - x2) / 2;
                    rec.left = (y1 - y2) / 2;
                    rec.width = x2;
                    rec.height = y2;
                }
            } else if (x1 / y1 > x2 / y2) {
                rec.width = x2 * y1 / y2;
                rec.height = y1;
                rec.top = 0;
                rec.left = (x1 * y2 - x2 * y1) / y2 / 2;
            } else {
                rec.width = x1;
                rec.height = x1 * y2 / x2;
                rec.top = (x2 * y1 - x1 * y2) / x2 / 2;
                rec.left = 0;
            }
            return rec;
        };
        $scope.insertTemplateFont = function (font_name, callback) {
            if (!_.filter($scope.resource.font.data, ['alias', font_name]).length) {
                NBDDataFactory.get('nbd_get_resource', {type: 'google_font', font_name: font_name}, function (data) {
                    data = JSON.parse(data);
                    if (data.flag == 1) {
                        if (!_.filter($scope.resource.font.data, ['alias', font_name]).length) {
                            $scope.resource.font.data.push(data.data);
                        }
                        ;
                        var fontName = data.data.alias;
                        var font_id = fontName.replace(/\s/gi, '').toLowerCase();
                        if (!jQuery('#' + font_id).length) {
                            jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family=' + fontName.replace(/\s/gi, '+') + ':400,400i,700,700i" rel="stylesheet" type="text/css">');
                        }
                        ;
                        var font = new FontFaceObserver(fontName);
                        font.load($scope.settings.subsets[data.data.subset]['preview_text']).then(function () {
                            if (angular.isDefined(callback)) callback(fontName);
                        }, function () {
                            console.log('Fail to load: ' + fontName);
                            if (angular.isDefined(callback)) callback('Poppins');
                        });
                    } else {
                        if (angular.isDefined(callback)) callback('Poppins');
                    }
                });
            } else {
                var _font = $scope.getFontInfo(font_name);
                var fontName = font_name;
                var font_id = fontName.replace(/\s/gi, '').toLowerCase();
                if (!jQuery('#' + font_id).length) {
                    if (_font.type == 'google') {
                        jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family=' + fontName.replace(/\s/gi, '+') + ':400,400i,700,700i" rel="stylesheet" type="text/css">');
                    } else {
                        if (_font.file.r == '1') {
                            var font_url = _font.url;
                            if (!(font_url.indexOf("http") > -1)) font_url = NBDESIGNCONFIG['font_url'] + font_url;
                            var css = "";
                            css = "<style type='text/css' id='" + font_id + "' >";
                            css += "@font-face {font-family: '" + fontName + "';";
                            /*advanced*/
                            if (typeof udc_nbd_js_config != 'undefined') {
                                css += "src: local('\u263a'),";
                            } else {
                                css += "src: ";
                            }
                            css += "url('" + font_url + "') format('truetype')";
                            css += "}";
                            css += "</style>";
                            jQuery("head").append(css);
                        } else {
                            var css = "<style type='text/css' id='" + font_id + "' >";
                            _.each(_font.file, function (file, index) {
                                if (file != 0) {
                                    var font_url = file;
                                    if (!(file.indexOf("http") > -1)) font_url = NBDESIGNCONFIG['font_url'] + file;
                                    css += "@font-face {font-family: '" + fontName + "';";
                                    css += "src: ";
                                    css += "url('" + font_url + "') format('truetype');";
                                    switch (index) {
                                        case "r":
                                            css += "font-weight: normal;font-style: normal;"
                                            break;
                                        case "b":
                                            css += "font-weight: bold;font-style: normal;"
                                            break;
                                        case "i":
                                            css += "font-weight: normal;font-style: italic;"
                                            break;
                                        case "bi":
                                            css += "font-weight: bold;font-style: italic;"
                                            break;
                                    }
                                    ;
                                    css += "}";
                                }
                            });
                            css += "</style>";
                            jQuery("head").append(css);
                        }
                    }
                }
                ;
                var font = new FontFaceObserver(fontName);
                font.load($scope.settings.subsets[_font.subset]['preview_text']).then(function () {
                    if (angular.isDefined(callback)) callback(fontName);
                }, function () {
                    console.log('Fail to load: ' + fontName);
                    if (angular.isDefined(callback)) callback(fontName);
                });
            }
            ;
        };
        $scope.onloadTemplate = false;
        $scope.currentLocalTempId = 0;
        $scope.templateHolderFields = [];
        $scope.addTemplateToStage = function (templateId) {
            $scope.getTemplate(templateId)
                .then(({fonts, design, config, design_id}) => {

                    $scope.onloadTemplate = true;
                    $scope.contextAddLayers = 'template';
                    $scope.loadTemplateFonts(fonts)
                        .then(() => {
                            $scope.loadTemplateToStage(design, config.viewport, $scope.currentStage, config);
                            if (angular.isDefined(design_id)) {
                                NBDESIGNCONFIG.design_id = design_id;
                            }
                        });
                })
        }

        $scope.loadTemplateFonts = function (fonts) {
            return new Promise((resolve) => {
                if (fonts.length) {
                    _.each(fonts, function (font, index) {
                        if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                            if (angular.isDefined(font.file) && angular.isDefined(font.file.r)) $scope.resource.font.data.push(font);
                        }
                        ;
                        if (index == fonts.length - 1) {
                            $scope.insertTemplateFont(font.alias, function () {
                                resolve();
                                if (!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length) {
                                    $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        } else {
                            $scope.insertTemplateFont(font.alias, function () {
                                if (!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length) {
                                    $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        }
                    });
                } else {
                    resolve();
                }
            })
        }

        $scope.loadTemplateToStage = function (design, viewport, stageIndex, konfig) {
            $scope.toggleStageLoading(6E4);
            var _index = 'frame_' + 0,
                stage = $scope.stages[stageIndex],
                _canvas = stage['canvas'],
                layerIndex = 0;
            _canvas.clear();
            if (angular.isUndefined(design[_index])) {
                design[_index] = {version: "2.3.3", objects: []};
            }
            ;
            if (angular.isDefined(design[_index].background)) {
                _canvas.setBackgroundColor(design[_index].background);
            }
            ;
            var objects = design[_index].objects;

            function loadLayer(layerIndex) {
                function continueLoadLayer() {
                    layerIndex++;
                    if (objects.length !== 0 && layerIndex < objects.length) {
                        loadLayer(layerIndex);
                    } else {
                        $scope.renderStage(stageIndex);
                        var layers = stage.canvas.getObjects();
                        $scope.renderTextAfterLoadFont(layers, function () {
                            $scope.deactiveAllLayer();
                            $scope.renderStage(stageIndex);
                            $timeout(() => {
                                $scope.deactiveAllLayer();
                                $scope.renderStage(stageIndex);
                                $scope.onloadTemplate = false;
                                $scope.contextAddLayers = 'normal';
                                if (angular.isDefined(viewport)) {
                                    $scope.resizeStage(viewport);
                                } else if (angular.isDefined(konfig) && angular.isDefined(konfig.scale)) {
                                    viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                                    $scope.resizeStage(viewport);
                                } else {
                                    $scope.toggleStageLoading();
                                }
                                $scope.afterInsertTemplate();
                            }, 500)
                        })
                    }
                };
                if (objects.length > 0) {
                    var item = objects[layerIndex],
                        type = item.type;
                    var mustInsert = true;
                    if (type == 'image' || type == 'custom-image') {
                        if (appConfig.domainChanged) {
                            var _src = item.src;
                            var src = _src.split('nbdesigner');
                            if (src.length == 2) {
                                item.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                            }
                        }
                        ;
                        if (angular.isDefined(item.avatar)) {
                            if (angular.isDefined($scope.settings.contact_sheets)) {
                                item.src = $scope.settings.contact_sheets.avatar;
                            }
                        }
                        if (angular.isDefined(item.c_avatar)) {
                            if (angular.isDefined($scope.settings.contact_sheet)) {
                                if (angular.isDefined($scope.settings.contact_sheet[item.c_avatar])) {
                                    item.src = $scope.settings.contact_sheet[item.c_avatar].c_avatar;
                                } else {
                                    mustInsert = false;
                                }
                            }
                        }
                        if (mustInsert) {
                            fabric.Image.fromObject(item, function (_image) {
                                // _image.doesSnap();
                                console.log('add')
                                _canvas.add(_image);
                                continueLoadLayer();
                            });
                        } else {
                            continueLoadLayer();
                        }
                    } else {
                        var klass = fabric.util.getKlass(type);
                        if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(type) > -1) {
                            if (!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length) {
                                stage.states.usedFonts.push($scope.getFontInfo(item.fontFamily));
                            }
                            ;
                        }
                        ;
                        ['first_name', 'last_name', 'full_name', 'company', 'address', 'postcode', 'city', 'phone', 'email', 'mobile', 'website', 'title'].forEach(function (val) {
                            if (angular.isDefined(item[val])) {
                                if (angular.isDefined($scope.settings.user_infos)) {
                                    item.text = $scope.settings.user_infos[val].value;
                                }
                            }
                        });
                        ['date', 'c_full_name', 'c_title', 'c_mobile', 'c_phone', 'c_email'].forEach(function (val) {
                            if (angular.isDefined(item[val])) {
                                if (angular.isDefined($scope.settings.contact_sheets)) {
                                    if (val == 'date') {
                                        item.text = $scope.settings.contact_sheets[val];
                                    } else {
                                        if (angular.isDefined($scope.settings.contact_sheet[item[val]])) {
                                            item.text = $scope.settings.contact_sheet[item[val]][val];
                                        } else {
                                            mustInsert = false;
                                        }
                                    }
                                }
                            }
                        });
                        if (angular.isDefined(item.field_mapping) && !$scope.isTemplateMode) {
                            var field = _.filter($scope.settings.template_fields, {key: item.field_mapping})[0];
                            if (angular.isDefined(field)) {
                                if (field.value != '') {
                                    if (angular.isDefined(item.is_uppercase)) {
                                        item.text = item.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                    } else {
                                        item.text = field.value;
                                    }
                                } else {
                                    var mapping_field = _.filter($scope.templateHolderFields, {key: item.field_mapping})[0];
                                    if (angular.isUndefined(mapping_field)) {
                                        $scope.templateHolderFields.push(JSON.parse(JSON.stringify(field)));
                                    }
                                }
                            }
                        }
                        if (angular.isDefined(item.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1') {
                            $scope.generateVcard(function (newObject) {
                                var config = {
                                    left: item.left,
                                    top: item.top,
                                    scaleX: item.scaleX,
                                    scaleY: item.scaleY
                                };
                                newObject.set(config);
                                newObject.scaleToWidth(item.width * item.scaleX);
                                newObject.scaleToWidth(item.width * item.scaleX);
                                // newObject.doesSnap();
                                _canvas.add(newObject);
                                continueLoadLayer();
                            });
                        } else {
                            if (angular.isDefined(item.vcard)) {
                                var config = {
                                    left: item.left,
                                    top: item.top,
                                    vcard: 1
                                };
                                $scope.strVcard = '';
                                if (angular.isDefined($scope.settings.user_infos)) {
                                    var infos = $scope.settings.user_infos;
                                    $scope.strVcard += 'BEGIN:VCARD\nVERSION:3.0\n';
                                    $scope.strVcard += 'N:' + infos.last_name.value + ';' + infos.first_name.value + '\n' + 'FN:' + infos.full_name.value;
                                    $scope.strVcard += '\nADR;TYPE=home:;;' + infos.address.value + ';' + infos.city.value + ';;' + infos.postcode.value + ';' + infos.country.value;
                                    $scope.strVcard += '\nTEL;TYPE=home:' + infos.phone.value;
                                    $scope.strVcard += '\nTEL;TYPE=work:' + infos.mobile.value;
                                    $scope.strVcard += '\nEMAIL;TYPE=internet,work:' + infos.email.value;
                                    $scope.strVcard += '\nURL;TYPE=work:' + infos.website.value;
                                    $scope.strVcard += '\nEND:VCARD';
                                    var qr = qrcode('0', 'M');
                                    qr.addData($scope.strVcard);
                                    qr.make();
                                    var _qrcode = qr.createSvgTag();
                                    fabric.loadSVGFromString(_qrcode, function (ob, op) {
                                        var object = fabric.util.groupSVGElements(ob, op);
                                        object.set(config);
                                        object.scaleToWidth(item.width * item.scaleX);
                                        object.scaleToHeight(item.height * item.scaleY);
                                        object.vcard = 1;
                                        // object.doesSnap();
                                        _canvas.add(object);
                                        continueLoadLayer();
                                    });
                                } else {
                                    klass.fromObject(item, function (item) {
                                        // item.doesSnap();
                                        _canvas.add(item);
                                        continueLoadLayer();
                                    });
                                }
                            } else {
                                if (mustInsert) {
                                    if (type == 'text') {
                                        var text = item.text;
                                        var textobj = {};
                                        angular.copy(item, textobj);
                                        delete textobj.text;
                                        delete textobj.type;
                                        var textbox = new fabric.IText(text, textobj);
                                        // textbox.doesSnap();
                                        _canvas.add(textbox);
                                        continueLoadLayer();
                                    } else {
                                        klass.fromObject(item, function (item) {
                                            _canvas.add(item);
                                            continueLoadLayer();
                                        });
                                    }
                                } else {
                                    continueLoadLayer();
                                }
                            }
                        }
                    }
                } else {
                    continueLoadLayer();
                }
            };
            loadLayer(layerIndex);
        };

        $scope.getTemplate = function (templateId) {
            return new Promise((resolve) => {

               NBDDataFactory.get('nbdesigner_get_product_info', {
                    product_id: NBDESIGNCONFIG['product_id'],
                    variation_id: NBDESIGNCONFIG['variation_id'],
                    template_id: templateId
                }, function (data) {
                    data = JSON.parse(data);
                    resolve(data);
                });
            })

        }

        $scope.detectTemplateAvailability = function (id) {
            let role;
            _.each(CONFIG.templatesRoles, function (value, key) {
                if (Array.isArray(value) && value.includes(id)) {
                    role = key;
                    return false;
                }
            });
            return role;
        }
        $scope.detectClipartAvailability = function (id) {
            let role;
            _.each(CONFIG.clipartRoles, function (value, key) {
                if (Array.isArray(value) && value.includes(id)) {
                    role = key;
                    return false;
                }
            });
            return role;
        }
        $scope.detectOverlayAvailability = function (id) {
            let role;
            _.each(CONFIG.overlayRoles, function (value, key) {
                if (Array.isArray(value) && value.includes(id)) {
                    role = key;
                    return false;
                }
            });
            return role;
        }
        /*Edit field option visual design*/
        if (typeof bdesign_customize_visual_option != "undefined") {
            $scope.numberSpacing = function () {
                var cv = $scope.stages[$scope.currentStage]['canvas'].getActiveObject();
                if (!isNaN(Number(cv.text))) {
                    var str = cv.text.replace(/\s/g, '');
                    var arr = str.split("");
                    for (i = 2; i <= arr.length; i += 3) {
                        arr.splice(i, 0, ' ');
                    }
                    cv.text = arr.join('');
                }
            }
            $scope.hideEditor = function () {
                var dl_ip = jQuery(".text-editor.active").css("display");
                if (dl_ip == "none") {
                    jQuery(".text-editor.active").fadeIn(2000);
                } else {
                    jQuery(".text-editor.active").fadeOut(2000);
                }

                jQuery("#hide_editor").toggleClass("active");
            }

            function hideIfEmpty(type, item) {
                var index_t = -1;
                var cv = $scope.stages[$scope.currentStage].canvas.getObjects();
                cv.forEach((element, index) => {
                    if (element.name == type) {
                        index_t = index;
                    }
                });
                if (index_t !== -1) {
                    var str = cv[index_t].text.replace(/\s/g, '');
                    str = str.slice(-(str.length - 2));
                    if (str == '' || str == 'T:') {
                        if (type == "telephone") {
                            if (item.hidePhoneEmpty) {
                                item.visible = false;
                            } else {
                                item.visible = true;
                            }
                        } else {
                            if (item.hideMobileEmpty) {
                                item.visible = false;
                            } else {
                                item.visible = true;
                            }
                        }
                    }
                }
            }
        }
        /*advanced*/
        if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
            $scope.priceTem = 0;
            $scope.currentTemp = {};
            $scope.closeBoxPrenium = function () {
                jQuery('.box-prenium').toggleClass('active');
            }
            $scope.checkTemplatePre = function (e) {
                if (angular.isDefined($scope.priceTem) && $scope.priceTem > 0) {
                    jQuery('.box-prenium').toggleClass('active');
                } else {
                    $scope.saveData();
                }
            }
        }

        $scope.insertTemplateById = function (local, id) {
            const template = $scope.resource.templates.filter((template) => template.id === id)[0];
            if (!template) {
                return;
            }
            $scope.addTemplateToStage(template.id);
        }
        $scope.insertTemplate = function (local, temp) {
            if ($scope.settings.nbdesigner_boosting_load_template == 'yes') {
                $scope.boostInsertTemplate(local, temp);
                return;
            }

            $scope.currentLocalTempId = temp.id;
            /*advanced*/
            if (typeof mctp_nbd_js_config_design != "undefined") {
                if (angular.isDefined(nbd_window.NBDESIGNERPRODUCT)) {
                    nbd_window.NBDESIGNERPRODUCT.tempid = temp.id;
                }
            }
            /*advanced*/
            if (typeof kcnb_nbd_js_config != "undefined") {
                if (!local) {
                    $scope.templateName = temp.name;
                }
            }
            if (angular.isUndefined(temp.doNotShowLoading)) {
                $scope.toggleStageLoading(6E4);
                $scope.showDesignTab();
            }
            $scope.onloadTemplate = true;
            $scope.contextAddLayers = 'template';
            /*advanced*/
            if (typeof dkdp_nbd_mbf_custom_app_js != "undefined") {
                if (temp.type == 'pre') {
                    $scope.priceTem = temp.price;
                    $scope.currentTemp = temp;
                } else {
                    $scope.priceTem = 0;
                }
            }

            function loadDesign(fonts, design, viewport, konfig) {
                var stageIndex = 0;

                function loadStage(stageIndex) {
                    var _index = 'frame_' + stageIndex,
                        stage = $scope.stages[stageIndex],
                        _canvas = stage['canvas'],
                        layerIndex = 0;
                    _canvas.clear();
                    if (angular.isUndefined(design[_index])) {
                        design[_index] = {version: "2.3.3", objects: []};
                    }
                    ;
                    if (angular.isDefined(design[_index].background)) {
                        _canvas.setBackgroundColor(design[_index].background);
                    }
                    ;
                    _canvas.set({
                        linearGradientAngle: design[_index].linearGradientAngle || 0
                    });
                    /*advanced*/
                    if (typeof mctp_nbd_js_config_design != "undefined") {
                        if (NBDESIGNCONFIG.type_template == 1) {
                            var url = $scope.settings.nbdesigner_pdf_watermark_image;
                            fabric.Image.fromURL(url, function (img, isError) {
                                img.set({
                                    width: _canvas.width,
                                    height: _canvas.height,
                                    originX: 'left',
                                    originY: 'top'
                                });
                                _canvas.setOverlayImage(img, _canvas.renderAll.bind(_canvas));
                            });
                        }
                    }
                    var objects = design[_index].objects;

                    function loadLayer(layerIndex) {
                        function continueLoadLayer() {
                            layerIndex++;
                            if (objects.length != 0 && layerIndex < objects.length) {
                                loadLayer(layerIndex);
                            } else {
                                stageIndex++;
                                if (stageIndex < $scope.stages.length) {
                                    loadStage(stageIndex);
                                } else {
                                    /*advanced*/
                                    if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                                        function replaceObject() {
                                            var stage = $scope.stages[$scope.currentStage];
                                            _canvas = stage.canvas;
                                            var objects = _canvas.getObjects();
                                            money = NBDESIGNCONFIG.val_money;
                                            var str = money;
                                            str = str.replace("&pound;", "£");
                                            money = str;
                                            for (var i = 0; i < objects.length; i++) {
                                                if (objects[i].itemId === "vourcher") {
                                                    if (typeof NBDESIGNCONFIG.date != "undefined") {
                                                        objects[i].text =
                                                            "Vourcher No: " + NBDESIGNCONFIG.id_order +
                                                            "\n" +
                                                            "Issue Date: " +
                                                            NBDESIGNCONFIG.date;
                                                    } else {
                                                        var a = objects[i].text.split("\n");
                                                        a.forEach((e, i) => {
                                                            if (e.indexOf("Vourcher No") !== -1) {
                                                                a[i] =
                                                                    "Vourcher No: " + NBDESIGNCONFIG.id_order;
                                                            }
                                                        });
                                                        var b = a.join("\n");
                                                        objects[i].text = b;
                                                    }
                                                }
                                                if (objects[i].idvalue === "valuevourcher") {
                                                    objects[i].text = money;
                                                }
                                            }
                                            objects.forEach((e, i) => {
                                                if ((NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == '') || ((NBDESIGNCONFIG.task == 'new' && NBDESIGNCONFIG.ui_mode == 1))) {
                                                    if (objects[i].sampleText != 'undefined' && objects[i].sampleText == "sampleText") {
                                                        Object.assign(objects[i], {visible: true});
                                                    }
                                                    if (objects[i].termCodition != 'undefined' && objects[i].termCodition == "coditionText") {
                                                        Object.assign(objects[i], {visible: false});
                                                    }
                                                }
                                            });
                                        }

                                        replaceObject();
                                    }
                                    _.each($scope.stages, function (_stage, index) {
                                        /*Edit field option visual design*/
                                        if (typeof bdesign_customize_visual_option !== "undefined") {
                                            $scope.stages[index].layers.forEach(element => {
                                                element.placeholder = element.text;
                                                if (element.text.indexOf('T:') !== -1 || element.text.indexOf('M:') !== -1) {
                                                    if (element.text.indexOf('T:') !== -1) {
                                                        element.placeholder = "telephone";
                                                    }
                                                    if (element.text.indexOf('M:') !== -1) {
                                                        element.placeholder = "mobile";
                                                    }
                                                    element.text = element.text.slice(3, element.text.length);
                                                    element.text = element.text.replace(/\s/g, '');
                                                    if (isNaN(Number(element.text))) {
                                                        element.text_hide = "y";
                                                    }
                                                }
                                                if (element.text.indexOf('@') !== -1) {
                                                    element.placeholder = "email";
                                                }
                                                if (element.text == "| Afdeling") {
                                                    element.text = "Afdeling";
                                                    element.placeholder = "Afdeling";
                                                }
                                            })
                                        }
                                        $scope.renderStage(index);
                                        var layers = _stage.canvas.getObjects();
                                        $scope.renderTextAfterLoadFont(layers, function () {
                                            $scope.deactiveAllLayer();
                                            $scope.renderStage(index);
                                            $timeout(function () {
                                                $scope.deactiveAllLayer();
                                                $scope.renderStage(index);
                                                if (index == $scope.stages.length - 1) {
                                                    $scope.onloadTemplate = false;
                                                    $scope.contextAddLayers = 'normal';
                                                    if (angular.isDefined(viewport)) {
                                                        $scope.resizeStages(viewport);
                                                    } else if (angular.isDefined(konfig) && angular.isDefined(konfig.scale)) {
                                                        viewport = {
                                                            width: konfig.scale * 500,
                                                            height: konfig.scale * 500
                                                        };
                                                        $scope.resizeStages(viewport);
                                                    } else {
                                                        $scope.toggleStageLoading();
                                                    }
                                                    $scope.afterInsertTemplate();
                                                }
                                                /*Edit field option visual design*/
                                                if (typeof bdesign_customize_visual_option !== "undefined") {
                                                    $scope.stages[$scope.currentStage].states.hidePhoneEmpty = false;
                                                    layers.forEach(item => {
                                                        if (item.text.indexOf("T:") !== -1) {
                                                            item.name = "telephone";
                                                            item.margin_left_tele = item.left;
                                                            item.text = item.text.replace(/\s/g, '');
                                                            item.text = item.text.slice(2, item.text.length);
                                                            var val = item.text.split("");
                                                            for (i = 2; i <= val.length; i += 3) {
                                                                val.splice(i, 0, " ");
                                                            }
                                                            val = val.join("");
                                                            item.text = "T:" + " " + val.toString();

                                                        }
                                                        if (item.text.indexOf("M:") !== -1) {
                                                            item.name = "mobile";
                                                            item.margin_left_mobi = item.left;
                                                            item.text = item.text.replace(/\s/g, '');
                                                            item.text = item.text.slice(3, item.text.length);
                                                            var val = item.text.split("");
                                                            for (i = 2; i <= val.length; i += 3) {
                                                                val.splice(i, 0, " ");
                                                            }
                                                            val = val.join("");
                                                            item.text = "M:" + " " + val.toString();
                                                        }
                                                        if (item.text == "Title") {
                                                            item.margin_left_title = item.left;
                                                            item.name = "title";
                                                        }
                                                        if (item.text == "| Afdeling") {
                                                            item.margin_left_title_vl = item.left;
                                                            item.name = "title_vl";
                                                            item.text = "| Afdeling";
                                                        }
                                                    });
                                                }
                                            }, 500);
                                        });
                                    });
                                    /*advanced*/
                                    if (typeof mia_nbd_js_config_design != "undefined") {
                                        $timeout(function () {
                                            var angle = $scope.stages[$scope.currentStage].states.rotate.angle ? $scope.stages[$scope.currentStage].states.rotate.angle : 0;
                                            $scope.stages[$scope.currentStage].canvas._objects.forEach((element, index) => {
                                                var item = $scope.stages[$scope.currentStage].canvas._objects[index];
                                                if (item.type == "image" && item.elementUpload) {
                                                    $scope.stages[$scope.currentStage].canvas._objects[index].style = {
                                                        position: "absolute",
                                                        visibility: 'visible',
                                                        top: item.oCoords.tl.y - 1,
                                                        left: item.oCoords.tl.x - 1,
                                                        width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2)) + 2,
                                                        height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2)) + 2,
                                                        transform: "rotate(" + item.angle + "deg)"
                                                    };
                                                }
                                            })

                                        }, 500)
                                    }
                                }
                            }
                        };
                        if (objects.length > 0) {
                            var item = objects[layerIndex],
                                type = item.type;
                            var mustInsert = true;
                            if (type == 'image' || type == 'custom-image') {
                                if (appConfig.domainChanged) {
                                    var _src = item.src;
                                    var src = _src.split('nbdesigner');
                                    if (src.length == 2) {
                                        item.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                                    }
                                    var src2 = _src.split('web-to-print-online-designer/assets/');
                                    if (src2.length == 2) {
                                        item.src = NBDESIGNCONFIG['assets_url'] + src2[1];
                                    }
                                }
                                ;
                                if (angular.isDefined(item.avatar)) {
                                    if (angular.isDefined($scope.settings.contact_sheets)) {
                                        item.src = $scope.settings.contact_sheets.avatar;
                                    }
                                }
                                if (mustInsert) {
                                    fabric.Image.fromObject(item, function (_image) {
                                        _canvas.add(_image);
                                        continueLoadLayer();
                                    });
                                } else {
                                    continueLoadLayer();
                                }
                            } else {
                                var klass = fabric.util.getKlass(type);
                                if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(type) > -1) {
                                    if (!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length) {
                                        stage.states.usedFonts.push($scope.getFontInfo(item.fontFamily));
                                    }
                                    ;
                                }
                                ;
                                ['first_name', 'last_name', 'full_name', 'company', 'address', 'postcode', 'city', 'phone', 'email', 'mobile', 'website', 'title'].forEach(function (val) {
                                    if (angular.isDefined(item[val])) {
                                        if (angular.isDefined($scope.settings.user_infos)) {
                                            item.text = $scope.settings.user_infos[val].value;
                                        }
                                    }
                                });
                                ['date', 'c_full_name', 'c_title', 'c_mobile', 'c_phone', 'c_email'].forEach(function (val) {
                                    if (angular.isDefined(item[val])) {
                                        if (angular.isDefined($scope.settings.contact_sheets)) {
                                            if (val == 'date') {
                                                item.text = $scope.settings.contact_sheets[val];
                                            } else {
                                                if (angular.isDefined($scope.settings.contact_sheet[item[val]])) {
                                                    item.text = $scope.settings.contact_sheet[item[val]][val];
                                                } else {
                                                    mustInsert = false;
                                                }
                                            }
                                        }
                                    }
                                });
                                /*advanced*/
                                if (typeof pcsc_pcloud_js != "undefined") {
                                    if (angular.isDefined(item.field_mapping)) {
                                        var field = _.filter($scope.settings.template_fields, {key: item.field_mapping})[0];
                                        if (angular.isDefined(field)) {
                                            if (field.value != '') {
                                                if (angular.isDefined(item.is_uppercase)) {
                                                    item.text = item.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                                } else {
                                                    item.text = field.value;
                                                }
                                            } else {
                                                var mapping_field = _.filter($scope.templateHolderFields, {key: item.field_mapping})[0];
                                                if (angular.isUndefined(mapping_field)) {
                                                    $scope.templateHolderFields.push(JSON.parse(JSON.stringify(field)));
                                                }
                                            }
                                        }
                                    }
                                }
                                if (angular.isDefined(item.field_mapping) && !$scope.isTemplateMode) {
                                    var field = _.filter($scope.settings.template_fields, {key: item.field_mapping})[0];
                                    if (angular.isDefined(field)) {
                                        if (field.value != '') {
                                            if (angular.isDefined(item.is_uppercase)) {
                                                item.text = item.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                            } else {
                                                item.text = field.value;
                                            }
                                        } else {
                                            var mapping_field = _.filter($scope.templateHolderFields, {key: item.field_mapping})[0];
                                            if (angular.isUndefined(mapping_field)) {
                                                $scope.templateHolderFields.push(JSON.parse(JSON.stringify(field)));
                                            }
                                        }
                                    }
                                }
                                if (angular.isDefined(item.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1') {
                                    $scope.generateVcard(function (newObject) {
                                        var config = {
                                            left: item.left,
                                            top: item.top,
                                            scaleX: item.scaleX,
                                            scaleY: item.scaleY,
                                            fill: object.fill
                                        };
                                        newObject.set(config);
                                        newObject.scaleToWidth(item.width * item.scaleX);
                                        newObject.scaleToWidth(item.width * item.scaleX);
                                        _canvas.add(newObject);
                                        continueLoadLayer();
                                    });
                                } else {
                                    if (angular.isDefined(item.vcard)) {
                                        var config = {
                                            left: item.left,
                                            top: item.top,
                                            vcard: 1
                                        };
                                        $scope.strVcard = '';
                                        if (angular.isDefined($scope.settings.user_infos)) {
                                            var infos = $scope.settings.user_infos;
                                            $scope.strVcard += 'BEGIN:VCARD\nVERSION:3.0\n';
                                            $scope.strVcard += 'N:' + infos.last_name.value + ';' + infos.first_name.value + '\n' + 'FN:' + infos.full_name.value;
                                            $scope.strVcard += '\nADR;TYPE=home:;;' + infos.address.value + ';' + infos.city.value + ';;' + infos.postcode.value + ';' + infos.country.value;
                                            $scope.strVcard += '\nTEL;TYPE=home:' + infos.phone.value;
                                            $scope.strVcard += '\nTEL;TYPE=work:' + infos.mobile.value;
                                            $scope.strVcard += '\nEMAIL;TYPE=internet,work:' + infos.email.value;
                                            $scope.strVcard += '\nURL;TYPE=work:' + infos.website.value;
                                            $scope.strVcard += '\nEND:VCARD';
                                            var qr = qrcode('0', 'M');
                                            qr.addData($scope.strVcard);
                                            qr.make();
                                            var _qrcode = qr.createSvgTag();
                                            fabric.loadSVGFromString(_qrcode, function (ob, op) {
                                                var object = fabric.util.groupSVGElements(ob, op);
                                                object.set(config);
                                                object.scaleToWidth(item.width * item.scaleX);
                                                object.scaleToHeight(item.height * item.scaleY);
                                                object.vcard = 1;
                                                _canvas.add(object);
                                                continueLoadLayer();
                                            });
                                        } else {
                                            klass.fromObject(item, function (item) {
                                                _canvas.add(item);
                                                continueLoadLayer();
                                            });
                                        }
                                    } else {
                                        if (mustInsert) {
                                            if (type == 'text') {
                                                var text = item.text;
                                                var textobj = {};
                                                angular.copy(item, textobj);
                                                delete textobj.text;
                                                delete textobj.type;
                                                var textbox = new fabric.IText(text, textobj);
                                                _canvas.add(textbox);
                                                continueLoadLayer();
                                            } else if (!!item.isTemMask && !$scope.isTemplateMode) {
                                                klass.fromObject(item, function (item) {
                                                    item.set({
                                                        isMask: 1,
                                                        absolutePositioned: true,
                                                        strokeWidth: 0,
                                                        lockRotation: true,
                                                        selectable: false,
                                                        _isTemMask: true,
                                                        fill: '#ffffff',
                                                        opacity: 0.001
                                                    });
                                                    delete item.isTemMask;
                                                    _canvas.add(item);
                                                    var maskLayer = _canvas.item(_canvas.getObjects().length - 1),
                                                        maskId = maskLayer.get('itemId'),
                                                        defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';
                                                    fabric.Image.fromURL(defaultMaskImageUrl, function (op) {
                                                        var top = maskLayer.get('top'),
                                                            left = maskLayer.get('left'),
                                                            scaleX = maskLayer.get('scaleX'),
                                                            scaleY = maskLayer.get('scaleY'),
                                                            width = maskLayer.get('width'),
                                                            height = maskLayer.get('height'),
                                                            realWidth = width * scaleX,
                                                            realHeight = height * scaleY,
                                                            newWidth = realWidth,
                                                            newHeight = realHeight;
                                                        if ((op.width / op.height) > (realWidth / realHeight)) {
                                                            newWidth = op.width / op.height * newHeight;
                                                        } else {
                                                            newHeight = op.height / op.width * newWidth;
                                                        }
                                                        var d = new Date(),
                                                            itemId = d.getTime() + Math.floor(Math.random() * 1000);
                                                        op.set({
                                                            clipPath: maskLayer,
                                                            perPixelTargetFind: true,
                                                            centeredScaling: true,
                                                            maskId: maskId,
                                                            scaleX: newWidth / op.width,
                                                            scaleY: newHeight / op.height,
                                                            top: top + realHeight / 2,
                                                            left: left + realWidth / 2,
                                                            itemId: itemId,
                                                            isEmptyMask: true,
                                                            srcChanged: false
                                                        });
                                                        if (!!maskLayer.get('forceLock')) op.set({lockMask: true});
                                                        _canvas.add(op);
                                                        continueLoadLayer();
                                                    }, {crossOrigin: 'anonymous'});
                                                });
                                            } else {
                                                klass.fromObject(item, function (item) {
                                                    _canvas.add(item);
                                                    continueLoadLayer();
                                                });
                                            }
                                        } else {
                                            continueLoadLayer();
                                        }
                                    }
                                }
                            }
                        } else {
                            continueLoadLayer();
                        }
                    };
                    loadLayer(layerIndex);
                };
                if (fonts.length) {
                    _.each(fonts, function (font, index) {
                        if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                            if (angular.isDefined(font.file) && angular.isDefined(font.file.r)) $scope.resource.font.data.push(font);
                        }
                        ;
                        if (index == fonts.length - 1) {
                            $scope.insertTemplateFont(font.alias, function () {
                                loadStage(stageIndex);
                                if (!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length) {
                                    $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        } else {
                            $scope.insertTemplateFont(font.alias, function () {
                                if (!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length) {
                                    $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        }
                    });
                } else {
                    loadStage(stageIndex);
                }
            }

            if (local) {
                loadDesign(temp.fonts, temp.design, temp.viewport);
            } else {
                NBDDataFactory.get('nbdesigner_get_product_info', {
                    product_id: NBDESIGNCONFIG['product_id'],
                    variation_id: NBDESIGNCONFIG['variation_id'],
                    template_id: temp.id
                }, function (data) {
                    data = JSON.parse(data);
                    /*advanced*/
                    if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
                        function replaceObjectJson() {
                            var number_side = $scope.settings.product_data.product.length;
                            var a = data.design["frame_" + (number_side - 1)].objects;
                            var objects = a;
                            money = NBDESIGNCONFIG.val_money;
                            var str = money;
                            str = str.replace("&pound;", "£");
                            money = str;
                            for (var i = 0; i < objects.length; i++) {
                                if (objects[i].itemId === "vourcher") {
                                    objects[i].text =
                                        "Vourcher No: " + NBDESIGNCONFIG.id_order +
                                        "\n" +
                                        "Issue Date: " +
                                        NBDESIGNCONFIG.date;
                                }
                            }
                        }

                        replaceObjectJson();
                    }
                    /*advanced*/
                    if (typeof mctp_nbd_js_config_design != "undefined") {
                        if (data.private == 1) {
                            NBDESIGNCONFIG.type_template = 1;
                        } else {
                            NBDESIGNCONFIG.type_template = 0;
                        }
                    }
                    /*advanced*/
                    if (typeof ctcs_nbd_js_config_design != "undefined") {
                        if (Object.keys(data.design).length == 1) {
                            var cc = $scope.resource.jsonDesign;
                            var objs = data.design['frame_0'].objects;
                            cc['frame_' + $scope.currentStage] = {version: "2.3.3", objects: []};
                            cc['frame_' + $scope.currentStage].objects = objs;
                            data.design = cc;
                        }
                    }
                    loadDesign(data.fonts, data.design, data.config.viewport, data.config);
                    if (angular.isDefined(data.design_id)) {
                        NBDESIGNCONFIG.design_id = data.design_id;
                    }
                });
            }
        };
        $scope.boostInsertTemplate = function (local, temp) {
            $scope.currentLocalTempId = temp.id;
            if (angular.isUndefined(temp.doNotShowLoading)) {
                $scope.toggleStageLoading(6E4);
                $scope.showDesignTab();
            }
            $scope.onloadTemplate = true;
            $scope.contextAddLayers = 'template';

            function loadImageFromUrl(img) {
                return new Promise(resolve => {
                    fabric.Image.fromURL(img, op => {
                        resolve(op);
                    }, {crossOrigin: 'anonymous'});
                });
            }

            function loadImageFromObject(object) {
                return new Promise(resolve => {
                    fabric.Image.fromObject(object, function (image) {
                        resolve(image);
                    });
                });
            }

            function applyImageFilters(object) {
                return new Promise(resolve => {
                    object.applyFilters(false, function () {
                        setTimeout(() => resolve(object));
                    }, true);
                });
            }

            function loadLayerFromObject(klass, object) {
                return new Promise(resolve => {
                    klass.fromObject(object, function (obj) {
                        resolve(obj);
                    });
                });
            }

            async function loadPhotoFrameFromObject(klass, object) {
                let item = await loadLayerFromObject(klass, object);
                item.set({
                    isMask: 1,
                    absolutePositioned: true,
                    strokeWidth: 0,
                    lockRotation: true,
                    selectable: false,
                    _isTemMask: true,
                    fill: '#ffffff',
                    opacity: 0.001
                });
                delete item.isTemMask;

                let maskId = item.itemId,
                    defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';

                let op = await loadImageFromUrl(defaultMaskImageUrl);
                var top = item.get('top'),
                    left = item.get('left'),
                    scaleX = item.get('scaleX'),
                    scaleY = item.get('scaleY'),
                    width = item.get('width'),
                    height = item.get('height'),
                    realWidth = width * scaleX,
                    realHeight = height * scaleY,
                    newWidth = realWidth,
                    newHeight = realHeight;
                if ((op.width / op.height) > (realWidth / realHeight)) {
                    newWidth = op.width / op.height * newHeight;
                } else {
                    newHeight = op.height / op.width * newWidth;
                }
                var d = new Date(),
                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                op.set({
                    clipPath: item,
                    perPixelTargetFind: true,
                    centeredScaling: true,
                    maskId: maskId,
                    scaleX: newWidth / op.width,
                    scaleY: newHeight / op.height,
                    top: top + realHeight / 2,
                    left: left + realWidth / 2,
                    itemId: itemId,
                    isEmptyMask: true,
                    srcChanged: false
                });
                if (!!item.get('forceLock')) op.set({lockMask: true});

                return {
                    layer: item,
                    holder: op
                }
            }

            function generateVcard(object) {
                return new Promise(resolve => {
                    $scope.generateVcard(function (newObject) {
                        var config = {
                            left: object.left,
                            top: object.top,
                            scaleX: object.scaleX,
                            scaleY: object.scaleY,
                            fill: object.fill
                        };
                        newObject.set(config);
                        newObject.scaleToWidth(object.width * object.scaleX);
                        newObject.scaleToWidth(object.width * object.scaleX);

                        resolve(newObject);
                    });
                });
            }

            function loadDesign(fonts, design, viewport, konfig) {
                async function loadStages() {
                    async function loadLayer(object, objectIndex, stageIndex) {
                        let layer, photoHolder,
                            type = object.type,
                            stage = $scope.stages[stageIndex];
                        if (type == 'image' || type == 'custom-image') {
                            if (appConfig.domainChanged) {
                                var _src = object.src;
                                var src = _src.split('nbdesigner');
                                if (src.length == 2) {
                                    object.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                                }
                                var src2 = _src.split('web-to-print-online-designer/assets/');
                                if (src2.length == 2) {
                                    object.src = NBDESIGNCONFIG['assets_url'] + src2[1];
                                }
                            }
                            ;
                            layer = await loadImageFromObject(object);
                            if (layer.filters.length) {
                                layer = await applyImageFilters(layer);
                            }
                        } else {
                            var klass = fabric.util.getKlass(type);
                            if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(type) > -1) {
                                if (!_.filter(stage.states.usedFonts, ['alias', object.fontFamily]).length) {
                                    stage.states.usedFonts.push($scope.getFontInfo(object.fontFamily));
                                }
                                ;
                            }
                            ;
                            if (angular.isDefined(object.field_mapping) && !$scope.isTemplateMode) {
                                var field = _.filter($scope.settings.template_fields, {key: object.field_mapping})[0];
                                if (angular.isDefined(field)) {
                                    if (field.value != '') {
                                        if (angular.isDefined(object.is_uppercase)) {
                                            object.text = object.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                        } else {
                                            object.text = field.value;
                                        }
                                    } else {
                                        var mapping_field = _.filter($scope.templateHolderFields, {key: object.field_mapping})[0];
                                        if (angular.isUndefined(mapping_field)) {
                                            $scope.templateHolderFields.push(JSON.parse(JSON.stringify(field)));
                                        }
                                    }
                                }
                            }

                            if (angular.isDefined(object.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1') {
                                layer = await generateVcard(object);
                            } else {
                                if (type == 'text') {
                                    var text = object.text;
                                    var textobj = {};
                                    angular.copy(object, textobj);
                                    delete textobj.text;
                                    delete textobj.type;
                                    layer = new fabric.IText(text, textobj);
                                } else if (!!object.isTemMask && !$scope.isTemplateMode) {
                                    let res = await loadPhotoFrameFromObject(klass, object);
                                    layer = res.layer;
                                    photoHolder = res.holder;
                                } else {
                                    layer = await loadLayerFromObject(klass, object);
                                }
                            }
                        }
                        return {
                            layer: layer,
                            itemId: layer.itemId,
                            photoHolder: photoHolder
                        };
                    }

                    async function loadStage(stageIndex) {
                        var _index = 'frame_' + stageIndex,
                            stage = $scope.stages[stageIndex],
                            _canvas = stage['canvas'],
                            layers = [],
                            photoHolders = [];
                        _canvas.clear();
                        if (angular.isUndefined(design[_index])) {
                            design[_index] = {version: "3.4.0", objects: []};
                        }
                        ;
                        if (angular.isDefined(design[_index].background)) {
                            _canvas.setBackgroundColor(design[_index].background);
                        }
                        ;
                        var objects = design[_index].objects;

                        await Promise.all(objects.map(async (object, objectIndex) => {
                            let res = await loadLayer(object, objectIndex, stageIndex);
                            layers[objectIndex] = res.layer;
                            if (res.photoHolder) {
                                photoHolders.push({itemId: res.itemId, photoHolder: res.photoHolder});
                            }
                        }));

                        photoHolders.map(photoHolder => {
                            let holderIndex;
                            layers.map((layer, layerIndex) => {
                                if (photoHolder.itemId == layer.itemId) holderIndex = layerIndex;
                            });
                            layers.splice(holderIndex + 1, 0, photoHolder.photoHolder);
                        });

                        layers.map(layer => {
                            _canvas.add(layer);
                        });
                        return true;
                    }

                    await Promise.all($scope.stages.map(async (stage, stageIndex) => {
                        await loadStage(stageIndex);
                    }));

                    _.each($scope.stages, function (_stage, index) {
                        $scope.renderStage(index);
                        var layers = _stage.canvas.getObjects();
                        $scope.renderTextAfterLoadFont(layers, function () {
                            $scope.deactiveAllLayer();
                            $scope.renderStage(index);
                            $timeout(function () {
                                $scope.deactiveAllLayer();
                                $scope.renderStage(index);
                                if (index == $scope.stages.length - 1) {
                                    $scope.onloadTemplate = false;
                                    $scope.contextAddLayers = 'normal';
                                    if (angular.isDefined(viewport)) {
                                        $scope.resizeStages(viewport);
                                    } else if (angular.isDefined(konfig) && angular.isDefined(konfig.scale)) {
                                        viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                                        $scope.resizeStages(viewport);
                                    } else {
                                        $scope.toggleStageLoading();
                                    }
                                    $scope.afterInsertTemplate();
                                }
                            }, 500);
                        });
                    });

                    return true;
                }

                if (fonts.length) {
                    _.each(fonts, function (font, index) {
                        if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                            if (angular.isDefined(font.file) && angular.isDefined(font.file.r)) $scope.resource.font.data.push(font);
                        }
                        ;
                        if (index == fonts.length - 1) {
                            $scope.insertTemplateFont(font.alias, function () {
                                loadStages();
                                if (!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length) {
                                    $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        } else {
                            $scope.insertTemplateFont(font.alias, function () {
                                if (!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length) {
                                    $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        }
                    });
                } else {
                    loadStages();
                }
            }

            if (local) {
                loadDesign(temp.fonts, temp.design, temp.viewport);
            } else {
                NBDDataFactory.get('nbdesigner_get_product_info', {
                    product_id: NBDESIGNCONFIG['product_id'],
                    variation_id: NBDESIGNCONFIG['variation_id'],
                    template_id: temp.id
                }, function (data) {
                    data = JSON.parse(data);
                    loadDesign(data.fonts, data.design, data.config.viewport, data.config);
                    if (angular.isDefined(data.design_id)) {
                        NBDESIGNCONFIG.design_id = data.design_id;
                    }
                });
            }
        };
        $scope._currentTempId = 0;
        $scope._currentpartIndex = 0;
        $scope.insertPartTemplate = function (tempId, partIndex) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                layers = _canvas.getObjects();
            if (layers.length > 0) {
                $scope._currentTempId = tempId;
                $scope._currentpartIndex = partIndex;
                jQuery('.nbd-popup.insert-part-template-alert').nbShowPopup();
            } else {
                $scope._insertPartTemplate(tempId, partIndex);
            }
        };
        $scope.closePopupInertPartTem = function () {
            jQuery('.insert-part-template-alert .close-popup').triggerHandler('click');
        };
        $scope._insertPartTemplate = function (temp, partIndex) {
            $scope.onloadTemplate = true;
            $scope.contextAddLayers = 'template';
            $scope.toggleStageLoading();
            jQuery('.insert-part-template-alert .close-popup').triggerHandler('click');

            function loadDesign(fonts, design, viewport, konfig) {
                var _index = 'frame_' + partIndex;
                if (angular.isUndefined(design[_index])) {
                    return;
                }
                ;
                var layerIndex = 0,
                    stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'],
                    objects = design[_index].objects;

                function loadStage() {
                    _canvas.clear();

                    function loadLayer(layerIndex) {
                        function continueLoadLayer() {
                            layerIndex++;
                            if (objects.length != 0 && layerIndex < objects.length) {
                                loadLayer(layerIndex);
                            } else {
                                $scope.renderStage($scope.currentStage);
                                var layers = _canvas.getObjects();
                                $scope.renderTextAfterLoadFont(layers, function () {
                                    $scope.deactiveAllLayer();
                                    $scope.renderStage($scope.currentStage);
                                    $timeout(function () {
                                        $scope.deactiveAllLayer();
                                        $scope.renderStage($scope.currentStage);
                                        $scope.onloadTemplate = false;
                                        $scope.contextAddLayers = 'normal';
                                        if (angular.isDefined(viewport)) {
                                            $scope.resizeStage(viewport);
                                        } else if (angular.isDefined(konfig) && angular.isDefined(konfig.scale)) {
                                            viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                                            $scope.resizeStage(viewport);
                                        } else {
                                            $scope.toggleStageLoading();
                                        }
                                    }, 100);
                                });
                            }
                        }

                        if (objects.length > 0) {
                            var item = objects[layerIndex],
                                type = item.type;
                            if (type == 'image' || type == 'custom-image') {
                                if (appConfig.domainChanged) {
                                    var _src = item.src;
                                    var src = _src.split('nbdesigner');
                                    if (src.length == 2) {
                                        item.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                                    }
                                }
                                fabric.Image.fromObject(item, function (_image) {
                                    _canvas.add(_image);
                                    continueLoadLayer();
                                });
                            } else {
                                var klass = fabric.util.getKlass(type);
                                if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(type) > -1) {
                                    if (!_.filter(stage.states.usedFonts, ['alias', item.fontFamily]).length) {
                                        stage.states.usedFonts.push($scope.getFontInfo(item.fontFamily));
                                    }
                                    ;
                                }
                                ;
                                if (angular.isDefined(item.field_mapping) && !$scope.isTemplateMode) {
                                    var field = _.filter($scope.settings.template_fields, {key: item.field_mapping})[0];
                                    if (angular.isDefined(field)) {
                                        if (field.value != '') {
                                            if (angular.isDefined(item.is_uppercase)) {
                                                item.text = item.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                            } else {
                                                item.text = field.value;
                                            }
                                        } else {
                                            var mapping_field = _.filter($scope.templateHolderFields, {key: item.field_mapping})[0];
                                            if (angular.isUndefined(mapping_field)) {
                                                $scope.templateHolderFields.push(JSON.parse(JSON.stringify(field)));
                                            }
                                        }
                                    }
                                }
                                if (angular.isDefined(item.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1') {
                                    $scope.generateVcard(function (newObject) {
                                        var config = {
                                            left: item.left,
                                            top: item.top,
                                            scaleX: item.scaleX,
                                            scaleY: item.scaleY
                                        };
                                        newObject.set(config);
                                        newObject.scaleToWidth(item.width * item.scaleX);
                                        newObject.scaleToWidth(item.width * item.scaleX);
                                        _canvas.add(newObject);
                                        continueLoadLayer();
                                    });
                                } else {
                                    if (type == 'text') {
                                        var text = item.text;
                                        var textobj = {};
                                        angular.copy(item, textobj);
                                        delete textobj.text;
                                        delete textobj.type;
                                        var textbox = new fabric.IText(text, textobj);
                                        _canvas.add(textbox);
                                        continueLoadLayer();
                                    } else if (!!item.isTemMask && !$scope.isTemplateMode) {
                                        klass.fromObject(item, function (item) {
                                            item.set({
                                                isMask: 1,
                                                absolutePositioned: true,
                                                strokeWidth: 0,
                                                lockRotation: true,
                                                selectable: false,
                                                fill: '#ffffff',
                                                _isTemMask: true,
                                                opacity: 0.001
                                            });
                                            delete item.isTemMask;
                                            _canvas.add(item);
                                            var maskLayer = _canvas.item(_canvas.getObjects().length - 1),
                                                maskId = maskLayer.get('itemId'),
                                                defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';
                                            fabric.Image.fromURL(defaultMaskImageUrl, function (op) {
                                                var top = maskLayer.get('top'),
                                                    left = maskLayer.get('left'),
                                                    scaleX = maskLayer.get('scaleX'),
                                                    scaleY = maskLayer.get('scaleY'),
                                                    width = maskLayer.get('width'),
                                                    height = maskLayer.get('height'),
                                                    realWidth = width * scaleX,
                                                    realHeight = height * scaleY,
                                                    newWidth = realWidth,
                                                    newHeight = realHeight;
                                                if ((op.width / op.height) > (realWidth / realHeight)) {
                                                    newWidth = op.width / op.height * newHeight;
                                                } else {
                                                    newHeight = op.height / op.width * newWidth;
                                                }
                                                var d = new Date(),
                                                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                                                op.set({
                                                    clipPath: maskLayer,
                                                    perPixelTargetFind: true,
                                                    centeredScaling: true,
                                                    maskId: maskId,
                                                    scaleX: newWidth / op.width,
                                                    scaleY: newHeight / op.height,
                                                    top: top + realHeight / 2,
                                                    left: left + realWidth / 2,
                                                    itemId: itemId,
                                                    isEmptyMask: true,
                                                    srcChanged: false
                                                });
                                                if (!!maskLayer.get('forceLock')) op.set({lockMask: true});
                                                _canvas.add(op);
                                                continueLoadLayer();
                                            }, {crossOrigin: 'anonymous'});
                                        });
                                    } else {
                                        klass.fromObject(item, function (item) {
                                            _canvas.add(item);
                                            continueLoadLayer();
                                        });
                                    }
                                }
                            }
                        } else {
                            $scope.onloadTemplate = false;
                            $scope.toggleStageLoading();
                        }
                    }

                    loadLayer(layerIndex);
                }

                async function boostLoadLayer() {
                    _canvas.clear();

                    function loadImageFromUrl(img) {
                        return new Promise(resolve => {
                            fabric.Image.fromURL(img, op => {
                                resolve(op);
                            }, {crossOrigin: 'anonymous'});
                        });
                    }

                    function loadImageFromObject(object) {
                        return new Promise(resolve => {
                            fabric.Image.fromObject(object, function (image) {
                                resolve(image);
                            });
                        });
                    }

                    function applyImageFilters(object) {
                        return new Promise(resolve => {
                            object.applyFilters(false, function () {
                                setTimeout(() => resolve(object));
                            }, true);
                        });
                    }

                    function loadLayerFromObject(klass, object) {
                        return new Promise(resolve => {
                            klass.fromObject(object, function (obj) {
                                resolve(obj);
                            });
                        });
                    }

                    async function loadPhotoFrameFromObject(klass, object) {
                        let item = await loadLayerFromObject(klass, object);
                        item.set({
                            isMask: 1,
                            absolutePositioned: true,
                            strokeWidth: 0,
                            lockRotation: true,
                            selectable: false,
                            _isTemMask: true,
                            fill: '#ffffff',
                            opacity: 0.001
                        });
                        delete item.isTemMask;

                        let maskId = item.itemId,
                            defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';

                        let op = await loadImageFromUrl(defaultMaskImageUrl);
                        var top = item.get('top'),
                            left = item.get('left'),
                            scaleX = item.get('scaleX'),
                            scaleY = item.get('scaleY'),
                            width = item.get('width'),
                            height = item.get('height'),
                            realWidth = width * scaleX,
                            realHeight = height * scaleY,
                            newWidth = realWidth,
                            newHeight = realHeight;
                        if ((op.width / op.height) > (realWidth / realHeight)) {
                            newWidth = op.width / op.height * newHeight;
                        } else {
                            newHeight = op.height / op.width * newWidth;
                        }
                        var d = new Date(),
                            itemId = d.getTime() + Math.floor(Math.random() * 1000);
                        op.set({
                            clipPath: item,
                            perPixelTargetFind: true,
                            centeredScaling: true,
                            maskId: maskId,
                            scaleX: newWidth / op.width,
                            scaleY: newHeight / op.height,
                            top: top + realHeight / 2,
                            left: left + realWidth / 2,
                            itemId: itemId,
                            isEmptyMask: true,
                            srcChanged: false
                        });
                        if (!!item.get('forceLock')) op.set({lockMask: true});

                        return {
                            layer: item,
                            holder: op
                        }
                    }

                    function generateVcard(object) {
                        return new Promise(resolve => {
                            $scope.generateVcard(function (newObject) {
                                var config = {
                                    left: object.left,
                                    top: object.top,
                                    scaleX: object.scaleX,
                                    scaleY: object.scaleY,
                                    fill: object.fill
                                };
                                newObject.set(config);
                                newObject.scaleToWidth(object.width * object.scaleX);
                                newObject.scaleToWidth(object.width * object.scaleX);

                                resolve(newObject);
                            });
                        });
                    }

                    async function loadLayer(object) {
                        let layer, photoHolder,
                            type = object.type;
                        if (type == 'image' || type == 'custom-image') {
                            if (appConfig.domainChanged) {
                                var _src = object.src;
                                var src = _src.split('nbdesigner');
                                if (src.length == 2) {
                                    object.src = NBDESIGNCONFIG['nbd_content_url'] + src[1];
                                }
                                var src2 = _src.split('web-to-print-online-designer/assets/');
                                if (src2.length == 2) {
                                    object.src = NBDESIGNCONFIG['assets_url'] + src2[1];
                                }
                            }
                            ;
                            layer = await loadImageFromObject(object);
                            if (layer.filters.length) {
                                layer = await applyImageFilters(layer);
                            }
                        } else {
                            var klass = fabric.util.getKlass(type);
                            if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(type) > -1) {
                                if (!_.filter(stage.states.usedFonts, ['alias', object.fontFamily]).length) {
                                    stage.states.usedFonts.push($scope.getFontInfo(object.fontFamily));
                                }
                                ;
                            }
                            ;
                            if (angular.isDefined(object.field_mapping) && !$scope.isTemplateMode) {
                                var field = _.filter($scope.settings.template_fields, {key: object.field_mapping})[0];
                                if (angular.isDefined(field)) {
                                    if (field.value != '') {
                                        if (angular.isDefined(object.is_uppercase)) {
                                            object.text = object.is_uppercase ? field.value.toUpperCase() : field.value.toLowerCase();
                                        } else {
                                            object.text = field.value;
                                        }
                                    } else {
                                        var mapping_field = _.filter($scope.templateHolderFields, {key: object.field_mapping})[0];
                                        if (angular.isUndefined(mapping_field)) {
                                            $scope.templateHolderFields.push(JSON.parse(JSON.stringify(field)));
                                        }
                                    }
                                }
                            }

                            if (angular.isDefined(object.v_card) && !$scope.isTemplateMode && $scope.settings.is_logged == '1') {
                                layer = await generateVcard(object);
                            } else {
                                if (type == 'text') {
                                    var text = object.text;
                                    var textobj = {};
                                    angular.copy(object, textobj);
                                    delete textobj.text;
                                    delete textobj.type;
                                    layer = new fabric.IText(text, textobj);
                                } else if (!!object.isTemMask && !$scope.isTemplateMode) {
                                    let res = await loadPhotoFrameFromObject(klass, object);
                                    layer = res.layer;
                                    photoHolder = res.holder;
                                } else {
                                    layer = await loadLayerFromObject(klass, object);
                                }
                            }
                        }
                        return {
                            layer: layer,
                            itemId: layer.itemId,
                            photoHolder: photoHolder
                        };
                    }

                    var layers = [],
                        photoHolders = [];

                    await Promise.all(objects.map(async (object, objectIndex) => {
                        let res = await loadLayer(object);
                        layers[objectIndex] = res.layer;
                        if (res.photoHolder) {
                            photoHolders.push({itemId: res.itemId, photoHolder: res.photoHolder});
                        }
                    }));

                    photoHolders.map(photoHolder => {
                        let holderIndex;
                        layers.map((layer, layerIndex) => {
                            if (photoHolder.itemId == layer.itemId) holderIndex = layerIndex;
                        });
                        layers.splice(holderIndex + 1, 0, photoHolder.photoHolder);
                    });

                    layers.map(layer => {
                        _canvas.add(layer);
                    });

                    $scope.renderStage($scope.currentStage);
                    var layers = _canvas.getObjects();
                    $scope.renderTextAfterLoadFont(layers, function () {
                        $scope.deactiveAllLayer();
                        $scope.renderStage($scope.currentStage);
                        $timeout(function () {
                            $scope.deactiveAllLayer();
                            $scope.renderStage($scope.currentStage);
                            $scope.onloadTemplate = false;
                            $scope.contextAddLayers = 'normal';
                            if (angular.isDefined(viewport)) {
                                $scope.resizeStage(viewport);
                            } else if (angular.isDefined(konfig) && angular.isDefined(konfig.scale)) {
                                viewport = {width: konfig.scale * 500, height: konfig.scale * 500};
                                $scope.resizeStage(viewport);
                            } else {
                                $scope.toggleStageLoading();
                            }
                        }, 100);
                    });

                    return true;
                }

                if (fonts.length) {
                    _.each(fonts, function (font, index) {
                        if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                            if (angular.isDefined(font.file) && angular.isDefined(font.file.r)) $scope.resource.font.data.push(font);
                        }
                        ;
                        if (index == fonts.length - 1) {
                            $scope.insertTemplateFont(font.alias, function () {
                                if ($scope.settings.nbdesigner_boosting_load_template == 'yes') {
                                    boostLoadLayer();
                                } else {
                                    loadStage();
                                }
                                if (!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length) {
                                    $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        } else {
                            $scope.insertTemplateFont(font.alias, function () {
                                if (!_.filter($scope.resource.usedFonts, ['alias', font.alias]).length) {
                                    $scope.resource.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        }
                    });
                } else {
                    if ($scope.settings.nbdesigner_boosting_load_template == 'yes') {
                        boostLoadLayer();
                    } else {
                        loadStage();
                    }
                }
            }

            NBDDataFactory.get('nbdesigner_get_product_info', {
                product_id: NBDESIGNCONFIG['product_id'],
                variation_id: NBDESIGNCONFIG['variation_id'],
                template_id: temp
            }, function (data) {
                data = JSON.parse(data);
                if (angular.isDefined(data.design)) {
                    $scope.setHistory($scope.currentStage, true);
                    loadDesign(data.fonts, data.design, data.config.viewport, data.config);
                } else {
                    $scope.onloadTemplate = false;
                    $scope.contextAddLayers = 'normal';
                    $scope.toggleStageLoading();
                }
            });
        };
        $scope.resizeStage = function (viewport, stage_id, wihoutLoading) {
            var stage = angular.isDefined(stage_id) ? $scope.stages[stage_id] : $scope.stages[$scope.currentStage];
            var currentViewport = $scope.viewPort;
            var newFitRec = $scope.fitRectangle(viewport.width, viewport.height, stage.config._width, stage.config._height, true);
            var oldFitRec = $scope.fitRectangle(currentViewport.width, currentViewport.height, stage.config._width, stage.config._height, true);
            var factor = oldFitRec.width / newFitRec.width;
            if (factor != 1) {
                stage.canvas.forEachObject(function (obj) {
                    var scaleX = obj.scaleX,
                        scaleY = obj.scaleY,
                        left = obj.left,
                        top = obj.top,
                        tempScaleX = scaleX * factor,
                        tempScaleY = scaleY * factor,
                        tempLeft = left * factor,
                        tempTop = top * factor;
                    obj.scaleX = tempScaleX;
                    obj.scaleY = tempScaleY;
                    obj.left = tempLeft;
                    obj.top = tempTop;
                    if (obj.clipPath && obj.clipPath.absolutePositioned & !obj.clipPath._isTemMask) {
                        var scaleX = obj.clipPath.scaleX,
                            scaleY = obj.clipPath.scaleY,
                            left = obj.clipPath.left,
                            top = obj.clipPath.top,
                            tempScaleX = scaleX * factor,
                            tempScaleY = scaleY * factor,
                            tempLeft = left * factor,
                            tempTop = top * factor;
                        obj.clipPath.scaleX = tempScaleX;
                        obj.clipPath.scaleY = tempScaleY;
                        obj.clipPath.left = tempLeft;
                        obj.clipPath.top = tempTop;
                    }
                    if (obj.clipPath && obj.clipPath.absolutePositioned & obj.clipPath._isTemMask) {
                        delete obj.clipPath._isTemMask;
                    }
                    obj.setCoords();
                });
                stage.canvas.calcOffset();
                $scope.renderStage($scope.currentStage);
            }
            if (!wihoutLoading) $scope.toggleStageLoading();
        };
        $scope.resizeStages = function (viewport) {
            _.each($scope.stages, function (stage, index) {
                var currentViewport = $scope.viewPort;
                var newFitRec = $scope.fitRectangle(viewport.width, viewport.height, stage.config._width, stage.config._height, true);
                var oldFitRec = $scope.fitRectangle(currentViewport.width, currentViewport.height, stage.config._width, stage.config._height, true);
                var factor = oldFitRec.width / newFitRec.width;
                if (factor != 1) {
                    stage.canvas.forEachObject(function (obj) {
                        var scaleX = obj.scaleX,
                            scaleY = obj.scaleY,
                            left = obj.left,
                            top = obj.top,
                            tempScaleX = scaleX * factor,
                            tempScaleY = scaleY * factor,
                            tempLeft = left * factor,
                            tempTop = top * factor;

                        obj.scaleX = tempScaleX;
                        obj.scaleY = tempScaleY;

                        obj.left = tempLeft;
                        obj.top = tempTop;

                        if (obj.clipPath && obj.clipPath.absolutePositioned & !obj.clipPath._isTemMask) {
                            var scaleX = obj.clipPath.scaleX,
                                scaleY = obj.clipPath.scaleY,
                                left = obj.clipPath.left,
                                top = obj.clipPath.top,
                                tempScaleX = scaleX * factor,
                                tempScaleY = scaleY * factor,
                                tempLeft = left * factor,
                                tempTop = top * factor;
                            obj.clipPath.scaleX = tempScaleX;
                            obj.clipPath.scaleY = tempScaleY;
                            obj.clipPath.left = tempLeft;
                            obj.clipPath.top = tempTop;
                        }
                        if (obj.clipPath && obj.clipPath.absolutePositioned & obj.clipPath._isTemMask) {
                            delete obj.clipPath._isTemMask;
                        }
                        obj.setCoords();
                    });
                    stage.canvas.calcOffset();
                    $scope.renderStage(index);
                }
                if (index == $scope.stages.length - 1) {
                    $scope.toggleStageLoading();
                }
            });
        };
        $scope.insertTypography = function (typo) {
            if (!$scope.canAddMoreLayer()) return;
            var stage = $scope.stages[$scope.currentStage],
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                _canvas = stage['canvas'];
            $scope.toggleStageLoading();
            $scope.showDesignTab();
            NBDDataFactory.get('nbd_get_resource', {type: 'get_typo', folder: typo.folder}, function (data) {
                data = JSON.parse(data);
                var fonts = data.data.font,
                    layers = data.data.design.frame_0.objects;
                $scope.resource.tempData.template = [];

                function loadLayers() {
                    _.each(layers, function (layer, _index) {
                        if (_index == layers.length - 1) {
                            $scope.loadTemplateLayer(layer, function () {
                                $scope.renderTextAfterLoadFont($scope.resource.tempData.template, function () {
                                    var selection = new fabric.ActiveSelection($scope.resource.tempData.template, {
                                        canvas: _canvas
                                    });
                                    _canvas.setActiveObject(selection);
                                    selection.addWithUpdate();
                                    if ((selection.width * scale) > (_canvas.width * 0.8)) {
                                        var canvasWidth = _canvas.width;
                                        selection.scaleX = selection.scaleX * canvasWidth * 0.8 / (selection.width * scale);
                                        selection.scaleY = selection.scaleY * canvasWidth * 0.8 / (selection.width * scale);
                                        selection.width = selection.width * canvasWidth * 0.8 / (selection.width * scale);
                                        selection.addWithUpdate();
                                        if ((selection.height * scale) > (_canvas.height * 0.8)) {
                                            var canvasHeight = _canvas.height;
                                            selection.scaleX = selection.scaleX * canvasHeight * 0.8 / (selection.height * scale);
                                            selection.scaleY = selection.scaleY * canvasHeight * 0.8 / (selection.height * scale);
                                            selection.height = selection.height * canvasHeight * 0.8 / (selection.height * scale);
                                            selection.addWithUpdate();
                                        }
                                    }
                                    _canvas.viewportCenterObjectH(selection);
                                    _canvas.viewportCenterObjectV(selection);
                                    $scope.renderStage();
                                    $timeout(function () {
                                        $scope.deactiveAllLayer();
                                        _canvas.setActiveObject(selection);
                                        selection.addWithUpdate();
                                        _canvas.viewportCenterObjectH(selection);
                                        _canvas.viewportCenterObjectV(selection);
                                        if (stage.config.area_design_type == "2") $scope.setStackLayerAlwaysOnTop();
                                        $scope.renderStage();
                                        $scope.toggleStageLoading();
                                        $scope.setHistory($scope.currentStage, true);
                                    }, 500);
                                });
                            });
                        } else {
                            $scope.loadTemplateLayer(layer);
                        }
                    });
                };
                if (fonts.length) {
                    _.each(fonts, function (font, index) {
                        if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                            $scope.resource.font.data.push(font);
                        }
                        ;
                        if (index == fonts.length - 1) {
                            $scope.insertTemplateFont(font.alias, function () {
                                loadLayers();
                                if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                    stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        } else {
                            $scope.insertTemplateFont(font.alias, function () {
                                if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                    stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                                }
                                ;
                            });
                        }
                    });
                } else {
                    loadLayers();
                }
            });
        };
        $scope.renderTextAfterLoadFont = function (layers, callback) {
            if (layers.length == 0) {
                callback();
                return;
            }
            ;
            _.each(layers, function (item, index) {
                /*advanced*/
                if (typeof mia_nbd_js_config_design != "undefined") {
                    if (item.elementUpload && angular.isUndefined(item.clickUpload)) {
                        item.clickUpload = true;
                    }
                }
                if (['text', 'i-text', 'curvedText', 'textbox'].indexOf(item.type) > -1) {
                    var fontFamily = item.get('fontFamily'),
                        fontWeight = item.get('fontWeight'),
                        fontStyle = item.get('fontStyle'),
                        _font = $scope.getFontInfo(fontFamily);
                    var opt = {};
                    if (fontWeight != '') opt.weight = fontWeight;
                    if (fontStyle != '') opt.style = fontStyle;
                    item.set({objectCaching: false});
                    fabric.util.clearFabricFontCache();
                    var font = new FontFaceObserver(fontFamily, {weight: fontWeight, style: fontStyle});
                    font.load($scope.settings.subsets[_font.subset]['preview_text']).then(function () {
                        fabric.util.clearFabricFontCache();
                        item.initDimensions();
                        item.setCoords();
                    }, function () {
                        /* todo */
                    });
                }
                ;
                if (index == (layers.length - 1) && typeof callback == 'function') {
                    callback();
                }
            });
        };
        $scope.loadTemplateLayer = function (json, callback, stage_id) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            var stage = $scope.stages[stage_id],
                _canvas = stage['canvas'];
            var klass = fabric.util.getKlass(json.type);
            klass.fromObject(json, function (item) {
                $scope.contextAddLayers = 'template';
                _canvas.add(item);
                if (item.maskId) {
                    $scope.contextAddLayers = 'addMask';
                    _canvas.add(item.clipPath);
                }
                var _item = _canvas.item(_canvas.getObjects().length - 1);
                $scope.resource.tempData.template.push(_item);
                if (typeof callback == 'function') callback();
            });
        };
        $scope.loadTemplatesLayers = function (objects, callback) {
            objects = objects || [];

            var enlivenedObjects = [],
                numLoadedObjects = 0,
                numTotalObjects = objects.length;

            function onLoaded() {
                if (++numLoadedObjects === numTotalObjects) {
                    callback && callback(enlivenedObjects.filter(function (obj) {
                        // filter out undefined objects (objects that gave error)
                        return obj;
                    }));
                }
            }

            if (!numTotalObjects) {
                callback && callback(enlivenedObjects);
                return;
            }

            objects.forEach(function (o, index) {
                // if sparse array
                if (!o || !o.type) {
                    onLoaded();
                    return;
                }
                var klass = fabric.util.getKlass(o.type);
                klass.fromObject(o, function (obj, error) {
                    error || (enlivenedObjects[index] = obj);
                    onLoaded();
                });
            });
        };
        $scope.insertCanvaTypo = function (typo) {
            if ($scope.settings.task != 'typography') {
                $scope.insertTypography(typo);
                return;
            }
            ;
            $scope.stages[0].states.usedFonts = [];
            $scope.zoomStage(0);
            var url = $scope.generateTypoLink(typo);
            $scope.resource.currentTypo = typo.id;
            var svg_url = url.replace("png", "svg"),
                svg_url = svg_url.replace("/img/", "/svg/"),
                _stages = $scope.stages[0],
                _canvas = _stages['canvas'];
            _canvas.clear();
            $scope.toggleStageLoading();

            function validFontName(fontName) {
                fontName = fontName.replace(/'/g, "");
                fontName = fontName.split("-")[0];
                fontName = fontName.replace(/([A-Z])/g, ' $1').trim();
                return fontName;
            };
            fabric.Image.fromURL(url, function (op) {
                _stages.config.width = op.width;
                _stages.config.height = op.height;
                _canvas.setDimensions({'width': op.width, 'height': op.height});
                fabric.loadSVGFromURL(svg_url, function (ob, op) {
                    _canvas.add((fabric.util.groupSVGElements(ob, op)).set({
                        scaleX: _stages.config.width / op.width,
                        scaleY: _stages.config.height / op.height
                    }));
                    $scope.renderStage(0);
                    $timeout(function () {
                        var object = _canvas.getActiveObject();
                        var textIndexArr = [],
                            count = 0;
                        _.each(object._objects, function (path, index) {
                            if (angular.isDefined(path.text)) {
                                var color = tinycolor(path.get('fill')).toHexString();
                                color = color.toLowerCase() == '#ffffff' ? '#404762' : color;
                                textIndexArr.push({
                                    index: index,
                                    type: 'text',
                                    text: path.text,
                                    font: validFontName(path.fontFamily),
                                    fill: color
                                });
                            }
                            if (path.get('fill') == '') {
                                textIndexArr.push({index: index, type: 'empty_rect'});
                            }
                            ;
                        });
                        object.set({dirty: true});
                        _.each(textIndexArr, function (el, index) {
                            var _index = el.index - count;
                            object._objects.splice(_index, 1);
                            count++;
                            if (el.type == 'text') {
                                var _text = new FabricWindow.IText(el.text, {
                                    radius: 50,
                                    fontSize: 20,
                                    noScaleCache: false,
                                    fill: el.fill,
                                    lockUniScaling: true,
                                    lockRotation: true,
                                    spacing: 0
                                });
                                _text["setControlVisible"]("mtr", false);
                                if (index < _.findLastIndex(textIndexArr, function (o) {
                                    return o.type == 'text';
                                })) {
                                    $scope.insertTemplateFont(el.font, function (fontName) {
                                        _text.set({fontFamily: fontName});
                                        _canvas.add(_text);
                                        if (!_.filter(_stages.states.usedFonts, ['alias', fontName]).length) {
                                            _stages.states.usedFonts.push($scope.getFontInfo(fontName));
                                        }
                                        ;
                                    });
                                } else {
                                    $scope.insertTemplateFont(el.font, function (fontName) {
                                        _text.set({fontFamily: fontName});
                                        _canvas.add(_text);
                                        if (!_.filter(_stages.states.usedFonts, ['alias', fontName]).length) {
                                            _stages.states.usedFonts.push($scope.getFontInfo(fontName));
                                        }
                                        ;
                                        $scope.renderStage(0);
                                        $scope.toggleStageLoading();
                                        $scope.updateLayersList();
                                    });
                                }
                            }
                        });
                    }, 1000);
                });
            }, {crossOrigin: 'anonymous'});
        };
        /* History */
        $scope.itemToJson = function (item, params) {
            if (params) {
                return JSON.stringify(params);
            } else {
                return JSON.stringify(item);
            }
        };
        $scope.setItemParameters = function (parameters, itemId) {
            var params = JSON.parse(parameters),
                _canvas = this.stages[this.currentStage]['canvas'],
                item = _canvas.item(this.getLayerById(itemId));
            if (typeof params.src !== "undefined") {
                fabric.Image.fromURL(params.src, function (op) {
                    item.getElement().setAttribute("src", params.src);
                }, {crossOrigin: 'anonymous'});
            }
            item.set(params);
            item.setCoords();
        };
        $scope.undo = function () {
            var _stage = this.stages[this.currentStage],
                _canvas = _stage['canvas'];
            if (_stage.undos.length > 1) {
                var last = _stage.undos.pop(),
                    nexttoLast = _stage.undos[_stage.undos.length - 1];
                $scope._loadStageFromJson($scope.currentStage, nexttoLast);
                $scope.setHistory($scope.currentStage, false, last, true);
                $scope.deactiveAllLayer();
                this.renderStage();

                if ($scope.resource.shareDesign) {
                    if (NBDESIGNCONFIG['ui_mode'] == 1) {
                        nbd_window.jQuery(nbd_window.document).triggerHandler('nbd_pass_design_json', {
                            stage_id: this.currentStage,
                            design: nexttoLast,
                            config: {
                                width: _canvas.width,
                                height: _canvas.height,
                                zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio
                            },
                            fonts: _stage.states.usedFonts
                        });
                    } else {
                        jQuery(document).triggerHandler('nbd_pass_design_json', {
                            stage_id: this.currentStage,
                            design: nexttoLast,
                            config: {
                                width: _canvas.width,
                                height: _canvas.height,
                                zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio
                            },
                            fonts: _stage.states.usedFonts
                        });
                    }
                }
            }
            $scope.updateApp();
        };
        $scope.redo = function () {
            var _stage = this.stages[this.currentStage],
                _canvas = _stage['canvas'];
            if (_stage.redos.length > 0) {
                var last = _stage.redos.pop();
                $scope._loadStageFromJson($scope.currentStage, last);
                $scope.setHistory($scope.currentStage, last, false, true);
                $scope.deactiveAllLayer();
                /*advanced*/
                if (typeof mia_nbd_js_config_design != "undefined") {
                    $timeout(function () {
                        var angle = _stage.states.rotate.angle ? _stage.states.rotate.angle : 0;
                        _stage.canvas._objects.forEach((element, index) => {
                            var item = _stage.canvas._objects[index];
                            if (item.type == "image" && item.elementUpload) {
                                _stage.canvas._objects[index].style = {
                                    position: "absolute",
                                    visibility: 'visible',
                                    top: item.oCoords.tl.y - 1,
                                    left: item.oCoords.tl.x - 1,
                                    width: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.tr.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.tr.y, 2)) + 2,
                                    height: Math.sqrt(Math.pow(item.oCoords.tl.x - item.oCoords.bl.x, 2) + Math.pow(item.oCoords.tl.y - item.oCoords.bl.y, 2)) + 2,
                                    transform: "rotate(" + item.angle + "deg)"
                                };
                            }

                        })

                    }, 500);
                }
                this.renderStage();
            }
            ;
            $scope.updateApp();
        };
        $scope._undo = function () {
            var _stage = this.stages[this.currentStage],
                _canvas = _stage['canvas'];
            if (_stage.undos.length > 0) {
                var json = _stage.undos.pop();
                _canvas.clear();
                $scope.contextAddLayers = 'template';
                $scope.onloadTemplate = true;
                _canvas.loadFromJSON(json, function () {
                    $scope.onloadTemplate = false;
                    $scope.contextAddLayers = 'normal';
                });
                $scope._setHistory(false, json);
            }
        };
        $scope._redo = function () {
            var _stage = this.stages[this.currentStage],
                _canvas = _stage['canvas'];
            if (_stage.redos.length > 0) {
                var json = _stage.redos.pop();
                _canvas.clear();
                $scope.contextAddLayers = 'template';
                $scope.onloadTemplate = true;
                _canvas.loadFromJSON(json, function () {
                    $scope.onloadTemplate = false;
                    $scope.contextAddLayers = 'normal';
                });
                $scope._setHistory(json);
            }
        };
        $scope._setHistory = function (undo, redo) {
            var _stage = this.stages[this.currentStage];
            if (undo) {
                if (angular.isUndefined(_stage.undos)) _stage.undos = [];
                _stage.undos.push(undo);
                if (_stage.undos.length > 20) _stage.undos.shift();
                _stage.states.isUndoable = true;
            } else {
                if (angular.isUndefined(_stage.redos)) _stage.redos = [];
                _stage.states.isRedoable = true;
                _stage.redos.push(redo);
            }
            ;
            $scope.updateApp();
            $scope.updateStatusHistory();
        };
        $scope.setHistory = function (stage_id, undo, redo, hasJson) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            var _stage = this.stages[stage_id];
            if (angular.isUndefined(_stage)) return;
            /*if (undo) {
            if(angular.isUndefined(_stage.undos)) _stage.undos = [];
            _stage.undos.push(undo);
            if(_stage.undos.length > 50) _stage.undos.shift();
            _stage.states.isUndoable = true;
        }else{
            if(angular.isUndefined(_stage.redos)) _stage.redos = [];
            _stage.states.isRedoable = true;
            _stage.redos.push(redo);
        };*/
            var _canvas = _stage['canvas'];
            if (undo) {
                if (angular.isUndefined(_stage.undos)) _stage.undos = [];
                if (typeof _canvas.toJSON == 'function') {
                    if (angular.isUndefined(hasJson)) {
                        var json = _canvas.toJSON($scope.includeExport);
                        if (angular.isUndefined(_stage.undos)) _stage.undos = [];
                    } else {
                        var json = undo;
                    }
                    _stage.undos.push(json);
                    if (_stage.undos.length > 30) _stage.undos.shift();
                    _stage.states.isUndoable = true;

                    if ($scope.resource.shareDesign) {
                        if (NBDESIGNCONFIG['ui_mode'] == 1) {
                            nbd_window.jQuery(nbd_window.document).triggerHandler('nbd_pass_design_json', {
                                stage_id: stage_id,
                                design: json,
                                config: {
                                    width: _canvas.width,
                                    height: _canvas.height,
                                    zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio
                                },
                                fonts: _stage.states.usedFonts
                            });
                        } else {
                            jQuery(document).triggerHandler('nbd_pass_design_json', {
                                stage_id: stage_id,
                                design: json,
                                config: {
                                    width: _canvas.width,
                                    height: _canvas.height,
                                    zoom: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio
                                },
                                fonts: _stage.states.usedFonts
                            });
                        }
                    }
                }
            } else {
                if (angular.isUndefined(_stage.redos)) _stage.redos = [];
                _stage.states.isRedoable = true;
                _stage.redos.push(redo);
            }
            $scope.updateApp();
            $scope.updateStatusHistory();
        };
        $scope.updateStatusHistory = function () {
            var _stage = this.stages[this.currentStage];
            _stage.states.isUndoable = (_stage.undos.length > 1) ? true : false;
            _stage.states.isRedoable = (_stage.redos.length > 0) ? true : false;
            $scope.updateApp();
        };
        $scope.clearHistory = function () {
            var _stage = this.stages[this.currentStage];
            _stage.undos = [];
            _stage.redos = [];
            _stage.states.isRedoable = false;
            _stage.states.isUndoable = false;
            $scope.updateApp();
        };
        $scope._loadStageFromJson = function (stage_id, json, callback, withoutLoading) {
            $scope.onloadTemplate = true;
            $scope.contextAddLayers = 'template';
            if (!withoutLoading) $scope.toggleStageLoading();
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            var layerIndex = 0,
                stage = $scope.stages[stage_id],
                _canvas = stage['canvas'],
                objects = json.objects;
            _canvas.clear();
            if (json.background) {
                _canvas.setBackgroundColor(json.background);
            } else {
                _canvas.backgroundColor = null;
            }

            function loadLayer(layerIndex) {
                function continueLoadLayer() {
                    layerIndex++;
                    if (objects.length != 0 && layerIndex < objects.length) {
                        loadLayer(layerIndex);
                    } else {
                        $scope.renderStage($scope.currentStage);
                        var layers = _canvas.getObjects();
                        $scope.renderTextAfterLoadFont(layers, function () {
                            $scope.deactiveAllLayer();
                            $scope.renderStage($scope.currentStage);
                            $timeout(function () {
                                $scope.deactiveAllLayer();
                                $scope.renderStage($scope.currentStage);
                                $scope.onloadTemplate = false;
                                $scope.contextAddLayers = 'normal';
                                $scope.updateMaskedLayers(stage_id);
                                if (!withoutLoading) $scope.toggleStageLoading();
                                if (typeof callback == 'function') {
                                    callback();
                                }
                            }, 100);
                        });
                    }
                }

                if (objects.length > 0) {
                    var item = objects[layerIndex],
                        type = item.type;
                    if (type == 'image' || type == 'custom-image') {
                        fabric.Image.fromObject(item, function (_image) {
                            _canvas.add(_image);
                            continueLoadLayer();
                        });
                    } else {
                        var klass = fabric.util.getKlass(type);
                        klass.fromObject(item, function (item) {
                            _canvas.add(item);
                            continueLoadLayer();
                        });
                    }
                } else {
                    $scope.contextAddLayers = 'normal';
                    $scope.onloadTemplate = false;
                    if (!withoutLoading) $scope.toggleStageLoading();
                    if (typeof callback == 'function') {
                        callback();
                    }
                }
            }

            loadLayer(layerIndex);
        };
        $scope.enableFullScreenMode = function () {
            var ele = document.getElementById('nbd-stages');
            requestFullScreen(ele);
        };
        $scope.exitFullscreenMode = function () {
            exitFullscreen();
        };
        $scope.toggleStageFullScreenMode = function () {
            _.each($scope.stages, function (stage, index) {
                var zoomIndex = $scope.fullScreenMode ? stage.states.fullScreenScaleIndex : stage.states.fitScaleIndex;
                $scope.zoomStage(zoomIndex, index);
                $scope.deactiveAllLayer(index);
                $scope.renderStage(index);
            });
        };
        /* Design tools */
        $scope.debug = function () {
        };
        $scope.setGeometricalObjectAttr = function (type, value) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'],
                item = _canvas.getActiveObject();
            if (!item) return;
            switch (type) {
                case 'fill':
                    item.set({fill: value});
                    _states.geoObject.fill = value;
                    break;
                case 'strokeUniform':
                    item.set({strokeUniform: value});
                    break;
                case 'stroke':
                    if (value === false) {
                        item.set({stroke: null});
                        _states.geoObject.stroke = '#ffffff';
                    } else {
                        item.set({stroke: value});
                        _states.geoObject.stroke = value;
                    }
                    break;
                case 'strokeWidth':
                    var strokeWidth = value * 1;
                    strokeWidth = isNaN(strokeWidth) ? 0 : Math.abs(strokeWidth),
                        item.set({strokeWidth: strokeWidth});
                    break;
                case 'strokeDashArray':
                    var dash1 = value[0] * 1,
                        dash2 = value[1] * 1;
                    if (isNaN(dash1) || isNaN(dash2) || dash1 == 0 || dash2 == 0) {
                        item.set({strokeDashArray: null});
                    } else {
                        var i = isNaN(dash1) ? 0 : Math.abs(dash1),
                            j = isNaN(dash2) ? 0 : Math.abs(dash2);
                        item.set({strokeDashArray: [i, j]});
                    }
                    break;
            }
            item.setCoords();
            $scope.afterObjectModify();
            $scope.renderStage();
        };
        $scope.addGeometricalObject = function (type) {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            var object;
            $scope.disableDrawMode();
            switch (type) {
                case 'rect':
                    object = new fabric.Rect({
                        width: 100,
                        height: 100,
                        strokeWidth: 0,
                        noScaleCache: false,
                        strokeUniform: true
                    });
                    break;
                case 'circle':
                    object = new fabric.Circle({
                        radius: 50,
                        width: 100,
                        height: 100
                    });
                    break;
                case 'triangle':
                    object = new fabric.Triangle({
                        width: 100,
                        height: 100,
                        strokeWidth: 0
                    });
                    break;
                case 'hexagon':
                    object = new fabric.Polygon([{x: 10, y: 17.321}, {x: -10, y: 17.321}, {x: -20, y: 0}, {
                        x: -10,
                        y: -17.321
                    }, {x: 10, y: -17.321}, {x: 20, y: 0}]);
                    break;
                case 'line':
                    object = new fabric.Line([0, 35, 200, 35], {
                        stroke: 'red',
                        borderColor: 'rgba(255,0,0,0.2)',
                        padding: 10,
                        cornerColor: 'rgba(255, 106, 71)',
                        cornerSize: 15,
                    });
                    break;
                case 'polyline':
                    object = new fabric.Polyline([
                        {x: 10, y: 10},
                        {x: 50, y: 30},
                        {x: 40, y: 70},
                        {x: 60, y: 50},
                        {x: 100, y: 150},
                        {x: 40, y: 100}
                    ]);
                    break;
                case 'ellipse':
                    object = new fabric.Ellipse({
                        rx: 80,
                        ry: 50
                    });
                    break;
                case 'outlinecircle':
                    object = new fabric.Circle({
                        radius: 100,
                        fill: '',
                        stroke: 'red',
                        strokeUniform: true,
                        strokeWidth: 3
                    });
                    break;
                case 'roundedrectangle':
                    object = new fabric.Rect({
                        left: 10,
                        top: 10,
                        width: 200,
                        height: 200,
                        fill: '#0E1318',
                        rx: 10,
                        ry: 10,
                        objectCaching: false,
                        strokeWidth: 0,
                        noScaleCache: false,
                        strokeUniform: true
                    });
                    break;
                case 'star':
                    object = new fabric.Polygon([{x: 295, y: 10}, {x: 235, y: 198}, {x: 385, y: 78}, {
                        x: 205,
                        y: 78
                    }, {x: 355, y: 198}]);
                    break;
                case 'rightparallelogram':
                    object = new fabric.Rect({
                        width: 200,
                        height: 100,
                        fill: '#0E1318',
                        skewX: 45,
                        objectCaching: false
                    });
                    break;
                case 'leftparallelogram':
                    object = new fabric.Rect({
                        width: 200,
                        height: 100,
                        fill: '#0E1318',
                        skewX: -45,
                        objectCaching: false
                    });
                    break;
                case 'diamond':
                    object = new fabric.Rect({
                        width: 200,
                        height: 200,
                        fill: '#0E1318',
                        angle: 45,
                        objectCaching: false
                    });
                    break;
            }
            _canvas.add(object);
        };
        /*advanced*/
        if (typeof udc_nbd_js_config != 'undefined') {
            $scope.lineConfig = {
                dash1: 5,
                dash2: 5,
                width: 100,
                color: '#ff0000'
            };
            $scope.addLine = function () {
                var _canvas = $scope.stages[$scope.currentStage]['canvas'];
                _canvas.add(
                    new fabric.Line([0, 20, $scope.lineConfig.width, 20], {
                        stroke: $scope.lineConfig.color
                    })
                );
            };
            $scope.addShape = function (type) {
                var _canvas = $scope.stages[$scope.currentStage]['canvas'];
                var shape = null;
                switch (type) {
                    case 'rect':
                        shape = new fabric.Rect({
                            width: 50,
                            height: 50
                        });
                        break;
                    case 'circle':
                        shape = new fabric.Circle({
                            radius: 50
                        });
                        break;
                    case 'triangle':
                        shape = new fabric.Triangle({
                            width: 50,
                            height: 50
                        });
                        break;
                }
                _canvas.add(shape);
            };
        }
        $scope.tempLayer = {};
        $scope.renderStage = function (stage_id) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            if (typeof nbod_addon_side_thumbnail != "undefined") {
                //nbdesginer advanced
                $scope.getStageThumbnail(stage_id);
            }
            $scope.stages[stage_id]['canvas'].calcOffset();
            //$scope.stages[stage_id]['canvas'].requestRenderAll();
            $scope.stages[stage_id]['canvas'].renderAll();
        };
        $scope.deactiveAllLayer = function (stage_id) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            $scope.stages[stage_id]['canvas'].discardActiveObject();
            angular.merge($scope.stages[$scope.currentStage].states.uploadZone, {visibility: 'hidden'});
            $scope.updateCorners();
            $scope.renderStage();
            $scope.updateApp();
        };
        $scope.groupLayers = function () {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                activeObject = _canvas.getActiveObject();
            if (activeObject.type === 'activeSelection') {
                activeObject.getObjects()
                    .forEach((object) => {
                        if (object.isMask) {
                            activeObject.removeWithUpdate(object);
                        }
                    });
                $scope.contextAddLayers = 'template';
                activeObject.toGroup();
                const group = _canvas.getActiveObject();
                group.set({
                    subTargetCheck: true
                });
                $scope.renderStage();
                $scope.getCurrentLayerInfo();
                _canvas.renderAll();
                $scope.makeActiveSelectionMasksMovable(_canvas.getActiveObject());
            }
        };
        $scope.handleGroupDoubleClick = function (e) {
            const _canvas = $scope.stages[$scope.currentStage]['canvas'];
            if (e.subTargets && e.subTargets.length) {
                const target = e.subTargets[0];
                target.set({
                    isInGroup: true,
                    hasControls: false
                });

                function deselectedHandler() {
                    target.set({
                        hasControls: true
                    });
                    target.off('deselected', deselectedHandler);
                }

                target.on('deselected', deselectedHandler);
                _canvas.discardActiveObject(target);
                _canvas.setActiveObject(target);
                $scope.renderStage();
                $scope.getCurrentLayerInfo();
            }
        };
        $scope.onUnloadGroup = {
            status: false,
            remain: 0,
            length: 0
        };
        $scope.unGroupLayers = function () {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'],
                activeObject = _canvas.getActiveObject();
            if (activeObject.isInGroup) {
                $scope.stages[$scope.currentStage].states.isInGroup = false;
                activeObject.set({
                    isInGroup: false,
                });
                _canvas.setActiveObject(activeObject.group);
                activeObject = _canvas.getActiveObject();
            }
            if (activeObject.type === 'activeSelection') {
                activeObject.getObjects().forEach((o) => {
                    if (o.isMask) {
                        activeObject.removeWithUpdate(o)
                    }
                    if (o.type === 'group') {
                        o.getObjects()
                            .forEach((_o) => {
                                if (_o.maskId) {
                                    const maskLayer = $scope.getMaskLayer(_o.get('maskId'));
                                    if (_o.originX !== maskLayer.originX) {
                                        const originX = _o.originX;
                                        _o.set({
                                            originX: maskLayer.originX,
                                        });
                                        if (originX === 'center') {
                                            _o.set({
                                                left: _o.left - _o.getScaledWidth() / 2
                                            });
                                        }
                                    }

                                    if (_o.originY !== maskLayer.originY) {
                                        const originY = _o.originY;
                                        _o.set({
                                            originY: maskLayer.originY,
                                        });
                                        if (originY === 'center') {
                                            _o.set({
                                                top: _o.top - _o.getScaledHeight() / 2
                                            });
                                        }
                                    }
                                    _o.setCoords();
                                    _canvas.renderAll();
                                }
                            });
                        activeObject = o;
                    }
                    _canvas.discardActiveObject();
                });
            }
            /*advanced*/
            if (typeof nbpdf_ai_to_svg != "undefined") {
                activeObject.toObject().objects.forEach(function (ele, index) {
                    if (ele.type == "text") {
                        delete ele.type;
                        var text = ele.text;
                        var textobj = {};
                        angular.copy(ele, textobj);
                        var oText = new fabric.IText(text, textobj);
                        activeObject._objects[index] = oText;
                    }
                });
            }
            if (activeObject.type === 'group') {
                $scope.onUnloadGroup = {
                    status: true,
                    remain: activeObject._objects.length,
                    length: activeObject._objects.length
                };
                if (angular.isDefined(activeObject.itemId)) {
                    $scope.onUnloadGroup.prevIndex = $scope.getLayerById(activeObject.itemId);
                }
                $scope.contextAddLayers = 'template';
                activeObject.toActiveSelection();
                $scope.renderStage();
                $scope.getCurrentLayerInfo();
            }
            $scope.stages[$scope.currentStage].states.isGrouppedSelection = false;
            $scope.clearMovableMasks();
            $scope.makeActiveSelectionMasksMovable(_canvas.getActiveObject());
        };
        /* General */
        $scope._clearAllStage = function () {
            if (!$scope.canDeleteLayer()) return;
            jQuery('.nbd-popup.clear-all-stage-alert').nbShowPopup();
        };
        $scope.clearAllStage = function () {
            _.each($scope.stages, function (stage, index) {
                stage.canvas.clear();
                stage.layers = [];
            });
            $scope.initStagesSettingWithoutTemplate();
            jQuery('.clear-all-stage-alert .close-popup').triggerHandler('click');
        };
        /* Draw mode */
        $scope.disableDrawMode = function () {
            $scope.resource.drawMode.status = false;
            _.each($scope.stages, function (stage, index) {
                stage.canvas.isDrawingMode = false;
            });
            $scope.changeBush();
            $scope.updateApp();
        };
        $scope.enableDrawMode = function () {
            $scope.resource.drawMode.status = true;
            _.each($scope.stages, function (stage, index) {
                stage.canvas.isDrawingMode = true;
            });
            $scope.updateApp();
        };
        $scope.changeBush = function (color) {
            if (color) $scope.resource.drawMode.brushColor = color;
            if (!$scope.resource.drawMode.brushType) {
                return;
            }
            let brush;
            if ($scope.resource.drawMode.brushType === 'hline') {
                _.each($scope.stages, function (stage, index) {
                    const patternBrush = new fabric.PatternBrush(stage.canvas);
                    patternBrush.getPatternSrc = function () {
                        var patternCanvas = fabric.document.createElement('canvas');
                        patternCanvas.width = patternCanvas.height = 10;
                        var ctx = patternCanvas.getContext('2d');
                        ctx.strokeStyle = $scope.resource.drawMode.brushColor;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(0, 5);
                        ctx.lineTo(10, 5);
                        ctx.closePath();
                        ctx.stroke();
                        return patternCanvas;
                    };
                    stage.canvas.freeDrawingBrush = patternBrush;
                    stage.canvas.freeDrawingBrush.color = $scope.resource.drawMode.brushColor;
                    stage.canvas.freeDrawingBrush.width = $scope.resource.drawMode.brushWidth;
                    const brush = stage.canvas.freeDrawingBrush;
                    if (brush.getPatternSrc) {
                        brush.source = brush.getPatternSrc.call(brush);
                    }
                });
                return;
            } else if ($scope.resource.drawMode.brushType === 'vline') {
                _.each($scope.stages, function (stage, index) {
                    const patternBrush = new fabric.PatternBrush(stage.canvas);
                    patternBrush.getPatternSrc = function () {
                        var patternCanvas = fabric.document.createElement('canvas');
                        patternCanvas.width = patternCanvas.height = 10;
                        var ctx = patternCanvas.getContext('2d');

                        ctx.strokeStyle = $scope.resource.drawMode.brushColor;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(5, 0);
                        ctx.lineTo(5, 10);
                        ctx.closePath();
                        ctx.stroke();

                        return patternCanvas;
                    };
                    stage.canvas.freeDrawingBrush = patternBrush;
                    stage.canvas.freeDrawingBrush.color = $scope.resource.drawMode.brushColor;
                    stage.canvas.freeDrawingBrush.width = $scope.resource.drawMode.brushWidth;
                    const brush = stage.canvas.freeDrawingBrush;
                    if (brush.getPatternSrc) {
                        brush.source = brush.getPatternSrc.call(brush);
                    }
                });
                return;
            } else if ($scope.resource.drawMode.brushType === 'Square') {
                _.each($scope.stages, function (stage, index) {
                    const patternBrush = new fabric.PatternBrush(stage.canvas);
                    patternBrush.getPatternSrc = function () {
                        var squareWidth = 10, squareDistance = 2;
                        var patternCanvas = fabric.document.createElement('canvas');
                        patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
                        var ctx = patternCanvas.getContext('2d');

                        ctx.fillStyle = this.color;
                        ctx.fillRect(0, 0, squareWidth, squareWidth);

                        return patternCanvas;
                    };
                    stage.canvas.freeDrawingBrush = patternBrush;
                    stage.canvas.freeDrawingBrush.color = $scope.resource.drawMode.brushColor;
                    stage.canvas.freeDrawingBrush.width = $scope.resource.drawMode.brushWidth;
                    const brush = stage.canvas.freeDrawingBrush;
                    if (brush.getPatternSrc) {
                        brush.source = brush.getPatternSrc.call(brush);
                    }
                });
                return;
            } else if ($scope.resource.drawMode.brushType === 'Diamond') {
                _.each($scope.stages, function (stage, index) {
                    const patternBrush = new fabric.PatternBrush(stage.canvas);
                    patternBrush.getPatternSrc = function () {
                        var squareWidth = 10, squareDistance = 5;
                        var patternCanvas = fabric.document.createElement('canvas');
                        var rect = new fabric.Rect({
                            width: squareWidth,
                            height: squareWidth,
                            angle: 45,
                            fill: $scope.resource.drawMode.brushColor
                        });

                        var canvasWidth = rect.getBoundingRect().width;

                        patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
                        rect.set({left: canvasWidth / 2, top: canvasWidth / 2});

                        var ctx = patternCanvas.getContext('2d');
                        rect.render(ctx);

                        return patternCanvas;
                    };
                    stage.canvas.freeDrawingBrush = patternBrush;
                    stage.canvas.freeDrawingBrush.color = $scope.resource.drawMode.brushColor;
                    stage.canvas.freeDrawingBrush.width = $scope.resource.drawMode.brushWidth;
                    const brush = stage.canvas.freeDrawingBrush;
                    if (brush.getPatternSrc) {
                        brush.source = brush.getPatternSrc.call(brush);
                    }
                });
                return;
            } else {
                brush = fabric[$scope.resource.drawMode.brushType + "Brush"];
            }

            _.each($scope.stages, function (stage, index) {
                stage.canvas.freeDrawingBrush = new brush(stage.canvas);
                stage.canvas.freeDrawingBrush.color = $scope.resource.drawMode.brushColor;
                stage.canvas.freeDrawingBrush.width = $scope.resource.drawMode.brushWidth;
            });
        };
        $scope.importDesign = function () {
            var input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/JSON';
            input.style.display = 'none';
            input.addEventListener('change', onChange.bind(input), false);
            document.body.appendChild(input);
            input.click();

            function onChange() {
                if (this.files.length > 0) {
                    var file = this.files[0],
                        reader = new FileReader();
                    reader.onload = function (event) {
                        if (event.target.readyState === 2) {
                            var result = JSON.parse(reader.result);
                            $scope.importImages(result, function (new_design, fonts, extenalDesign) {
                                var temp = {fonts: fonts, design: new_design, viewport: result.config.viewport};
                                if (!!extenalDesign) temp.doNotShowLoading = true;
                                $scope.syncImportedDesignStages(temp.design);
                                setTimeout(() => {
                                    $scope.insertTemplate(true, temp)
                                }, 100);
                            });
                            destroy();
                        }
                    };
                    reader.readAsText(file);
                }
            }

            function destroy() {
                input.removeEventListener('change', onChange.bind(input), false);
                document.body.removeChild(input);
            }
        };
        $scope.exportDesign = function () {
            $scope.saveDesign();
            var json = {config: {}};
            json.config.viewport = $scope.calcViewport();
            json.config.home_url = $scope.settings.home_url;
            json.fonts = $scope.resource.usedFonts;
            json.design = $scope.resource.jsonDesign;
            if (nbd_window.jQuery('.nbd-main-bar .nbd-main-menu input[name="title"]').val() != "") {
                var filename = nbd_window.jQuery('.nbd-main-bar .nbd-main-menu input[name="title"]').val().replace(' ', '_');
            }
            text = JSON.stringify(json),
                a = document.createElement('a');
            a.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(text));
            a.setAttribute('download', filename);
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
        $scope.importImages = function (result, callback) {
            var images = [], extenalDesign = false,
                design = result.design, fonts = result.fonts, new_fonts = fonts;

            if (angular.isDefined(result.config.home_url)) {
                if ($scope.settings.home_url != result.config.home_url) {
                    new_fonts = [];
                    _.each(fonts, function (font, index) {
                        if (font.type == "google") {
                            new_fonts.push(font);
                        }
                    });
                }
            }

            _.each(design, function (side, sideIndex) {
                var objects = side.objects;
                _.each(objects, function (object, objectIndex) {
                    var type = object.type, src = object.src;
                    if (type == 'image' || type == 'custom-image') {
                        if (src.indexOf($scope.settings.home_url) == -1 && src.indexOf('data:im') == -1) {
                            var __index = sideIndex + '_' + objectIndex;
                            ['src', 'origin_url', 'origin_src'].forEach(function (val) {
                                if (angular.isDefined(object[val])) {
                                    var _index = __index + '_' + val;
                                    images[_index] = object[val];
                                    extenalDesign = true;
                                }
                            });
                        }
                    }
                });
            });
            if (extenalDesign) {
                $scope.toggleStageLoading();
                // var dataObj = {images: images, nonce: NBDESIGNCONFIG['nonce']};
                // NBDDataFactory.get('nbd_import_images', dataObj, function(data){
                //     data = JSON.parse(data);
                //     if( data.flag == 1 ){
                //         var new_images = data.images;
                //         _.each(design, function(side, sideIndex){
                //             var objects = side.objects;
                //             _.each(objects, function(object, objectIndex){
                //                 var type = object.type;
                //                 if( type == 'image' || type == 'custom-image' ){
                //                     var __index = sideIndex + '_' + objectIndex;
                //                     ['src', 'origin_url', 'origin_src'].forEach(function(val){
                //                         var _index = __index + '_' + val;
                //                         if( angular.isDefined( new_images[_index] ) ){
                //                             if( angular.isDefined( object[val] ) ){
                //                                 object[val] = new_images[_index];
                //                             }
                //                         }
                //                     });
                //                 }
                //             });
                //         });
                //         callback( design, new_fonts, extenalDesign );
                //     } else {
                //         alert( 'Import images fail!' );
                //     }
                // });
                var new_images = images;
                _.each(design, function (side, sideIndex) {
                    var objects = side.objects;
                    _.each(objects, function (object, objectIndex) {
                        var type = object.type;
                        if (type == 'image' || type == 'custom-image') {
                            var __index = sideIndex + '_' + objectIndex;
                            ['src', 'origin_url', 'origin_src'].forEach(function (val) {
                                var _index = __index + '_' + val;
                                if (angular.isDefined(new_images[_index])) {
                                    if (angular.isDefined(object[val])) {
                                        object[val] = new_images[_index];
                                    }
                                }
                            });
                        }
                    });
                });
                callback(design, new_fonts, extenalDesign);
            } else {
                callback(design, new_fonts);
            }
        };
        $scope.loadMyDesign = function (did, inCart) {
            function process() {
                var dataObj = {}, loadAllMyTemplate = true;
                $scope.toggleStageLoading();
                var popup = inCart ? '.popup-nbd-my-designs-in-cart' : '.popup-nbd-my-templates';
                if (did != null) {
                    dataObj = {did: did};
                    loadAllMyTemplate = false;
                    jQuery(popup).removeClass('nb-show');
                } else {
                    dataObj = {
                        product_id: NBDESIGNCONFIG['product_id'],
                        variation_id: NBDESIGNCONFIG['variation_id']
                    };
                    if (appConfig.loadAllDesign) {
                        dataObj = {};
                    }
                }
                ;
                var action = inCart ? 'nbd_get_designs_in_cart' : 'nbd_get_user_designs';
                NBDDataFactory.get(action, dataObj, function (data) {
                    data = JSON.parse(data);
                    if (data.flag == 1) {
                        if (data.folder) {
                            $scope.savedNbdKey = data.folder;
                            $scope.selectedMyDesign = undefined;
                        }
                        if (loadAllMyTemplate) {
                            if (inCart) {
                                $scope.resource.cartTemplates = data.designs;
                            } else {
                                $scope.resource.myTemplates = data.designs;
                            }
                            $scope.toggleStageLoading();
                            jQuery(popup).nbShowPopup();
                        } else {
                            $scope.syncImportedDesignStages(data.design);
                            setTimeout(() => {
                                $scope.insertTemplate(true, {
                                    fonts: data.fonts,
                                    design: data.design,
                                    doNotShowLoading: true
                                });
                            }, 100);
                        }
                    }
                });
            }

            if (inCart) {
                process();
            } else {
                $scope.login(function () {
                    process();
                });
            }
        };
        $scope.syncImportedDesignStages = function (design) {
            const stagesCount = $scope.stages.length;
            const importedStagesCount = Object.keys(design).length;
            if (importedStagesCount > stagesCount) {
                Array.from({length: importedStagesCount - stagesCount}, () => {
                    $scope._addStage();
                    $scope.updateApp();
                });
            } else if (importedStagesCount < stagesCount) {
                Array.from({length: stagesCount - importedStagesCount}, () => {
                    $scope._deleteStage(null, false);
                    $scope.updateApp();
                });
            }
        };
        $scope.tempCanvas = null;
        $scope.storeLayers = function () {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            var item = _canvas.getActiveObjects();
            if (item) {
                var bound = _canvas.getActiveObject().getBoundingRect();
                if (jQuery('#temp-canvas-wrap').length == 0) {
                    var tempCanvasWrap = document.createElement('div');
                    tempCanvasWrap.setAttribute('id', 'temp-canvas-wrap');
                    var canvasEl = document.createElement('canvas');
                    canvasEl.setAttribute('id', 'temp-canvas');
                    tempCanvasWrap.appendChild(canvasEl);
                    document.body.appendChild(tempCanvasWrap);
                    $scope.tempCanvas = new fabric.Canvas("temp-canvas");
                    /*advanced*/
                    if (typeof udc_nbd_js_config != 'undefined') {
                        fabric.Image.prototype.set({
                            crossOrigin: 'anonymous'
                        });
                    }
                }
                $scope.tempCanvas.setDimensions({'width': bound.width, 'height': bound.height});
                $scope.tempCanvas.clear();
                $scope.tempCanvas.renderAll();
                var designData = {
                    used_font: [],
                    design: null,
                    preview: null,
                    tempLayers: []
                };
                var layers = [];
                var currentIndex = 0;
                _canvas.getActiveObjects().forEach(function (obj) {
                    if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(obj.type) > -1) {
                        var font = $scope.getFontInfo(obj.fontFamily);
                        designData.used_font.push(font);
                    }
                    layers.push(JSON.stringify(obj));
                });

                function importLayerToTempCanvas(currentIndex) {
                    var object = JSON.parse(layers[currentIndex]);

                    function continueLoadLayer() {
                        var _item = $scope.tempCanvas.item($scope.tempCanvas.getObjects().length - 1);
                        designData.tempLayers.push(_item);
                        currentIndex++;
                        if (currentIndex <= (layers.length - 1)) {
                            importLayerToTempCanvas(currentIndex);
                        } else {
                            var selection = new fabric.ActiveSelection(designData.tempLayers, {
                                canvas: $scope.tempCanvas
                            });
                            $scope.tempCanvas.setActiveObject(selection);
                            selection.addWithUpdate();
                            $scope.tempCanvas.viewportCenterObjectH(selection);
                            $scope.tempCanvas.viewportCenterObjectV(selection);
                            $scope.tempCanvas.discardActiveObject().renderAll();
                            $timeout(function () {
                                designData.preview = $scope.tempCanvas.toDataURL();
                                designData.design = $scope.tempCanvas.toJSON($scope.includeExport);
                                var designObj = {
                                    used_font: designData.used_font,
                                    json: designData.design,
                                    width: bound.width,
                                    height: bound.height
                                };
                                var _dataObj = {
                                    type: 'save_user_design',
                                    design: new Blob([JSON.stringify(designObj)], {type: "application/json"}),
                                    preview: $scope.makeblob(designData.preview)
                                };
                                $scope.toggleStageLoading();
                                NBDDataFactory.get('nbd_get_resource', _dataObj, function (_data) {
                                    _data = JSON.parse(_data);
                                    if ($scope.resource.myDesigns.length == 0) {
                                        $scope.needReloadUserDesigns = true;
                                    } else {
                                        $scope.resource.myDesigns.splice(0, 0, _data.data);
                                    }
                                    $scope.toggleStageLoading();
                                });
                            });
                        }
                    };
                    var klass = fabric.util.getKlass(object.type);
                    if (object.type == 'image' || object.type == 'custom-image') {
                        fabric.Image.fromObject(object, function (_image) {
                            $scope.tempCanvas.add(_image);
                            continueLoadLayer();
                        });
                    } else {
                        klass.fromObject(object, function (object) {
                            $scope.tempCanvas.add(object);
                            continueLoadLayer();
                        });
                    }
                };
                importLayerToTempCanvas(currentIndex);
            }
        };
        $scope.needReloadUserDesigns = false;
        $scope.loadUserDesigns = function (template_id) {
            $scope.toggleStageLoading();
            var _dataObj = {
                type: 'load_user_designs'
            };
            if (angular.isDefined(template_id)) {
                _dataObj.type = 'load_user_design';
                _dataObj.template_id = template_id;
            } else {
                if ($scope.resource.myDesigns.length && !$scope.needReloadUserDesigns) {
                    jQuery('.popup-nbd-user-design').nbShowPopup();
                    $scope.toggleStageLoading();
                    return;
                }
            }
            NBDDataFactory.get('nbd_get_resource', _dataObj, function (_data) {
                _data = JSON.parse(_data);
                if (angular.isDefined(_data.flag) && _data.flag == '1') {
                    if (angular.isDefined(template_id)) {
                        $scope.insertUserDesigns(_data.data.design);
                    } else {
                        _data.data.user_designs.forEach(function (design) {
                            $scope.resource.myDesigns.push(design);
                        });
                        $scope.needReloadUserDesigns = false;
                        jQuery('.popup-nbd-user-design').nbShowPopup();
                    }
                }
                $scope.toggleStageLoading();
            });
        };
        $scope.deleteUserDesign = function (template_id, index) {
            var con = confirm($scope.settings.nbdlangs.confirm_delete_design);
            if (con == true) {
                jQuery('.popup-nbd-user-design .overlay-main').addClass('active');
                var _dataObj = {
                    type: 'delete_user_design',
                    template_id: template_id
                };
                NBDDataFactory.get('nbd_get_resource', _dataObj, function (_data) {
                    _data = JSON.parse(_data);
                    if (angular.isDefined(_data.flag) && _data.flag == '1') {
                        $scope.resource.myDesigns.splice(index, 1);
                    }
                    jQuery('.popup-nbd-user-design .overlay-main').removeClass('active');
                });
            }
        };
        $scope.insertUserDesigns = function (data) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'];
            jQuery('.popup-nbd-user-design .overlay-main').addClass('active');
            var fonts = data.used_font,
                layers = data.json.objects,
                _index = 0,
                tempLayers = [];

            function loadLayer(_index) {
                if (_index == layers.length) {
                    var selection = new fabric.ActiveSelection(tempLayers, {
                        canvas: _canvas
                    });
                    $timeout(function () {
                        _canvas.setActiveObject(selection);
                        selection.addWithUpdate();
                        _canvas.viewportCenterObjectH(selection);
                        _canvas.viewportCenterObjectV(selection);
                        if (stage.config.area_design_type == "2") $scope.setStackLayerAlwaysOnTop();
                        $scope.renderStage();
                        jQuery('.popup-nbd-user-design').removeClass('nb-show');
                        jQuery('.popup-nbd-user-design .overlay-main').removeClass('active');
                    }, 50);
                } else {
                    $scope.contextAddLayers = 'template';
                    var object = layers[_index],
                        type = object.type;
                    _index++;

                    function addLayer(_obj) {
                        _canvas.add(_obj);
                        tempLayers.push(_obj);
                        loadLayer(_index);
                    };
                    var klass = fabric.util.getKlass(type);
                    if (type == 'image' || type == 'custom-image') {
                        fabric.Image.fromObject(object, function (_image) {
                            addLayer(_image);
                        });
                    } else {
                        klass.fromObject(object, function (object) {
                            if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(object.type) > -1) {
                                var fontName = object.fontFamily,
                                    content = object.text;
                                var font = new FontFaceObserver(fontName, {
                                    weight: object.fontWeight,
                                    style: object.fontStyle
                                });
                                font.load(content).then(function () {
                                    fabric.util.clearFabricFontCache(fontName);
                                    addLayer(object);
                                }, function () {
                                    console.log('Fail to load font: ' + fontName);
                                    addLayer(object);
                                });
                            } else {
                                addLayer(object);
                            }
                        });
                    }
                }
            }

            if (fonts.length) {
                _.each(fonts, function (font, index) {
                    if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                        $scope.resource.font.data.push(font);
                    }
                    ;
                    if (index == fonts.length - 1) {
                        $scope.insertTemplateFont(font.alias, function () {
                            loadLayer(_index);
                            if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                            }
                            ;
                        });
                    } else {
                        $scope.insertTemplateFont(font.alias, function () {
                            if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                            }
                            ;
                        });
                    }
                });
            } else {
                loadLayer(_index);
            }
        };
        /*advanced*/
        if (typeof udc_nbd_js_config != 'undefined') {
            // OBJECT LOCK
            $scope.LockActiveObject = function () {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                var activeObject = _canvas.getActiveObject();
                if (activeObject) {
                    activeObject.lockMovementX = !activeObject.lockMovementX;
                    activeObject.lockMovementY = !activeObject.lockMovementY;
                    activeObject.lockScalingX = !activeObject.lockScalingX;
                    activeObject.lockScalingY = !activeObject.lockScalingY;
                    activeObject.lockUniScaling = !activeObject.lockUniScaling;
                    activeObject.lockRotation = !activeObject.lockRotation;
                    activeObject.lockObject = !activeObject.lockObject;
                    $scope.renderStage();
                }
            };
            // OBJECT UNLOCK
            $scope.unLockActiveObject = function () {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                var activeObject = _canvas.getActiveObject();
                if (activeObject) {
                    activeObject.lockMovementX = activeObject.lockMovementX;
                    activeObject.lockMovementY = activeObject.lockMovementY;
                    activeObject.lockScalingX = activeObject.lockScalingX;
                    activeObject.lockScalingY = activeObject.lockScalingY;
                    activeObject.lockUniScaling = activeObject.lockUniScaling;
                    activeObject.lockRotation = activeObject.lockRotation;
                    activeObject.lockObject = activeObject.lockObject;
                    $scope.renderStage();
                }
            };
            $scope.setStrokeWidth = function (value) {
                $scope.changeObjectColor('strokeWidth', value);
            };

            $scope.handleImageEditClick = function () {
                const activeObject = $scope.getActiveObject();
                if (activeObject) {
                    $scope.imageToOpenInPhotokit = activeObject.toDataURL({withoutTransform: true});
                    $scope.showPhotokitEditor = true;
                }
            }

            $scope.handlePhotokitSave = function (e) {
                $scope.imageToOpenInPhotokit = null;
                $scope.showPhotokitEditor = false;
                const activeObject = $scope.getActiveObject();
                const canvas = $scope.getCurrentStageCanvas();
                if (activeObject) {
                    activeObject.setSrc(e, () => {
                        canvas.renderAll();
                    }, {crossOrigin: 'anonymous'});
                }
            }

            $scope.handlePhotokitClose = function () {
                $scope.imageToOpenInPhotokit = null;
                $scope.showPhotokitEditor = false;
            }

            $scope.changeObjectColor = function (style, hex) {
                jQuery('.strokecolor').css('background', hex);
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                var obj = _canvas.getActiveObject();
                if (!obj) return;
                // var obj = _canvas.getActiveObject();

                if (obj) {
                    if (obj.paths) {
                        for (var i = 0; i < obj.paths.length; i++) {
                            $scope.setActiveStyle(style, hex, obj.paths[i]);
                        }
                    } else if (obj.type === "group") {
                        var objects = obj.getObjects();
                        for (var i = 0; i < objects.length; i++) {
                            $scope.setActiveStyle(style, hex, objects[i]);
                        }
                    } else $scope.setActiveStyle(style, hex, obj);
                } else {
                    var grpobjs = _canvas.getActiveObjects();
                    if (grpobjs) {
                        grpobjs.forEach(function (object) {
                            if (object.paths) {
                                for (var i = 0; i < object.paths.length; i++) {
                                    $scope.setActiveStyle(style, hex, obj.paths[i]);
                                }
                            } else $scope.setActiveStyle(style, hex, obj);
                        });
                    }
                }
                _canvas.renderAll();
            };

            $scope.onTitleChanged = function () {
                const title = $scope.stages[$scope.currentStage].config.name;
                if (title) {
                    document.title = `${title} - Plasfy Designer`;
                } else {
                    document.title = `Design - Plasfy Designer`;
                }
                $scope.customTemplate.name = title;
            }

            $scope.imageHasTransparency = function (image) {
                if (image.type !== 'image') {
                    return;
                }
                ;
                const tempCanvas = document.createElement("canvas");
                const tempCtx = tempCanvas.getContext("2d");
                tempCanvas.width = image.width;
                tempCanvas.height = image.height;
                tempCtx.drawImage(image.getElement(), 0, 0);
                const imgData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imgData.data;
                let hasTransparency = false;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] < 255) {
                        hasTransparency = true;
                    }
                }
                return hasTransparency;
            };

            $scope.setActiveStyle = function (styleName, value, object) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                object = object || _canvas.getActiveObject();
                if (!object) return;
                if (object.type === 'image' && !object.maskId && (styleName === 'strokeWidth' || styleName === 'stroke')) {
                    if ($scope.imageHasTransparency(object)) {
                        object.set(`${styleName}Image`, value);
                    } else {
                        object.set(styleName, value);
                    }
                } else if (object.type === 'image' && object.maskId && (styleName === 'strokeWidth' || styleName === 'stroke')) {
                    const maskLayer = $scope.getMaskLayer(object.get('maskId'));
                    if (maskLayer) {
                        maskLayer.set(styleName, value);

                        maskLayer.set({
                            opacity: 1,
                            strokeUniform: true,
                            objectCaching: false
                        });
                    }
                } else if (object.setSelectionStyles && object.isEditing) {
                    var style = {};
                    style[styleName] = value;
                    object.setSelectionStyles(style);
                    object.setCoords();
                } else {
                    object.set(styleName, value);
                }
                object.setCoords();
                _canvas.renderAll();
            };

            $scope.setRotate = function (value) {
                $scope.rotate = value;
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                var obj = _canvas.getActiveObject();
                if (!obj) return;
                if (obj) {
                    $scope.rotateObject($scope.rotate);
                }
            }

            $scope.rotateObject = function (angleOffset) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                var obj = _canvas.getActiveObject();
                if (!obj) return;
                obj.rotate(angleOffset);
                obj.setCoords();
                _canvas.renderAll();
            }

            $scope.roundValue = function (value) {
                return Math.round(value);
            };

            $scope.setCanvasBGimage = function (bgimgsrc) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                $scope.deleteCanvasBg(false);
                if (!_canvas) return false;
                if (bgimgsrc)
                    fabric.Image.fromURL(bgimgsrc, (bg) => {
                        bg.set({
                            opacity: 1,
                            selectable: true,
                            hasBorders: true,
                            hasCorners: true,
                            hasControls: true,
                            left: 0,
                            top: 0,
                            strokeWidth: 0,
                            isBgImg: 1,
                            width: _canvas.getWidth(),
                            height: _canvas.getHeight()
                        });
                        _canvas.add(bg);
                        _canvas.sendToBack(bg);
                        bg.bg = true;
                    }, {
                        crossOrigin: 'anonymous'
                    });

                _canvas.forEachObject(function (obj) {
                    if (obj.isBgImg) {
                        _canvas.remove(obj);
                    }
                });
            };

            $scope.setCanvasGradientone = function (colorvalue) {
                $scope.gradientOne = colorvalue;
                if (!$scope.gradientTwo) {
                    $scope.setCanvasGradientBG($scope.gradientOne, '#000');
                } else {
                    $scope.setCanvasGradientBG($scope.gradientOne, $scope.gradientTwo);
                }

            }

            $scope.setCanvasGradienttwo = function (colorvalue) {
                $scope.gradientTwo = colorvalue;
                jQuery('.gradientcolorone').css('background', colorvalue);
                if ($scope.gradientOne && $scope.gradientTwo) {
                    $scope.setCanvasGradientBG($scope.gradientOne, $scope.gradientTwo);
                } else {
                    //return false
                    $scope.setCanvasGradientBG('#000', $scope.gradientTwo);
                }
            }

            $scope.setTextGradientone = function (colorvalue) {
                $scope.txtgradientOne = colorvalue;
                jQuery('.gradientcolorone').css('background', colorvalue);
                if (!$scope.txtgradientTwo) {
                    $scope.setTextgradient($scope.txtgradientOne, '#000');
                } else {
                    $scope.setTextgradient($scope.txtgradientOne, $scope.txtgradientTwo);
                }
            }

            $scope.setTextGradienttwo = function (colorvalue) {
                $scope.txtgradientTwo = colorvalue;
                jQuery('.gradientcolortwo').css('background', colorvalue);
                if ($scope.txtgradientOne && $scope.txtgradientTwo) {
                    $scope.setTextgradient($scope.txtgradientOne, $scope.txtgradientTwo);
                } else {
                    //return false
                    $scope.setTextgradient('#000', $scope.txtgradientTwo);
                }
            }

            $scope.initGradientColorPicker = function () {
                $scope.textGP = new Grapick({el: '#textGradientColorPicker', colorEl: '<input id="textColorPicker"/>'});
                $scope.textGP.setColorPicker(handler => {
                    const el = handler.getEl().querySelector('#textColorPicker');
                    const $el = jQuery(el);
                    $el.spectrum({
                        containerClassName: 'sp-container-inline',
                        color: handler.getColor(),
                        preferredFormat: "hex",
                        showInput: true,
                        showButtons: false,
                        showAlpha: true,
                        change(color) {
                            handler.setColor(color.toRgbString());
                        },
                        move(color) {
                            handler.setColor(color.toRgbString(), 0);
                        }
                    });

                    return () => {
                        $el.spectrum('destroy');
                    }
                });
                $scope.textGP.on('change', () => {
                    const colors = $scope.textGP.getHandlers()
                        .map(({color, position}) => [position / 100, color]);
                    $scope.setGradient(Object.fromEntries(colors), $scope.textGP.getType());
                });
            }

            $scope.onTextGradientTypeChanged = function (isRadial) {
                if (!$scope.textGP) {
                    return;
                }
                $scope.textGP.setType(isRadial ? 'radial' : 'linear');
            }

            $scope.onShapeGradientTypeChanged = function (isRadial) {
                if (!$scope.shapeGP) {
                    return;
                }
                $scope.shapeGP.setType(isRadial ? 'radial' : 'linear');
            }

            $scope.onBackgroundGradientTypeChanged = function (isRadial) {
                if (!$scope.backgroundGP) {
                    return;
                }
                $scope.backgroundGP.setType(isRadial ? 'radial' : 'linear');
            }

            $scope.initShapeGradientColorPicker = function () {
                $scope.shapeGP = new Grapick({
                    el: '#shapeGradientColorPicker',
                    colorEl: '<input id="shapeColorPicker"/>'
                });
                $scope.shapeGP.setColorPicker(handler => {
                    const el = handler.getEl().querySelector('#shapeColorPicker');
                    const $el = jQuery(el);
                    $el.spectrum({
                        containerClassName: 'sp-container-inline',
                        color: handler.getColor(),
                        preferredFormat: "hex",
                        showInput: true,
                        showButtons: false,
                        showAlpha: true,
                        change(color) {
                            handler.setColor(color.toRgbString());
                        },
                        move(color) {
                            handler.setColor(color.toRgbString(), 0);
                        }
                    });

                    return () => {
                        $el.spectrum('destroy');
                    }
                });
                $scope.shapeGP.on('change', () => {
                    const colors = $scope.shapeGP.getHandlers()
                        .map(({color, position}) => [position / 100, color]);
                    const direction = $scope.shapeGP.getDirection();
                    $scope.setGradient(Object.fromEntries(colors), $scope.shapeGP.getType(), direction);
                });
            }

            $scope.backgroundGPInitialized = false;

            $scope.initBackgroundColorPicker = function () {
                $scope.backgroundGP = new Grapick({
                    el: '#backgroundGradientColorPicker',
                    colorEl: '<input id="backgroundColorPicker"/>'
                });
                const canvas = $scope.getCurrentStageCanvas();
                $scope.backgroundGP.setColorPicker(handler => {
                    const el = handler.getEl().querySelector('#backgroundColorPicker');
                    const $el = jQuery(el);
                    $el.spectrum({
                        containerClassName: 'sp-container-inline',
                        color: handler.getColor(),
                        preferredFormat: "hex",
                        showInput: true,
                        showButtons: false,
                        showAlpha: true,
                        change(color) {
                            handler.setColor(color.toRgbString());
                        },
                        move(color) {
                            handler.setColor(color.toRgbString(), 0);
                        }
                    });

                    return () => {
                        $el.spectrum('destroy');
                    }
                });
                $scope.backgroundGP.on('change', () => {
                    if (!$scope.backgroundGPInitialized) {
                        $scope.backgroundGPInitialized = true;
                        return;
                    }
                    const colors = $scope.backgroundGP.getHandlers()
                        .map(({color, position}) => ({color, offset: position / 100}));
                    $scope.setBackgroundGradient(colors, $scope.backgroundGP.getType());
                });
            }

            $scope.setCurrentBackgoundGradientColor = function () {
                const _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!_canvas || !$scope.backgroundGP) {
                    return;
                }
                if (_canvas.backgroundColor.type === 'linear' || _canvas.backgroundColor.type === 'radial') {
                    $scope.backgroundGP.clear({silent: true});
                    $scope.backgroundGP.setType(_canvas.backgroundColor.type, {silent: true});
                    $timeout(() => {
                        $scope.gradientTypes.isBackgroundRadial = (_canvas.backgroundColor.type === 'radial');
                    });
                    _canvas.backgroundColor.colorStops
                        .forEach((stop) => {
                            const rgba = $scope.rgbToRgba(stop.color, stop.opacity);
                            $scope.backgroundGP.addHandler(stop.offset * 100, rgba, null);
                        });
                    if (_canvas.backgroundColor.type === 'linear') {
                        $scope.stages[$scope.currentStage].states.canvasLinearGradientAngle = Number(_canvas.get('linearGradientAngle') || 0);
                    }
                } else if (_canvas.backgroundColor && !_canvas.backgroundColor.type) {
                    $scope.backgroundGP.clear({silent: true});
                    $timeout(() => {
                        $scope.gradientTypes.isBackgroundRadial = false;
                    });
                    $scope.backgroundGP.addHandler(50, _canvas.backgroundColor);
                } else {
                    $timeout(() => {
                        $scope.gradientTypes.isBackgroundRadial = false;
                    });
                    $scope.backgroundGP.clear({silent: true});
                    $scope.backgroundGP.addHandler(50, 'transparent');
                }
            }
            $scope.rgbToRgba = function (rgb = 'rgb(0,0,0)', alpha = 1) {
                let rgba;
                rgba = rgb.replace(/rgb/i, "rgba");
                return rgba.replace(/\)/i, `,${alpha})`);
            }

            $scope.setCurrentShapeGradientColor = function (shape) {
                if (!shape || !$scope.shapeGP) {
                    return;
                }

                if (shape.fill && (shape.fill.type === 'linear' || shape.fill.type === 'radial')) {
                    $scope.shapeGP.clear({silent: true});
                    $scope.shapeGP.setType(shape.fill.type, {silent: true});
                    $timeout(() => {
                        $scope.gradientTypes.isShapeBackgroundRadial = (shape.fill.type === 'radial');
                    });
                    shape.fill.colorStops
                        .forEach((stop) => {
                            const rgba = $scope.rgbToRgba(stop.color, stop.opacity);
                            $scope.shapeGP.addHandler(stop.offset * 100, rgba, null);
                        });
                } else if (shape.fill && !shape.fill.type) {
                    $timeout(() => {
                        $scope.gradientTypes.isShapeBackgroundRadial = false;
                    });
                    $scope.shapeGP.clear({silent: true});
                    $scope.shapeGP.addHandler(50, shape.fill);
                } else {
                    $timeout(() => {
                        $scope.gradientTypes.isShapeBackgroundRadial = false;
                    });
                    $scope.shapeGP.clear({silent: true});
                    $scope.shapeGP.addHandler(50, 'transparent');
                }
            }

            $scope.setCurrentTextGradientColor = function (textbox) {
                if (!textbox || !$scope.textGP) {
                    return;
                }

                if (textbox.fill && (textbox.fill.type === 'linear' || textbox.fill.type === 'radial')) {
                    $scope.textGP.clear({silent: true});
                    $scope.textGP.setType(textbox.fill.type, {silent: true});
                    $timeout(() => {
                        $scope.gradientTypes.isTextBackgroundRadial = (textbox.fill.type === 'radial');
                    });
                    textbox.fill.colorStops
                        .forEach((stop) => {
                            const rgba = $scope.rgbToRgba(stop.color, stop.opacity);
                            $scope.textGP.addHandler(stop.offset * 100, rgba, null);
                        });
                } else if (textbox.fill && !textbox.fill.type) {
                    $timeout(() => {
                        $scope.gradientTypes.isTextBackgroundRadial = false;
                    });
                    $scope.textGP.clear({silent: true});
                    $scope.textGP.addHandler(50, textbox.fill);
                } else {
                    $timeout(() => {
                        $scope.gradientTypes.isTextBackgroundRadial = (textbox.fill.type === 'radial');
                    });
                    $scope.textGP.clear({silent: true});
                    $scope.textGP.addHandler(50, "transparent");
                }
            }

            $scope.setGradient = function (colorStops, type) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                if (!_canvas) return false;
                var activeObject = _canvas.getActiveObject();
                if (!activeObject) {
                    return;
                }
                const stops = colorStops && Object.keys(colorStops);
                const hasSingleStop = stops && stops.length === 1;
                const color = colorStops && colorStops[stops[0]];
                if (hasSingleStop && color === activeObject.fill) {
                    return;
                }
                if (type && type === 'radial') {
                    activeObject.setGradient('fill', {
                        type,
                        x1: activeObject.width / 2,
                        y1: activeObject.height / 2,
                        x2: activeObject.width / 2,
                        y2: activeObject.height / 2,
                        r1: Math.max(activeObject.width, activeObject.height) / 2,
                        r2: 0,
                        colorStops
                    });
                } else {
                    activeObject.setGradient('fill', {
                        type,
                        x1: activeObject.width / 4,
                        y1: 0,
                        x2: activeObject.width / 2 + activeObject.width / 4,
                        y2: 0,
                        colorStops
                    });
                }
                _canvas.renderAll();
            }

            $scope.setTextgradient = function (grdcolorone, grdcolortwo) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                if (!_canvas) return false;
                var activeobject = _canvas.getActiveObject();
                activeobject.setGradient('fill', {
                    type: 'linear',
                    x1: activeobject.width / 4,
                    y1: 0,
                    x2: activeobject.width / 2 + activeobject.width / 4,
                    y2: 0,
                    colorStops: {
                        0: grdcolorone,
                        1: grdcolortwo
                    }
                });
                _canvas.renderAll();
                GRADIENT_AWARE_TEXT.includes(activeobject.type) ?
                    $scope.setCurrentTextGradientColor(activeobject) :
                    $scope.setCurrentShapeGradientColor(activeobject);
                $scope.setCurrentShapeGradientColor(activeobject);
                $scope.handleGradientColor(activeobject);

            }

            $scope.handleGradientColor = function (item) {
                if (item.fill && (item.fill.type === 'linear' || item.fill.type === 'radial')) {
                    $scope.stages[$scope.currentStage].states.safeGradientValue = $scope.shapeGP.getSafeValue();
                } else {
                    $scope.stages[$scope.currentStage].states.safeGradientValue = null;
                }
            }

            $scope.setCanvasGradientBG = function (grdcolone, grdcoltwo) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                $scope.deleteCanvasBg();
                if (!_canvas) return false;
                var verticalgrad = new fabric.Gradient({
                    type: 'linear',
                    coords: {
                        x1: _canvas.width / 4,
                        y1: 0,
                        x2: _canvas.width / 2 + _canvas.width / 4,
                        y2: 0,
                    },
                    colorStops: [{
                        color: grdcolone,
                        offset: 0,
                    }, {
                        color: grdcoltwo,
                        offset: 1,
                    }]
                });
                _canvas.setBackgroundColor(verticalgrad);
                _canvas.renderAll();
            }

            $scope.setCanvasBGcolor = function (type, color) {
                jQuery('.nbd-color-picker').css('background', color);
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                $scope.deleteCanvasBg(false);
                if (!_canvas) return false;
                _canvas.setBackgroundColor(color);
                _canvas.renderAll()
            };

            $scope.setBackgroundGradient = function (colorStops, type) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                $scope.deleteCanvasBg(false);
                if (!_canvas) return false;
                let gradient;
                if (type && type === 'radial') {
                    gradient = new fabric.Gradient({
                        type,
                        coords: {
                            x1: _canvas.width / 2,
                            y1: _canvas.height / 2,
                            x2: _canvas.width / 2,
                            y2: _canvas.height / 2,
                            r1: Math.max(_canvas.width, _canvas.height) / 2,
                            r2: 0
                        },
                        colorStops
                    });
                } else {
                    gradient = new fabric.Gradient({
                        type,
                        coords: {
                            x1: 0,
                            y1: _canvas.height / 2,
                            x2: _canvas.width / 2,
                            y2: _canvas.height / 2,
                        },
                        colorStops
                    });
                }
                _canvas.setBackgroundColor(gradient);
                _canvas.renderAll();
            }

            $scope.setGradientbackground = function (grdcolorone, grdcolortwo) {
                //this.gradienttype = "gradientradial";
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                $scope.deleteCanvasBg(false);
                if (!_canvas) return false;
                var verticalgrad = new fabric.Gradient({
                    type: 'linear',
                    coords: {
                        x1: _canvas.width / 4,
                        y1: 0,
                        x2: _canvas.width / 2 + _canvas.width / 4,
                        y2: 0,
                    },
                    colorStops: [{
                        color: grdcolorone,
                        offset: 0,
                    }, {
                        color: grdcolortwo,
                        offset: 1,
                    }]
                });
                _canvas.setBackgroundColor(verticalgrad);
                _canvas.renderAll();
                $scope.setCurrentBackgoundGradientColor();

            };

            $scope.deleteCanvasBg = function (removeImage = true) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!_canvas) return false;
                _canvas.backgroundColor = '';
                _canvas.renderAll();
                if (removeImage) {
                    var objects = _canvas.getObjects().filter(function (o) {
                        return o.bg == true;
                    });
                    for (var i = 0; i < objects.length; i++) {
                        _canvas.remove(objects[i]);
                    }
                }
                _canvas.bgsrc = "";
                _canvas.bgcolor = "";
            };


            $scope.setoffsetX = function (value) {
                $scope.offsetX = value;
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                var activeObject = _canvas.getActiveObject();
                if (!activeObject) return;
                if (activeObject) {
                    activeObject.setShadow({
                        blur: $scope.blur,
                        color: $scope.shadowcolor,
                        offsetX: $scope.offsetX,
                        offsetY: $scope.offsetY
                    });
                    _canvas.renderAll();
                } else {
                }
            };

            $scope.replaceImage = function (imgpath) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                var actObj = _canvas.getActiveObject();
                if (!actObj) return;
                if (actObj && actObj.type == 'image') {
                    var img = new Image();
                    img.onload = function () {
                        w = actObj.width * actObj.scaleX;
                        h = actObj.height * actObj.scaleY;
                        actObj.setElement(img);
                        actObj.src = imgpath;
                        actObj.orgSrc = imgpath;
                        actObj.cw = w;
                        actObj.ch = h;

                        actObj.oldWidth = null;
                        actObj.oldHeight = null;
                        actObj.oldScaleX = null;
                        actObj.oldScaleY = null;
                        actObj.cropX = 0;
                        actObj.cropY = 0;

                        actObj.scaleX = w / actObj.width;
                        actObj.scaleY = h / actObj.height;

                        var ih = img.naturalHeight;
                        var iw = img.naturalWidth;
                        var fw, fh;
                        var width_ratio = w / iw;
                        var height_ratio = h / ih;
                        if (width_ratio > height_ratio) {
                            fw = iw * width_ratio;
                            fh = ih * fw / iw;
                        } else {
                            fh = ih * height_ratio;
                            fw = iw * fh / ih;
                        }
                        if (width_ratio > height_ratio) {
                            actObj.asw = actObj.cw = w / width_ratio;
                            actObj.ash = actObj.ch = h / width_ratio;
                        } else {
                            actObj.asw = actObj.cw = w / height_ratio;
                            actObj.ash = actObj.ch = h / height_ratio;
                        }
                        actObj.cx = 0;
                        actObj.cy = 0;
                        actObj.setCoords();
                        _canvas.renderAll();
                        if (actObj.borderRadius && $scope.imageHasTransparency(actObj)) {
                            actObj.set({
                                borderRadius: {
                                    radius: 0,
                                    leftTop: 0,
                                    rightTop: 0,
                                    rightBottom: 0,
                                    leftBottom: 0,
                                }
                            });
                        }
                        /*actObj.zoomBy(0, 0, 0, function() {
                        actObj.setCoords();
                        _canvas.renderAll();
                    });*/
                    }
                    img.src = imgpath;
                }

            };

            /*$scope.setShadowcolor = function() {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!appConfig.ready) return;
            var activeObject = _canvas.getActiveObject();
            if (!activeObject) return;
            if (activeObject) {
                activeObject.setShadow({
                    blur: $scope.blur,
                    color: $scope.shadowcolor,
                    offsetX: $scope.offsetX,
                    offsetY: $scope.offsetY
                });
                _canvas.renderAll();
            } else {}


        };*/

            $scope.setShadowcolor = function (color) {
                $scope.shadowcolor = color;
                jQuery('.shadowcolor').css('background', color);
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                var activeObject = _canvas.getActiveObject();
                if (!activeObject) return;
                if (activeObject) {
                    activeObject.setShadow({
                        blur: $scope.blur,
                        color: $scope.shadowcolor,
                        offsetX: $scope.offsetX,
                        offsetY: $scope.offsetY
                    });
                    _canvas.renderAll();
                } else {
                }


            };

            $scope.setoffsetY = function (value) {
                $scope.offsetY = value;
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                var activeObject = _canvas.getActiveObject();
                if (!activeObject) return;
                if (activeObject) {
                    activeObject.setShadow({
                        blur: $scope.blur,
                        color: $scope.shadowcolor,
                        offsetX: $scope.offsetX,
                        offsetY: $scope.offsetY
                    });
                    _canvas.renderAll();
                } else {
                }

            };

            $scope.setblur = function (value) {
                $scope.blur = value;
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                if (!appConfig.ready) return;
                var activeObject = _canvas.getActiveObject();
                if (!activeObject) return;
                if (activeObject) {
                    activeObject.setShadow({
                        blur: $scope.blur,
                        color: $scope.shadowcolor,
                        offsetX: $scope.offsetX,
                        offsetY: $scope.offsetY
                    });
                    _canvas.renderAll();
                } else {
                }

            };

            $scope.cutobjs = function () {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                var actObj = _canvas.getActiveObject();
                actObj.clone(function (cloned) {
                    $scope.clipboard = cloned;
                });
                _canvas.remove(actObj);
                _canvas.requestRenderAll();
            };
            $scope.writeOnClipboard = function (text) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        // Success!
                    })
                    .catch(err => {
                        console.log('Something went wrong in copying', err);
                    });
            }
            $scope.pasteExternalImage = function () {
                navigator.clipboard.read().then((data) => {
                    for (let i = 0; i < data.length; i++) {
                        if (!data[i].types.includes("image/png")) {
                            //alert("Clipboard contains non-image data. Unable to access it.");
                        } else {
                            data[i].getType("image/png").then((blob) => {
                                const file = new File([blob], `${+new Date()}.png`, {type: "image/png"});
                                $scope.toggleStageLoading();
                                NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                                    var data = JSON.parse(data);
                                    if (data.flag == 1) {
                                        $scope.addImageFromUrl(data.src, false);
                                        $scope.toggleStageLoading();
                                    }
                                }, () => {
                                });
                            });
                        }
                    }
                });
            }
            $scope.copyobjs = function () {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                var activeObj = _canvas.getActiveObject();
                if (activeObj) {
                    activeObj.clone(function (cloned) {
                        $scope.clipboard = cloned;
                    });
                    _canvas.requestRenderAll();
                } else {
                }
            };

            $scope.loadOverlays = function (json) {
                var _canvas = this.stages[$scope.currentStage]['canvas'];
                $scope.toggleStageLoading();
                if (_canvas) {
                    if (!json) return false;
                    var json = JSON.parse(json);
                    json.objects = json.objects;
                    if (json.frame_0) {
                        json = JSON.stringify(json.frame_0);
                        json = JSON.parse(json);
                        var ffs = $scope.getFFs(json, 'fontFamily');
                        ffs = $scope.removeDuplicates(ffs);
                        if (ffs && ffs.length == 0) ffs.push('Arvo');

                        WebFont.load({
                            google: {
                                families: ffs
                            },
                            active: function () {
                                var objects = json.objects;
                                fabric.util.enlivenObjects(objects, function (objects) {
                                    $scope.diffuseAnimation = true;
                                    _canvas.discardActiveObject();
                                    objects.forEach(function (o) {
                                        _canvas.add(o);
                                        o.setCoords();
                                    });
                                    _canvas.discardActiveObject();
                                    _canvas.requestRenderAll();

                                    $scope.diffuseAnimation = false;
                                    $scope.toggleStageLoading();
                                });
                            },
                            classes: false
                        });
                    } else {
                        var stage = $scope.stages[$scope.currentStage];
                        var scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                        var ffs = $scope.getFFs(json, 'fontFamily');
                        ffs = $scope.removeDuplicates(ffs);

                        layers = json.objects;
                        $scope.resource.tempData.template = [];

                        function loadLayers() {
                            $scope.loadTemplatesLayers(layers, function (objects) {
                                objects.forEach((object) => {
                                    if (object.shadow && object.shadow.color === 'rgb(0,0,0)') {
                                        object.shadow = null;
                                    }
                                    $scope.contextAddLayers = 'template';
                                    _canvas.add(object);
                                    if (object.maskId) {
                                        $scope.contextAddLayers = 'addMask';
                                        _canvas.add(object.clipPath);
                                    }
                                    var _item = _canvas.item(_canvas.getObjects().length - 1);
                                    $scope.resource.tempData.template.push(_item);
                                });
                                $scope.toggleStageLoading();
                                $scope.setHistory($scope.currentStage, true);
                            })
                        };

                        if (ffs.length) {
                            _.each(ffs, function (font, index) {
                                if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                                    $scope.resource.font.data.push(font);
                                }
                                ;
                                if (index == ffs.length - 1) {
                                    $scope.insertTemplateFont(font.alias, function () {
                                        loadLayers();
                                        if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                            stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                                        }
                                        ;
                                    });
                                } else {
                                    $scope.insertTemplateFont(font.alias, function () {
                                        if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                            stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                                        }
                                        ;
                                    });
                                }
                            });
                        } else {
                            loadLayers();
                        }
                    }
                } else {
                    console.log("Not loading WebFonts");
                    return false;
                }
            };
        }
        $scope.getFFs = function (obj, key) {
            var objects = [];
            for (var i in obj) {
                if (!obj.hasOwnProperty(i)) continue;
                if (typeof obj[i] == 'object') {
                    objects = objects.concat($scope.getFFs(obj[i], key));
                } else if (i === key) {
                    objects.push(obj[i]);
                }
            }
            return objects;
        };
        $scope.removeDuplicates = function (arr) {
            var obj = {};
            for (var i = 0; i < arr.length; i++) {
                obj[arr[i]] = true;
            }
            arr = [];
            for (var key in obj) {
                arr.push(key);
            }
            return arr;
        };

        $scope.downloadlayersvg = function () {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!_canvas.getActiveObject()) return;
            var activeObject = _canvas.getActiveObject();
            var currentTime = new Date();
            var month = currentTime.getMonth() + 1;
            var day = currentTime.getDate();
            var year = currentTime.getFullYear();
            var hours = currentTime.getHours();
            var minutes = currentTime.getMinutes();
            var seconds = currentTime.getSeconds();
            var filename = month + '' + day + '' + year + '' + hours + '' + minutes + '' + seconds;
            const svgString = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">${activeObject.toSVG()}</svg>`;
            const svgBlob = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
            const svgDataUrl = URL.createObjectURL(svgBlob);
            var link = document.createElement('a');
            link.href = svgDataUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };
        $scope.downloadlayerpng = function () {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!_canvas.getActiveObject()) return;
            var activeObject = _canvas.getActiveObject();
            const {width, height} = activeObject;
            var currentTime = new Date();
            var month = currentTime.getMonth() + 1;
            var day = currentTime.getDate();
            var year = currentTime.getFullYear();
            var hours = currentTime.getHours();
            var minutes = currentTime.getMinutes();
            var seconds = currentTime.getSeconds();
            var filename = month + '' + day + '' + year + '' + hours + '' + minutes + '' + seconds;
            var pngdataURL = activeObject.toDataURL();
            var link = document.createElement('a');
            link.href = pngdataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };
        $scope.copylayerpng = function () {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!_canvas.getActiveObject()) return;
            var activeObject = _canvas.getActiveObject();
            const {width, height} = activeObject;
            var pngdataURL = activeObject.toDataURL();
            var link = document.createElement('a');
            link.href = pngdataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };
        $scope.downloadjson = function () {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!_canvas.getActiveObject()) return;
            $scope.downloadAspng();
            var activeObject = _canvas.getActiveObject().ungroupOnCanvas();
            activeObject = activeObject.toJSON(['itemId', 'maskId', 'isMask', 'selectable', 'opacity', 'fill', 'lockRotation']);
            var currentTime = new Date();
            var month = currentTime.getMonth() + 1;
            var day = currentTime.getDate();
            var year = currentTime.getFullYear();
            var hours = currentTime.getHours();
            var minutes = currentTime.getMinutes();
            var seconds = currentTime.getSeconds();
            var fileName = month + '' + day + '' + year + '' + hours + '' + minutes + '' + seconds;

            var string = JSON.stringify(activeObject);

            var file = new Blob([string], {
                type: 'application/json'
            });
            var a = document.createElement('a');
            a.href = URL.createObjectURL(file);
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
        $scope.downloadAspng = function () {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!_canvas.getActiveObject()) return;
            var activeObject = _canvas.getActiveObject();
            const {top, left, width, height} = activeObject;
            var currentTime = new Date();
            var month = currentTime.getMonth() + 1;
            var day = currentTime.getDate();
            var year = currentTime.getFullYear();
            var hours = currentTime.getHours();
            var minutes = currentTime.getMinutes();
            var seconds = currentTime.getSeconds();
            var filename = month + '' + day + '' + year + '' + hours + '' + minutes + '' + seconds;
            var pngdataURL = _canvas.toDataURL({
                quality: 0.95,
                top,
                left,
                width,
                height
            });
            var link = document.createElement('a');
            link.href = pngdataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };
        $scope.deleteLayers = function (itemIndex) {
            if (!$scope.canDeleteLayer()) return;
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            var item = angular.isDefined(itemIndex) ? _canvas.item(itemIndex) : _canvas.getActiveObjects();
            /*advanced*/
            if (typeof mia_nbd_js_config_design != "undefined" && item[0].elementUpload) {
                return;
            }
            if (item) {
                if (angular.isDefined(itemIndex)) {
                    /*$scope.setHistory({
                    element: item,
                    parameters: JSON.stringify(item.toJSON()),
                    interaction: 'remove'
                });*/
                    if (!!item.get('maskId')) {
                        var maskLayer = $scope.getMaskLayer(item.get('maskId'));
                        _canvas.remove(maskLayer);
                    }
                    _canvas.remove(item);
                } else {
                    _canvas.getActiveObjects().forEach(function (o) {
                        /*$scope.setHistory({
                        element: o,
                        parameters: JSON.stringify(o.toJSON()),
                        interaction: 'remove'
                    }); */
                        if (!!o.get('maskId')) {
                            maskLayer = $scope.getMaskLayer(o.get('maskId'));
                            _canvas.remove(maskLayer);
                        }
                        _canvas.remove(o);
                    });
                }
                $scope.setHistory($scope.currentStage, true);
                _canvas.discardActiveObject().requestRenderAll();
            }
            ;
            $scope.updateLayersList();
            return;
        };
        $scope.resetLayer = function () {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage['canvas'];
            var index = 'frame_' + $scope.currentStage;
            var initialItems = null;
            var item = _canvas.getActiveObject();
            if (angular.isDefined($scope.settings.product_data.design)) {
                initialItems = $scope.settings.product_data.design[index].objects;
            } else {
                return;
            }
            var initialItem = _.find(initialItems, {itemId: item.get('itemId')});
            if (angular.isDefined(initialItem)) {
                item.set(initialItem);
                item.setCoords();
                $scope.deactiveAllLayer();
                $scope.renderStage();
            }
            return;
        };
        $scope.activeLayer = function (itemIndex, layerIndex, e) {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage['canvas'];
            if (e && (e.shiftKey || e.ctrlKey || e.metaKey)) {
                const item = _canvas.item(itemIndex);
                const objects = _canvas.getActiveObjects();
                if (!objects.length) {
                    _canvas.setActiveObject(item);
                    _canvas.requestRenderAll();
                    $scope.updateApp();
                    return;
                }
                const objectIds = objects.map((o) => o.itemId);
                if (!objectIds.includes(item.itemId)) {
                    _canvas.discardActiveObject();
                    var sel = new fabric.ActiveSelection([...objects, item], {
                        canvas: _canvas,
                    });
                    $scope.stages[$scope.currentStage].states.activeIds = [...objectIds, item.itemId];
                    _canvas.setActiveObject(sel);
                    _canvas.requestRenderAll();
                } else {
                    _canvas.discardActiveObject();
                    const activeObjects = objects.filter((o) => o.itemId !== item.itemId);
                    if (activeObjects.length && activeObjects.length > 1) {
                        var sel = new fabric.ActiveSelection([...activeObjects], {
                            canvas: _canvas,
                        });
                        $scope.stages[$scope.currentStage].states.activeIds = [...activeObjects.map((o) => o.itemId)];
                        _canvas.setActiveObject(sel);
                        _canvas.requestRenderAll();
                    } else if (activeObjects.length) {
                        _canvas.setActiveObject(activeObjects[0]);
                        _canvas.requestRenderAll();
                    }
                }
            } else {
                if (!$scope.isTemplateMode && angular.isDefined(_canvas.item(itemIndex).forceLock) && _canvas.item(itemIndex).forceLock) return;
                _canvas.setActiveObject(_canvas.item(itemIndex));
                if (angular.isDefined(layerIndex)) _stage.layers[layerIndex].active = true;
            }
            $scope.renderStage();
        };
        $scope.copyLayers = function (objectToCopy) {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!objectToCopy && !_canvas.getActiveObject()) return;
            var activeObject = objectToCopy || _canvas.getActiveObject();
            activeObject.clone(function (cloned) {
                var _clipboard = cloned;

                function _clone(__clipboard, mask) {
                    $timeout(function () {
                        __clipboard.clone(function (clonedObj) {
                            _canvas.discardActiveObject();
                            clonedObj.set({
                                left: clonedObj.left + 10,
                                top: clonedObj.top + 10,
                                evented: true
                            });
                            if (clonedObj.type === 'activeSelection') {
                                clonedObj.canvas = _canvas;
                                clonedObj.forEachObject(function (obj) {
                                    $scope.contextAddLayers = 'copy';
                                    _canvas.add(obj);
                                });
                                clonedObj.setCoords();
                            } else {
                                $scope.contextAddLayers = 'copy';
                                _canvas.add(clonedObj);
                                if (angular.isDefined(mask)) {
                                    clonedObj.set({
                                        clipPath: mask,
                                        maskId: mask.get('itemId'),
                                        centeredScaling: true
                                    });
                                    $scope.updateMaskLayer();
                                }
                            }
                            _canvas.setActiveObject(clonedObj);
                            _canvas.requestRenderAll();
                        }, ['crop']);
                    }, 10);
                }

                if (cloned.type != 'activeSelection' && !!activeObject.get('maskId')) {
                    var maskLayer = $scope.getMaskLayer(activeObject.get('maskId'));
                    if (maskLayer) {
                        maskLayer.clone(function (cloned) {
                            var _maskClipboard = cloned;
                            $timeout(function () {
                                _clone(_maskClipboard);
                                $timeout(function () {
                                    var mask = _canvas.item(_canvas.getObjects().length - 1);
                                    mask.set({
                                        isMask: 1,
                                        absolutePositioned: true,
                                        selectable: false
                                    });
                                    _clone(_clipboard, mask);
                                }, 10);
                            }, 10);
                        }, ['crop']);
                    } else {
                        _clone(_clipboard);
                    }
                } else {
                    _clone(_clipboard);
                }
            }, ['crop']);
        };
        $scope.alignLayer = function (command) {
            var _canvas = this.stages[this.currentStage].canvas,
                group = _canvas.getActiveObject(),
                items = _canvas.getActiveObjects(),
                _bound = items[0].getBoundingRect(),
                position = {
                    left: _bound.left,
                    top: _bound.top,
                    right: _bound.left + _bound.width,
                    bottom: _bound.top + _bound.height
                };
            var _leftPosition = [],
                _topPosition = [],
                totalWidth = 0,
                totalHeight = 0;

            items.forEach(function (item, index) {
                var bound = item.getBoundingRect();
                if (bound.left < position.left) position.left = bound.left;
                if (bound.top < position.top) position.top = bound.top;
                if (bound.left + bound.width > position.right) position.right = bound.left + bound.width;
                if (bound.top + bound.height > position.bottom) position.bottom = bound.top + bound.height;
                _leftPosition.push({index: index, value: bound.left});
                _topPosition.push({index: index, value: bound.top});
                totalWidth += bound.width;
                totalHeight += bound.height;
            });
            switch (command) {
                case 'horizontal':
                    items.forEach(function (item) {
                        var bound = item.getBoundingRect();
                        item.set({top: item.get('top') + (position.top + position.bottom) / 2 - bound.top - bound.height / 2});
                        item.setCoords();
                    });
                    break;
                case 'vertical':
                    items.forEach(function (item) {
                        var bound = item.getBoundingRect();
                        item.set({left: item.get('left') + (position.left + position.right) / 2 - bound.left - bound.width / 2});
                        item.setCoords();
                    });
                    break;
                case 'top':
                    items.forEach(function (item) {
                        var bound = item.getBoundingRect();
                        item.set({top: item.get('top') + position.top - bound.top});
                        item.setCoords();
                    });
                    break;
                case 'bottom':
                    items.forEach(function (item) {
                        var bound = item.getBoundingRect();
                        item.set({top: item.get('top') + position.bottom - bound.top - bound.height});
                        item.setCoords();
                    });
                    break;
                case 'left':
                    items.forEach(function (item) {
                        var bound = item.getBoundingRect();
                        item.set({left: item.get('left') - bound.left + position.left});
                        item.setCoords();
                    });
                    break;
                case 'right':
                    items.forEach(function (item) {
                        var bound = item.getBoundingRect();
                        item.set({left: item.get('left') - bound.left + position.right - bound.width});
                        item.setCoords();
                    });
                    break;
                case 'dis-horizontal':
                    var leftPosition = _.sortBy(_leftPosition, [function (o) {
                        return o.value;
                    }]);
                    var space = (position.right - position.left - totalWidth) / (items.length - 1);
                    leftPosition.forEach(function (_item, _index) {
                        var index = _item.index;
                        if (_index > 0 && _index < items.length - 1) {
                            var item = items[index],
                                previous_item = items[leftPosition[_index - 1].index],
                                bound = item.getBoundingRect(),
                                previous_item_bound = previous_item.getBoundingRect();
                            item.set({'left': item.get('left') - bound.left + previous_item_bound.left + previous_item_bound.width + space});
                            item.setCoords();
                        }
                    });
                    break;
                case 'dis-vertical':
                    var topPosition = _.sortBy(_topPosition, [function (o) {
                        return o.value;
                    }]);
                    var space = (position.bottom - position.top - totalHeight) / (items.length - 1);
                    topPosition.forEach(function (_item, _index) {
                        var index = _item.index;
                        if (_index > 0 && _index < items.length - 1) {
                            var item = items[index],
                                previous_item = items[topPosition[_index - 1].index],
                                bound = item.getBoundingRect(),
                                previous_item_bound = previous_item.getBoundingRect();
                            item.set({'top': item.get('top') - bound.top + previous_item_bound.top + previous_item_bound.height + space});
                            item.setCoords();
                        }
                    });
                    break;
            }
            ;
            group.addWithUpdate();
            this.renderStage();
        };
        $scope.translateLayer = function (command) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage.canvas,
                item = _canvas.getActiveObject();
            if (!item) return;
            let cropper;
            if (item.isImageCropper) {
                cropper = item
                const imageIndex = $scope.getLayerById(item.imageId);
                item = _canvas.item(imageIndex);
            }
            var bound = item.getBoundingRect(),
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                left = item.get('left'),
                top = item.get('top'),
                originX = item.get('originX'),
                originY = item.get('originY');
            $scope.beforeObjectModify(item);
            stage.states.isShowToolBox = false;
            switch (command) {
                case 'horizontal':
                    _canvas.viewportCenterObjectH(item);
                    break;
                case 'vertical':
                    _canvas.viewportCenterObjectV(item);
                    break;
                case 'center':
                    _canvas.viewportCenterObjectH(item);
                    _canvas.viewportCenterObjectV(item);
                    break;
                case 'top':
                    var _top = originY == 'center' ? bound.height / 2 / scale : top - bound.top / scale;
                    item.set({top: _top});
                    break;
                case 'top-left':
                    var _top = top - bound.top / scale, _left = left - bound.left / scale;
                    if (originX == 'center') {
                        _left = bound.width / 2 / scale;
                    }
                    if (originY == 'center') {
                        _top = bound.height / 2 / scale;
                    }
                    item.set({top: _top, left: _left});
                    break;
                case 'top-center':
                    _canvas.viewportCenterObjectH(item);
                    var _top = originY == 'center' ? bound.height / 2 / scale : top - bound.top / scale;
                    item.set({top: _top});
                    break;
                case 'top-right':
                    var _top = originY == 'center' ? bound.height / 2 / scale : top - bound.top / scale,
                        _left = left + (_canvas.width - bound.width - bound.left) / scale;
                    item.set({top: _top, left: _left});
                    break;
                case 'bottom':
                    var _top = top + (_canvas.height - bound.height - bound.top) / scale;
                    item.set({top: _top});
                    break;
                case 'bottom-left':
                    var _left = originX == 'center' ? bound.width / 2 / scale : left - bound.left / scale,
                        _top = top + (_canvas.height - bound.height - bound.top) / scale;
                    item.set({left: _left, top: _top});
                    break;
                case 'bottom-center':
                    _canvas.viewportCenterObjectH(item);
                    var _top = top + (_canvas.height - bound.height - bound.top) / scale;
                    item.set({top: _top});
                    break;
                case 'bottom-right':
                    var _left = left + (_canvas.width - bound.width - bound.left) / scale,
                        _top = top + (_canvas.height - bound.height - bound.top) / scale;
                    item.set({left: _left, top: _top});
                    break;
                case 'left':
                    var _left = originX == 'center' ? bound.width / 2 / scale : left - bound.left / scale;
                    item.set({left: _left});
                    break;
                case 'middle-left':
                    _canvas.viewportCenterObjectV(item);
                    var _left = originX == 'center' ? bound.width / 2 / scale : left - bound.left / scale;
                    item.set({left: _left});
                    break;
                case 'right':
                    var _left = left + (_canvas.width - bound.width - bound.left) / scale;
                    item.set({left: _left});
                    break;
                case 'middle-right':
                    _canvas.viewportCenterObjectV(item);
                    var _left = left + (_canvas.width - bound.width - bound.left) / scale;
                    item.set({left: _left});
                    break;
            }
            ;
            if (cropper) {
                cropper.set({
                    left: item.left,
                    top: item.top
                });
                cropper.setCoords();
            }
            $scope.updateLayerPositionObject(item);
            item.setCoords();
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.onPositionXChanged = function () {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage.canvas,
                item = _canvas.getActiveObject();
            if (!item) return;
            let cropper;
            if (item.isImageCropper) {
                cropper = item
                const imageIndex = $scope.getLayerById(item.imageId);
                item = _canvas.item(imageIndex);
            }
            $scope.beforeObjectModify(item);
            stage.states.isShowToolBox = false;
            item.set({
                left: +$scope.layerPosition.x.toFixed(2)
            });
            if (cropper) {
                cropper.set({
                    left: item.left,
                });
                cropper.setCoords();
            }
            item.setCoords();
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.onPositionYChanged = function () {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage.canvas,
                item = _canvas.getActiveObject();
            if (!item) return;
            let cropper;
            if (item.isImageCropper) {
                cropper = item
                const imageIndex = $scope.getLayerById(item.imageId);
                item = _canvas.item(imageIndex);
            }
            $scope.beforeObjectModify(item);
            stage.states.isShowToolBox = false;
            item.set({
                top: +$scope.layerPosition.y.toFixed(2)
            });
            if (cropper) {
                cropper.set({
                    top: item.top
                });
                cropper.setCoords();
            }
            item.setCoords();
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.onPositionWChanged = function () {
            if (!$scope.layerPosition.w) {
                return;
            }
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage.canvas,
                item = _canvas.getActiveObject();
            if (!item) return;
            let cropper;
            if (item.isImageCropper) {
                cropper = item
                const imageIndex = $scope.getLayerById(item.imageId);
                item = _canvas.item(imageIndex);
            }
            $scope.beforeObjectModify(item);
            stage.states.isShowToolBox = false;
            item.set({
                width: +($scope.layerPosition.w / item.scaleX).toFixed(2)
            });
            if (cropper) {
                cropper.set({
                    width: item.width
                });
                cropper.setCoords();
            }
            item.setCoords();
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.onPositionHChanged = function () {
            if (!$scope.layerPosition.h) {
                return;
            }
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage.canvas,
                item = _canvas.getActiveObject();
            if (!item) return;
            let cropper;
            if (item.isImageCropper) {
                cropper = item
                const imageIndex = $scope.getLayerById(item.imageId);
                item = _canvas.item(imageIndex);
            }
            $scope.beforeObjectModify(item);
            stage.states.isShowToolBox = false;
            item.set({
                height: $scope.layerPosition.h / item.scaleY
            });
            if (cropper) {
                cropper.set({
                    height: +item.height.toFixed(2)
                });
                cropper.setCoords();
            }
            item.setCoords();
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.onPositionOffsetXChanged = function () {
            const canvas = $scope.getCurrentStageCanvas();
            if (!canvas) {
                return;
            }
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'image' || activeObject.type === 'bg-image')) {
                activeObject.set({
                    offsetX: +$scope.layerPosition.offsetX.toFixed(2)
                });
                canvas.requestRenderAll();
            }
        }
        $scope.onPositionOffsetYChanged = function () {
            const canvas = $scope.getCurrentStageCanvas();
            if (!canvas) {
                return;
            }
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'image' || activeObject.type === 'bg-image')) {
                activeObject.set({
                    offsetY: +$scope.layerPosition.offsetY.toFixed(2)
                });
                canvas.requestRenderAll();
            }
        }
        $scope.fitToStage = function (direction, item) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage.canvas,
                item = angular.isDefined(item) ? item : _canvas.getActiveObject();
            if (!item) return;
            direction = angular.isDefined(direction) ? direction : 'both';
            var originX = item.get('originX'),
                originY = item.get('originY'),
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
            switch (direction) {
                case 'width':
                    var _left = originX == 'center' ? _canvas.width / 2 / scale : 0;
                    item.set({
                        left: _left,
                        scaleX: _canvas.width / item.width / scale,
                        scaleY: _canvas.width / item.width / scale
                    });
                    _canvas.viewportCenterObjectV(item);
                    break;
                case 'height':
                    var _top = originY == 'center' ? _canvas.height / 2 / scale : 0;
                    item.set({
                        top: _top,
                        scaleX: _canvas.height / item.height / scale,
                        scaleY: _canvas.height / item.height / scale
                    });
                    _canvas.viewportCenterObjectH(item);
                    break;
                default:
                    var _top = originY == 'center' ? _canvas.height / 2 / scale : 0;
                    var _left = originX == 'center' ? _canvas.width / 2 / scale : 0;
                    item.set({
                        top: _top,
                        left: _left,
                        scaleX: _canvas.width / item.width / scale,
                        scaleY: _canvas.height / item.height / scale
                    });
                    _canvas.viewportCenterObjectH(item);
                    _canvas.viewportCenterObjectV(item);
            }
            item.setCoords();
            $scope.updateCorners();
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.getLayerById = function (itemId) {
            var _canvas = this.stages[this.currentStage].canvas;
            var _index;
            _canvas.forEachObject(function (obj, index) {
                if (obj.get('itemId') == itemId) _index = index;
            });
            return _index;
        };
        $scope.getMaskLayer = function (itemId) {
            var _canvas = this.stages[this.currentStage].canvas;
            var layer;
            _canvas.forEachObject(function (obj, index) {
                if (obj.get('itemId') == itemId) layer = obj;
            });
            return layer;
        };
        $scope.getMaskedLayerByMaskId = function (maskId, stageId) {
            stageId = stageId ? stageId : $scope.currentStage;
            var _canvas = this.stages[stageId].canvas;
            var layer;
            _canvas.forEachObject(function (obj, index) {
                if (obj.get('maskId') == maskId) layer = obj;
            });
            return layer;
        };
        $scope.closePopupClearStage = function () {
            jQuery('.clear-stage-alert .close-popup').triggerHandler('click');
        };
        $scope.closePopupClearAllStages = function () {
            jQuery('.clear-all-stage-alert .close-popup').triggerHandler('click');
        };
        $scope.closePopupGrid = function () {
            jQuery('.popup-nbd-stage-grid-view .close-popup').triggerHandler('click');
        };
        $scope.zoomStage = function (index, stage_id) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            var _stage = $scope.stages[stage_id],
                _canvas = _stage['canvas'];
            _stage.states.isShowToolBox = true;
            _stage.states.currentScaleIndex = index;
            _stage.states.corners = [];
            $scope.setStageDimension(stage_id);
            _canvas.setZoom(_stage.states.scaleRange[_stage.states.currentScaleIndex].ratio);
            jQuery('#stage-container-' + $scope.currentStage).stop().animate({
                scrollTop: 0,
                scrollLeft: 0
            }, 100);
            jQuery('#stage-container-' + $scope.currentStage).perfectScrollbar('update');
            if (appConfig.isVisual) $scope.deactiveAllLayer();
            this.renderStage();
            if ($scope.settings.showRuler && appConfig.isModern) {
                _stage.hozRuler.update({
                    config: _stage.config,
                    zoomRatio: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio
                });
                _stage.verRuler.update({
                    config: _stage.config,
                    zoomRatio: _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio
                });
            }
            ;

            $timeout(function () {
                $scope.processAreaDesignShape(stage_id);
            });
        };
        $scope.confirmClearStage = function () {
            if (!$scope.canDeleteLayer()) return;
            jQuery('.nbd-popup.clear-stage-alert, .v-popup.v-popup-select').nbShowPopup();
        };
        $scope.clearStage = function () {
            if (!$scope.canDeleteLayer()) return;
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'];
            _canvas.clear();
            jQuery('.clear-stage-alert .close-popup').triggerHandler('click');
            if (stage.config.bgType == 'color') {
            }
            if (stage.config.area_design_type == "2") {
                $scope.contextAddLayers = 'template';
                var width = _canvas.width,
                    height = _canvas.height,
                    path = new fabric.Path("M0 0 H" + width + " V" + height + " H0z M " + width / 2 + " 0 A " + width / 2 + " " + height / 2 + ", 0, 1, 0, " + width / 2 + " " + height + " A " + width / 2 + " " + height / 2 + ", 0, 1, 0, " + width / 2 + " 0z");
                path.set({strokeWidth: 0, isAlwaysOnTop: true, fill: '#ffffff', selectable: false, evented: false});
                _canvas.add(path);
            }
            $scope.updateLayersList();
            _canvas.requestRenderAll();
            $scope.setHistory($scope.currentStage, true);
            $scope.stageDesignChanged();
        };
        $scope.selectAllLayers = function () {
            var _canvas = this.stages[this.currentStage]['canvas'];
            $scope.deactiveAllLayer();
            var objs = [];
            _canvas.forEachObject(function (obj, index) {
                if (obj.get('selectable')) objs.push(obj);
            });
            var selection = new fabric.ActiveSelection(objs, {
                canvas: _canvas
            });
            selection.addWithUpdate();
            _canvas.setActiveObject(selection);
            $scope.renderStage();
        };
        $scope.stageToJson = function (stage_id) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            $scope.renderStage(stage_id);
            var json = this.stages[stage_id]['canvas'].toJSON($scope.includeExport);
            return json;
        };
        $scope.loadStageFromJson = function (stage_id, json) {
            /*         var _canvas = this.stages[stage_id]['canvas'];
        _canvas.loadFromJSON(json, function() {
            $scope.renderStage(stage_id);
        }); */
            $scope._loadStageFromJson(stage_id, json, function () {
                $scope.clearClipboardDesign();
            });
        };
        $scope.copyStage = function (stage_id) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            $scope.tempStageDesign = {
                id: stage_id,
                design: $scope.stageToJson()
            };
        };
        $scope.pasteStage = function (dist_stage) {
            dist_stage = angular.isDefined(dist_stage) ? dist_stage : $scope.currentStage;
            if ($scope.tempStageDesign.id == dist_stage) return;
            $scope.loadStageFromJson(dist_stage, $scope.tempStageDesign.design);
        };
        $scope.clearClipboardDesign = function () {
            $scope.tempStageDesign = null;
        };
        $scope.duplicateStage = function (stage_id) {
            if ($scope.stages.length == $scope.settings.maxNoOfStage) return;
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            $scope.copyStage();
            $scope._addStage(stage_id);
            $timeout(function () {
                $scope.loadStageFromJson(stage_id * 1 + 1, $scope.tempStageDesign.design);
            }, 100);
        };
        $scope.maybeAddStage = function (stage_id) {
            if (!$scope.settings.dynamicStage) return;
            $scope._addStage(stage_id - 1);
        };
        $scope._addStage = function (stage_id) {
            if ($scope.stages.length == $scope.settings.maxNoOfStage) return;
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            $scope.preventLoadDesign = true;
            if (angular.isUndefined($scope.settings.product_data.origin_product)) {
                $scope.settings.product_data.origin_product = [];
                angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
            }
            var new_stage = {}, new_product_stage = {};

            angular.copy($scope.settings.product_data.product[stage_id], new_product_stage);
            $scope.settings.product_data.product.splice(stage_id * 1 + 1, 0, new_product_stage);

            angular.copy($scope.stages[stage_id], new_stage);
            new_stage.design = '';
            new_stage.config.name += ' (copy)';
            $scope.stages.splice(stage_id * 1 + 1, 0, new_stage);
        };
        $scope.stageWillBeDelete = 0;
        $scope.confirmDeleteStage = function (stage_id) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            $scope.stageWillBeDelete = stage_id;
            jQuery('.delete-stage-alert').nbShowPopup();
        };
        $scope.deleteStage = function () {
            jQuery('.delete-stage-alert .close-popup').triggerHandler('click');
            $scope._deleteStage($scope.stageWillBeDelete);
        };
        $scope.cancelDeleteStage = function (stage_id) {
            jQuery('.delete-stage-alert .close-popup').triggerHandler('click');
        };
        $scope._deleteStage = function (stage_id, callback, switchStage = true) {
            if ($scope.stages.length == $scope.settings.minNoOfStage) return;
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            $scope.preventLoadDesign = true;
            appConfig.ready = false;
            if (angular.isUndefined($scope.settings.product_data.origin_product)) {
                $scope.settings.product_data.origin_product = [];
                angular.copy($scope.settings.product_data.product, $scope.settings.product_data.origin_product);
            }
            if ($scope.currentStage == stage_id && $scope.currentStage > 0 && switchStage) {
                $scope.switchStage($scope.currentStage, 'prev', 'top-bottom', true);
            }
            if ($scope.currentStage == 0 && switchStage) {
                $scope.switchStage($scope.currentStage, 'next', 'top-bottom', true);
            }
            if ($scope.currentStage >= stage_id && $scope.currentStage > 0) {
                $scope.currentStage--;
            }
            $scope.settings.product_data.product.splice(stage_id, 1);
            $scope.stages.splice(stage_id, 1);
            $timeout(function () {
                appConfig.ready = true;
                $scope.updateApp();
                if (typeof callback == 'function') {
                    callback();
                }
            }, 100);
        };
        $scope.swapStage = function (dst_id, src_id, callback) {
            var dst_stage = {}, dst_product_stage = {}, src_stage = {}, src_product_stage = {};
            appConfig.ready = false;
            $scope.preventLoadDesign = true;

            angular.copy($scope.settings.product_data.product[dst_id], dst_product_stage);
            angular.copy($scope.settings.product_data.product[src_id], src_product_stage);
            angular.copy($scope.stages[dst_id], dst_stage);
            angular.copy($scope.stages[src_id], src_stage);
            $scope.settings.product_data.product[dst_id] = src_product_stage;
            $scope.settings.product_data.product[src_id] = dst_product_stage;
            $scope.stages[dst_id] = src_stage;
            $scope.stages[src_id] = dst_stage;

            var dst_design = $scope.stageToJson(dst_id),
                src_design = $scope.stageToJson(src_id);

            $timeout(function () {
                $scope.loadStageFromJson(dst_id, src_design);
                $scope.loadStageFromJson(src_id, dst_design);
                appConfig.ready = true;
                $scope.preventLoadDesign = false;

                if (typeof callback == 'function') {
                    callback();
                }
            }, 100);
        };
        $scope.$on('stage:move', function (event, from, to) {
            $scope.moveStage(from, to);
        });
        $scope.moveStage = function (from, to, callback) {
            if (from == to || from == (to - 1)) return;
            var from_stage = {}, from_product_stage = {}, currentStage = $scope.currentStage,
                _to = from > to ? to : (to - 1),
                from_design = $scope.stageToJson(from);

            angular.copy($scope.settings.product_data.product[from], from_product_stage);
            angular.copy($scope.stages[from], from_stage);
            $scope.settings.product_data.product.splice(from, 1);
            $scope.stages.splice(from, 1);
            $scope.preventLoadDesign = true;
            appConfig.ready = false;

            $scope.settings.product_data.product.splice(_to, 0, from_product_stage);
            $scope.stages.splice(_to, 0, from_stage);
            jQuery('.popup-nbd-stage-grid-view .overlay-main').addClass('active');

            $timeout(function () {
                $scope._loadStageFromJson(_to, from_design, function () {
                    $scope.preventLoadDesign = false;
                    appConfig.ready = true;
                    $scope.switchStageTo(currentStage);
                    $scope.updateApp();
                    jQuery('.popup-nbd-stage-grid-view .overlay-main').removeClass('active');
                    if (typeof callback == 'function') {
                        callback();
                    }
                }, true);
            }, 300);
        };
        $scope.showGridView = function () {
            $scope.toggleStageLoading();
            $scope.saveDesign();
            _showGridView = function () {
                $scope.toggleStageLoading();
                jQuery('.nbd-popup.popup-nbd-stage-grid-view').nbShowPopup();
                $scope.settings.gridViewMode = true;
            }
            if ($scope.checkSaveStatus()) {
                _showGridView();
            } else {
                var interval = $interval(function () {
                    if ($scope.checkSaveStatus()) {
                        $interval.cancel(interval);
                        _showGridView();
                    }
                }, 100);
            }
        };
        $scope.duplicateDesign = function (stage_id) {
            stage_id = angular.isDefined(stage_id) ? stage_id : $scope.currentStage;
            var next_stage_id = parseInt(stage_id) + 1;
            $scope.copyStage(stage_id);
            if (angular.isDefined($scope.stages[next_stage_id])) {
                var _canvas = $scope.stages[next_stage_id].canvas;
                $scope.onloadTemplate = true;
                $scope.contextAddLayers = 'template';
                _canvas.loadFromJSON($scope.tempStageDesign.design, function () {
                    $scope.switchStage($scope.currentStage, 'next', 'top-bottom');
                    $scope.renderStage(next_stage_id);
                    $timeout(function () {
                        $scope.contextAddLayers = 'normal';
                        $scope.onloadTemplate = false;
                    });
                });
            }
        };
        $scope.rotateLayer = function (command) {
            var _canvas = this.stages[this.currentStage]['canvas'],
                item = _canvas.getActiveObject();
            $scope.beforeObjectModify(item);
            switch (command) {
                case 'reflect-hoz':
                    item.toggle("flipY");
                    break;
                case 'reflect-ver':
                    item.toggle("flipX");
                    break;
                case '90cw':
                    var angle = item.get('angle') + 90;
                    if (angle > 360) angle = angle - 360;
                    if (angle < 0) angle = angle + 360;
                    item.set({angle: angle});
                    break;
                case '90ccw':
                    var angle = item.get('angle') - 90;
                    if (angle > 360) angle = angle - 360;
                    if (angle < 0) angle = angle + 360;
                    item.set({angle: angle});
                    break;
                case '180':
                    var angle = item.get('angle') + 180;
                    if (angle > 360) angle = angle - 360;
                    if (angle < 0) angle = angle + 360;
                    item.set({angle: angle});
                    break;
                default:
                    var angle = parseInt(command);
                    item.set({angle: angle});
            }
            ;
            item.setCoords();
            this.renderStage();
            $scope.afterObjectModify();
        };
        $scope.scaleLayer = function (command) {
            var _stage = this.stages[this.currentStage],
                _canvas = _stage.canvas,
                obj = _canvas.getActiveObject();
            if (!obj) return;
            $scope.beforeObjectModify(obj);
            if (_stage.lockMovementY || _stage.lockMovementX) return;
            var scaleX = obj.scaleX,
                scaleY = obj.scaleY,
                left = obj.left,
                top = obj.top,
                originX = obj.originX,
                originY = obj.originY,
                width = obj.width * scaleX,
                height = obj.height * scaleY,
                factor = command === "+" ? 1.1 : 0.9;
            var tempScaleX = scaleX * factor,
                tempScaleY = scaleY * factor,
                tempWidth = width * factor,
                tempHeight = height * factor,
                tempLeft = left + width / 2 - tempWidth / 2,
                tempTop = top + height / 2 - tempHeight / 2;
            if (originX == 'center') {
                tempLeft = left;
            }
            if (originY == 'center') {
                tempTop = top;
            }
            obj.scaleX = tempScaleX;
            obj.scaleY = tempScaleY;
            obj.left = tempLeft;
            obj.top = tempTop;
            obj.setCoords();
            $scope.adjustMaskedLayers(obj);
            $scope.renderStage();
            $scope.afterObjectModify();
        };
        $scope.moveLayer = function (command, alt) {
            var _canvas = this.stages[this.currentStage].canvas,
                items = _canvas.getActiveObjects(),
                selection = _canvas.getActiveObject(),
                step = alt ? 1 : 10;
            if (items.length == 0) return;
            angular.merge($scope.stages[$scope.currentStage].states.boundingObject, {visibility: 'hidden'});
            items.forEach(function (item) {
                $scope.beforeObjectModify(item);
                switch (command) {
                    case 'up':
                        if (!item.get("lockMovementY")) item.set('top', item.get('top') - step);
                        break;
                    case 'down':
                        if (!item.get("lockMovementY")) item.set('top', item.get('top') + step);
                        break;
                    case 'left':
                        if (!item.get("lockMovementX")) item.set('left', item.get('left') - step);
                        break;
                    case 'right':
                        if (!item.get("lockMovementX")) item.set('left', item.get('left') + step);
                        break;
                }
                ;
                item.setCoords();
            });
            if (selection.type === 'activeSelection') {
                selection.addWithUpdate();
            }
            ;
            this.updateApp();
            this.renderStage();
            $scope.afterObjectModify();
        };
        $scope.sortLayer = function (srcIndex, dstIndex) {
            var _canvas = this.stages[this.currentStage].canvas,
                item = _canvas.item(srcIndex);
            item.moveTo(dstIndex);
            $scope.setStackLayerAlwaysOnBottom();
            $scope.renderStage();
            $scope.updateLayersList();
            $scope.afterObjectModify();
            $scope.updateApp();
        };
        $scope.updateMaskLayer = function (selectedItem, stageId) {
            stageId = stageId ? stageId : $scope.currentStage;
            var _canvas = this.stages[stageId].canvas,
                maskId = [];
            _canvas.forEachObject(function (obj, index) {
                if (!!obj.get('isMask')) {
                    var id = obj.get('itemId'),
                        check = true;
                    if (angular.isDefined(selectedItem) && selectedItem.get('itemId') == id) {
                        check = false;
                    }
                    check && maskId.push(id);
                }
            });

            function getMaskedLayer(maskId) {
                var layer;
                _canvas.forEachObject(function (obj, index) {
                    if (!!obj.get('maskId')) {
                        if (obj.get('maskId') == maskId) {
                            layer = obj;
                        }
                    }
                });
                return layer;
            }

            _.each(maskId, function (id, index) {
                var maskLayerIndex = $scope.getLayerById(id),
                    maskLayer = _canvas.item(maskLayerIndex);
                var maskedLayer = getMaskedLayer(id);
                if (maskedLayer) {
                    var maskedLayerIndex = $scope.getLayerById(maskedLayer.get('itemId'));
                    if (maskLayerIndex < maskedLayerIndex) {
                        maskLayer.moveTo(maskedLayerIndex - 1);
                    } else {
                        maskLayer.moveTo(maskedLayerIndex);
                    }
                    maskLayer.set({selectable: false});
                } else {

                }
            });
        };
        $scope.updateLayersList = function () {
            $scope.updateMaskLayer();
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage['canvas'];
            $scope.originPDFs[$scope.currentStage] = [];
            _stage.layers = [];
            _canvas.forEachObject(function (obj, index) {
                var layerInfo = {
                    index: index,
                    visible: obj.get('visible'),
                    selectable: obj.get('selectable'),
                    forceLock: obj.get('forceLock'),
                    itemId: obj.get('itemId')
                };
                if (!obj.isAlwaysOnTop) {
                    if (!obj.get('isMask')) {
                        switch (obj.type) {
                            case 'i-text':
                            case 'text':
                            case 'textbox':
                            case 'curvedText':
                                layerInfo.type = 'text';
                                layerInfo.icon_class = 'text-fields';
                                layerInfo.text = obj.get('text');
                                layerInfo.editable = obj.get('editable');
                                if (angular.isDefined(obj.field_mapping)) {
                                    var field = _.filter($scope.settings.template_fields, {key: obj.field_mapping})[0];
                                    if (angular.isDefined(field)) {
                                        field.value = layerInfo.text;
                                    }
                                }
                                if (obj.lostChar == 1) layerInfo.lostChar = true;
                                break;
                            case 'image':
                            case 'custom-image':
                                var maskId = obj.get('maskId');
                                if (!maskId) {
                                    layerInfo.type = 'image';
                                    layerInfo.src = obj.getSvgSrc();
                                } else {
                                    layerInfo.type = 'image-layer';
                                    layerInfo.src = obj.getSvgSrc();
                                    layerInfo.maskId = maskId;
                                }
                                break;
                            case 'rect':
                            case 'triangle':
                            case 'line':
                            case 'polygon':
                            case 'circle':
                            case 'ellipse':
                            case 'roundedrectangle':
                            case 'diamond':
                            case 'star':
                            case 'rightparallelogram':
                            case 'leftparallelogram':
                            case 'outlinecircle':
                            case 'polyline':
                                var type = obj.type == 'rect' ? 'rectangle' : obj.type;
                                type = obj.type == 'polyline' ? 'line' : obj.type;
                                layerInfo.icon_class = 'layer-' + type;
                                layerInfo.type = type;
                                break;
                            case 'path-group':
                            case 'path':
                                layerInfo.icon_class = 'vector';
                                layerInfo.type = 'path';
                                break;
                            case 'group':
                                layerInfo.icon_class = 'layer-group';
                                layerInfo.type = 'group';
                                break;
                            default:
                                layerInfo.type = obj.type;
                                break;
                        }
                        layerInfo.layerName = typeof obj.layerName != 'undefined' ? obj.layerName : (angular.isDefined($scope.settings.nbdlangs[layerInfo.type]) ? $scope.settings.nbdlangs[layerInfo.type] : '');
                        _stage.layers.push(layerInfo);
                    }
                }

                if (angular.isDefined(obj.origin_pdf)) {
                    $scope.originPDFs[$scope.currentStage].push({
                        index: index,
                        origin_pdf: obj.origin_pdf,
                        top: obj.oCoords.tl.y / _stage.config.cheight * _stage.config.pHeight,
                        left: obj.oCoords.tl.x / _stage.config.cwidth * _stage.config.pWidth,
                        width: obj.width * obj.scaleX / _stage.config.cwidth * _stage.config.pWidth,
                        height: obj.height * obj.scaleY / _stage.config.cheight * _stage.config.pHeight
                    });
                }
            });
            $timeout(function () {
                /*Edit field option visual design*/
                if (typeof bdesign_customize_visual_option !== "undefined") {
                    $scope.stages[$scope.currentStage].layers.forEach(element => {
                        if (element.text.indexOf('T:') !== -1 || element.text.indexOf('M:') !== -1) {
                            if (element.text.indexOf('T:') !== -1) {
                                element.placeholder = "telephone";
                            }
                            if (element.text.indexOf('M:') !== -1) {
                                element.placeholder = "mobile";
                            }
                            element.text = element.text.slice(3, element.text.length);
                            element.text = element.text.replace(/\s/g, '');
                            if (isNaN(Number(element.text))) {
                                element.text_hide = "y";
                            }
                        }
                    })
                }
                jQuery('#tab-layer .tab-scroll').perfectScrollbar('update');
            });
        };
        $scope.changeLayerName = function (layerIndex, layerName) {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage['canvas'];
            if (_canvas.item(layerIndex)) {
                _canvas.item(layerIndex).set({layerName: layerName});
            }
        };
        $scope.setStackLayerAlwaysOnTop = function (maybeRender) {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            _canvas.forEachObject(function (obj) {
                if (obj.isAlwaysOnTop) {
                    obj.bringToFront();
                }
            });
            if (maybeRender) $scope.renderStage();
        };
        $scope.setStackLayerAlwaysOnBottom = function (maybeRender) {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            _canvas.forEachObject(function (obj) {
                if (obj.isBgImg) {
                    obj.sendToBack();
                }
            });
            if (maybeRender) $scope.renderStage();
        };
        $scope.setStackPosition = function (command, onLayer, _item) {
            var item = _item ? _item : $scope.stages[$scope.currentStage]['canvas'].getActiveObject();
            $scope.beforeObjectModify(item);
            switch (command) {
                case 'bring-front':
                    item.bringToFront();
                    $scope.setStackLayerAlwaysOnTop();
                    break;
                case 'bring-forward':
                    item.bringForward();
                    break;
                case 'send-backward':
                    item.sendBackwards();
                    break;
                case 'send-back':
                    item.sendToBack();
                    break;
                default:
                    var index = parseInt(command);
                    item.moveTo(index);
                    break;
            }
            $scope.setStackLayerAlwaysOnBottom();
            $scope.renderStage();
            $scope.afterObjectModify();
            if (!onLayer) $scope.updateLayersList();
        };
        $scope.changeBackground = function (color) {
            $scope.stages[$scope.currentStage].config.bgColor = color;
        };
        $scope.stageBgColorPicker = {
            status: false,
            currentColor: '#fff'
        };
        $scope.changeBackgroundCanvas = function (color, addColor = true) {
            /*nbdesigner adavanced*/
            if (typeof ctcs_nbd_js_config_design != "undefined") {
                var color = angular.isDefined(color) ? color : $scope.backgroundColor;
            }
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage.canvas;
            $scope.showDesignTab();
            _canvas.setBackgroundColor(color);
            if (addColor) {
                $scope.addColor(color);
            }
            _canvas.forEachObject(function (obj) {
                if (obj.isBgfImg) {
                    _canvas.remove(obj);
                    $scope.updateLayersList();
                }
            });
            _canvas.renderAll();
            $scope.afterObjectModify();
            $scope.setCurrentBackgoundGradientColor();
        };
        $scope.removeBackgroundCanvas = function () {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage.canvas;
            _canvas.backgroundColor = null;
            _canvas.forEachObject(function (obj) {
                if (obj.isBgImg) {
                    _canvas.remove(obj);
                }
            });
            _canvas.renderAll();
            $scope.afterObjectModify();
        };
        $scope.backgroundImgLitmit = 0;
        $scope.getBackgroundImgList = function () {
            $scope.resource.background = angular.isDefined($scope.settings.backgroundList) ? $scope.settings.backgroundList : [];
            $scope.backgroundImgLitmit = 24;
        };
        $scope.loadMoreBackgroundImgList = function () {
            if ($scope.backgroundImgLitmit < $scope.resource.background.length) $scope.backgroundImgLitmit += 24;
        };
        $scope.changeBackgroundImg = function (bgObj) {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage.canvas,
                scale = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
            _canvas.backgroundColor = null;
            _canvas.forEachObject(function (obj) {
                if (obj.isBgImg) {
                    _canvas.remove(obj);
                }
            });
            $scope.toggleStageLoading();
            var previewAvailable = NBDESIGNCONFIG.nbdesigner_enable_generate_photo_thumb == 'yes' && bgObj.previewAvailable;
            var url = previewAvailable ? bgObj.preview : bgObj.src;
            fabric.Image.fromURL(url, function (op) {
                var min_width = _canvas.width / scale,
                    min_height = _canvas.height / scale,
                    new_width = min_width,
                    new_height = min_height;
                if ((op.width / op.height) > (min_width / min_height)) {
                    new_height = min_height;
                    new_width = new_height / op.height * op.width;
                } else {
                    new_width = min_width;
                    new_height = new_width / op.width * op.height;
                }
                op.set({
                    fill: '#ff0000',
                    scaleX: new_width / op.width,
                    scaleY: new_height / op.height,
                    selectable: false,
                    isBgImg: 1
                });
                if (previewAvailable) {
                    op.set({
                        origin_url: bgObj.src,
                        origin_width: bgObj.width,
                        origin_height: bgObj.height,
                        width: bgObj.width,
                        height: bgObj.height,
                        scaleX: new_width / bgObj.width,
                        scaleY: new_height / bgObj.height
                    });
                }
                _canvas.add(op);
                $scope.toggleStageLoading();
            }, {crossOrigin: 'anonymous'});
        };
        $scope.setAsBackground = function () {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage.canvas,
                item = _canvas.getActiveObject(),
                scale = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio;
            if (item) {
                if (!!item.isBgImg) return;
                if (!!item.get('maskId')) {
                    return;
                }
                _canvas.forEachObject(function (obj) {
                    if (obj.isBgImg) {
                        _canvas.remove(obj);
                    }
                });
                var min_width = _canvas.width / scale,
                    min_height = _canvas.height / scale,
                    new_width = min_width,
                    new_height = min_height;
                if ((item.width / item.height) > (min_width / min_height)) {
                    new_height = min_height;
                    new_width = new_height / item.height * item.width;
                } else {
                    new_width = min_width;
                    new_height = new_width / item.width * item.height;
                }
                item.set({
                    scaleX: new_width / item.width,
                    scaleY: new_height / item.height,
                    selectable: true,
                    isBgImg: 1
                });
                _canvas.viewportCenterObject(item);
                item.sendToBack();
                $scope.deactiveAllLayer();
                _canvas.renderAll();
                $scope.afterObjectModify();
            }
        };
        $scope.currentCombinationColor = 0;
        $scope.currentForegroundColor = 0;
        $scope.currentBackgroundColor = 0;
        $scope._changeBackgroundCanvas = function ($index) {
            var color = $scope.settings.nbes_settings.background_colors.codes[$index];
            $scope.currentBackgroundColor = $index;
            $scope.changeBackgroundCanvas(color);
        };
        $scope.selectCombinationColor = function ($index) {
            var bgColor = $scope.settings.nbes_settings.combination_colors.bg_codes[$index],
                fgColor = $scope.settings.nbes_settings.combination_colors.fg_codes[$index];
            $scope.changeBackgroundCanvas(bgColor);
            $scope.changeFillAllLayers(fgColor, true);
            $scope.__colorPalette = [fgColor];
            $scope.stages[$scope.currentStage].states.text.fill = fgColor;
            $scope.currentCombinationColor = $index;
        };
        $scope.changeFillAllLayers = function (color, needRender) {
            _.each($scope.stages, function (stage, index) {
                var canvas = stage.canvas;
                canvas.forEachObject(function (obj) {
                    switch (obj.type) {
                        case 'i-text':
                        case 'text':
                        case 'textbox':
                        case 'curvedText':
                            obj.set({fill: color});
                            break;
                        case 'rect':
                        case 'triangle':
                        case 'line':
                        case 'polyline':
                        case 'polygon':
                        case 'circle':
                        case 'ellipse':
                            _.each(obj._objects, function (path, index) {
                                if (path.get('fill') != '') {
                                    path.set({fill: color});
                                }
                                if (path.get('stroke') != null) {
                                    path.set({stroke: color});
                                }
                            });
                            break;
                    }
                    if (obj.get('fill') != '') {
                        obj.set({fill: color});
                    }
                    if (obj.get('stroke') != null) {
                        obj.set({stroke: color});
                    }
                });
                if (needRender) canvas.renderAll();
            });
        };
        $scope.forceForeground = function (item) {
            if (angular.isDefined($scope.settings.nbes_enable_settings) && angular.isDefined($scope.settings.nbes_settings)) {
                var foreFill = false, color = '';
                if ($scope.settings.nbes_enable_settings.combination == 1 && angular.isDefined($scope.settings.nbes_settings.combination_colors) && $scope.settings.nbes_settings.combination_colors.fg_codes.length > 0) {
                    foreFill = true;
                    color = $scope.settings.nbes_settings.combination_colors.fg_codes[$scope.currentCombinationColor];
                } else if ($scope.settings.nbes_enable_settings.foreground == 1 && $scope.settings.nbes_settings.force_fg == 1 && angular.isDefined($scope.settings.nbes_settings.foreground_colors)
                    && $scope.settings.nbes_settings.foreground_colors.codes.length > 0) {
                    foreFill = true;
                    color = $scope.settings.nbes_settings.foreground_colors.codes[$scope.currentForegroundColor];
                }
                if (foreFill) {
                    switch (item.type) {
                        case 'i-text':
                        case 'text':
                        case 'textbox':
                        case 'curvedText':
                            item.set({fill: color});
                            break;
                        case 'rect':
                        case 'triangle':
                        case 'line':
                        case 'polygon':
                        case 'circle':
                        case 'ellipse':
                            _.each(item._objects, function (path, index) {
                                if (path.get('fill') != '') {
                                    path.set({fill: color});
                                }
                                if (path.get('stroke') != null) {
                                    path.set({stroke: color});
                                }
                            });
                            break;
                    }
                    if (item.get('fill') != '') {
                        item.set({fill: color});
                    }
                    if (item.get('stroke') != null) {
                        item.set({stroke: color});
                    }
                }
            }
        };
        $scope.onColorChanged = function (color) {
            this.changeFill(color);
        }

        $scope.onZoomRangeChanged = function () {
            if (typeof $scope.stages[$scope.currentStage].states.currentScaleIndex === 'undefined') {
                return;
            }
            const zoom = Number($scope.zoomRangeValue) / 50;
            $scope.zoomStage(zoom);
        }
        $scope.changeFill = function (color) {
            var _stage = $scope.stages[$scope.currentStage],
                _canvas = _stage.canvas;
            if (angular.equals({}, _canvas)) return;
            const activeItem = _canvas.getActiveObject();
            if (activeItem.type === 'activeSelection') {
                const groupsInActiveSelection = activeItem.getObjects()
                    .filter((o) => o.type === 'group');
                if (groupsInActiveSelection.length) {
                    groupsInActiveSelection[0].getObjects();
                }
            }
            var items = _canvas.getActiveObjects();
            items.forEach((item) => {
                $scope.beforeObjectModify(item);
                if (!_stage.states.isPath) {
                    _stage.states.text.fill = color;
                    if (item.type === 'textbox' && item.isInGroup) {
                        item.set({fill: color});
                        $scope.renderStage();
                        $scope.afterObjectModify();
                        return;
                    } else if (item.selectionStart != item.selectionEnd) {
                        if (item.getSelectionStyles()[0] && item.getSelectionStyles()[0].fontWeight == 'bold' || item.getSelectionStyles()[0] && item.getSelectionStyles()[0].fontStyle == 'italic') {
                            item.setSelectionStyles({
                                fill: color,
                                fontWeight: item.getSelectionStyles()[0].fontWeight,
                                fontStyle: item.getSelectionStyles()[0].fontStyle
                            });
                            $scope.setSelectionStyle(item);
                            return;
                        }
                        item.setSelectionStyles({fill: color, fontWeight: 'normal', fontStyle: 'normal'});
                        $scope.setSelectionStyle(item);
                        return;
                    } else if (item.selectionStart === item.selectionEnd) {
                        item.removeStyle && item.removeStyle('fill');
                    }
                    if (item.type !== 'curvedText') {
                        item.removeStyleFromTo && item.removeStyleFromTo();
                    }
                    item.set({fill: color});
                    if ($scope.stages[$scope.currentStage].states.isShape || $scope.stages[$scope.currentStage].states.isGrouppedSelection) {
                        _stage.states.svg.groupPath[_stage.states.svg.currentPath].color = color;
                    }
                } else {
                    item.set({dirty: true});
                    _.each(_stage.states.svg.groupPath[_stage.states.svg.currentPath].index, function (path_index) {
                        if (path_index == -2) {
                            item.set({fill: color});
                        } else {
                            if (path_index > -1) {
                                item._objects[path_index].set({fill: color});
                            } else {
                                item.set({stroke: color});
                            }
                        }
                    });
                    _stage.states.svg.groupPath[_stage.states.svg.currentPath].color = color;
                }
                if (angular.isDefined($scope.settings.nbes_enable_settings) && $scope.settings.nbes_enable_settings.combination != 1
                    && $scope.settings.nbes_enable_settings.foreground == 1 && angular.isDefined($scope.settings.nbes_settings) && $scope.settings.nbes_settings.force_fg == 1
                    && angular.isDefined($scope.settings.nbes_settings.foreground_colors) && $scope.settings.nbes_settings.foreground_colors.codes.length > 0) {
                    $scope.changeFillAllLayers(color, false);
                    var index = $scope.settings.nbes_settings.foreground_colors.codes.indexOf(color);
                    $scope.currentForegroundColor = index > -1 ? index : 0;
                }
                $scope.renderStage();
                $scope.afterObjectModify();
            });
        };
        $scope.initEyeDropper2 = function ($event, global) {
            if (!$scope.eyeDropper) {
                jQuery('.nbd-color-palette').removeClass('show');
                jQuery('.nbd-show-color-palette').removeClass('nbd-show');
                return;
            }
            $scope.eyeDropper.open()
                .then(({sRGBHex: color}) => {
                    if (global) {
                        $scope.globalPicker.color = color;
                        $scope.addColor($scope.globalPicker.color);
                        $scope.changeFill($scope.globalPicker.color);
                    } else {
                        $scope.currentColor = color;
                        $scope.addColor();
                        $scope.changeFill(color);
                    }
                }).catch((e) => e);
            jQuery('.nbd-color-palette').removeClass('show');
            jQuery('.nbd-show-color-palette').removeClass('nbd-show');
        };
        /* Text */
        $scope.addText = function (content, type, additionalObj) {
            /*advanced*/
            if (typeof kvlc_js_cusom != "undefined") {
                if (appConfig.isVisual) {
                    let _canvas = $scope.stages[$scope.currentStage]['canvas'];
                    let obj = _canvas.getActiveObject();
                    if (obj) {
                        obj.text = content;
                        _canvas.renderAll();
                        return;
                    }
                }
            }
            content = angular.isDefined(content) ? content : $scope.settings.nbdesigner_default_text;
            type = angular.isUndefined(type) ? 'bodytext' : type;
            var textType = 'Textbox',
                fontSize = 16,
                fontName = NBDESIGNCONFIG.default_font.alias;
            var state = $scope.stages[$scope.currentStage].states;
            fontName = 'Poppins';

            switch (type) {
                case 'heading':
                    textType = 'Textbox';
                    if (typeof checkBox != "undefined") {
                        textType = 'IText';
                    }
                    fontSize = 42;
                    /*advanced*/
                    if (typeof adc_check_app_modern != "undefined") {
                        textType = '';
                        fontSize = 62;
                    }
                    break;
                case 'subheading':
                    textType = 'Textbox';
                    if (typeof checkBox != "undefined") {
                        textType = 'IText';
                    }
                    fontSize = 36;
                    /*advanced*/
                    if (typeof adc_check_app_modern != "undefined") {
                        textType = '';
                        fontSize = 26;
                    }
                    break;
                case 'paragraph':
                    textType = 'Textbox';
                    if (typeof checkBox != "undefined") {
                        textType = 'IText';
                    }
                    fontSize = 26;
                    /*advanced*/
                    if (typeof adc_check_app_modern != "undefined") {
                        textType = '';
                        fontSize = 26;
                    }
                    break;
            }
            ;
            var textObj = {
                fontFamily: fontName,
                radius: 50,
                objectCaching: false,
                fontSize: fontSize,
                ptFontSize: (fontSize / state.ratioConvertFont).toFixed(2)
            };
            /* NBDesigner Advanced */
            if (typeof checkBox != "undefined") {
                textObj.checkTexBox = false;
                textObj.cellValue = false;
                textObj.temporary = '';
                textObj.lockFontEdit = false;
            }
            if (additionalObj) {
                angular.extend(textObj, additionalObj);
            }
            ;

            function addText() {
                $scope.stages[$scope.currentStage]['canvas'].add(new FabricWindow[textType](content, textObj));
            };
            var font = new FontFaceObserver(fontName);
            font.load(content).then(function () {
                fabric.util.clearFabricFontCache(fontName);
                var container = document.createElement('span'),
                    scale = state.scaleRange[state.currentScaleIndex].ratio;
                container.innerHTML = content;
                container.style.cssText = [
                    'position:absolute',
                    'width:auto',
                    'font-size: ' + fontSize + 'px',
                    'font-family: ' + fontName,
                    'left:-99999px'
                ].join(' !important;');
                document.body.appendChild(container);
                var textWidth = container.clientWidth + 2;
                document.body.removeChild(container);
                var canvasWidth = $scope.stages[$scope.currentStage]['canvas'].width;
                if ((textWidth * scale) > (canvasWidth * 0.8)) {
                    textObj.width = canvasWidth * 0.8 / scale;
                    textObj.fontSize = canvasWidth * 0.8 / (textWidth * scale) * fontSize;
                    textObj.ptFontSize = (textObj.fontSize / state.ratioConvertFont).toFixed(2);
                } else {
                    textObj.width = textWidth / scale;
                }
                $timeout(function () {
                    addText();
                }, 100);
            }, function () {
                console.log('Fail to load font: ' + fontName);
                addText();
            });
        };
        // add text box
        $scope.addTextBox = function () {
            var text = new fabric.Textbox('Text Box\nLine 1\nLine 2\nLine 3', {
                width: 150,
                fontFamily: 'Poppins',
                height: 400,
                top: 50,
                left: 5,
                fontSize: 26,
                textAlign: 'center',
                fixedWidth: 150,
                breakWords: true,
            });
            $scope.stages[$scope.currentStage]['canvas'].add(text);
        };
        // add vertical text
        $scope.addVerticalText = function () {
            var text = new fabric.Textbox('V\nE\nR\nT\nI\nC\nA\nL', {
                width: 150,
                fontFamily: 'Poppins',
                height: 400,
                top: 50,
                left: 5,
                fontSize: 26,
                textAlign: 'center',
                fixedWidth: 150,
                breakWords: true,
            });
            $scope.stages[$scope.currentStage]['canvas'].add(text);
        };
        // add underline
        $scope.addUnderline = function () {
            var text = new fabric.Textbox('Im an underlined text', {
                width: 150,
                fontFamily: NBDESIGNCONFIG.default_font.alias,
                fontStyle: underline,
                fontSize: 26,
                textAlign: 'center',
                breakWords: true,
            });
            $scope.stages[$scope.currentStage]['canvas'].add(text);
        };
        // add Bullet List
        $scope.addBulletList = function () {
            fontSize = 24,
                text = `Line 1\nLine 2`,
                t0 = new fabric.Textbox(text, {
                    name: "list",
                    fontFamily: "sans-serif",
                    lineHeight: 1.40,
                    left: 75,
                    top: 50,
                    width: 100,
                    objectCaching: false,
                    isWrapping: false,
                    listType: "bullet",
                    listBullet: "✱",
                    listCounter: 0,
                }),
                renderTextLine = function (method, ctx, line, left, top, lineIndex) {
                    const style0 = this.getCompleteStyleDeclaration(lineIndex, 0),
                        bullet = this.listType === "bullet"
                            ? [this.listBullet]
                            : [this.listCounter + 1 + "."],
                        bulletLeft = left - style0.fontSize - 2;

                    if (line.length) {
                        if (!this.isWrapping) {
                            // render the bullet
                            this._renderChars(method, ctx, bullet, bulletLeft, top, lineIndex);
                            this.isWrapping = !this.isEndOfWrapping(lineIndex);
                            if (!this.isWrapping) this.listCounter++;
                        } else if (this.isEndOfWrapping(lineIndex)) {
                            this.isWrapping = false;
                            this.listCounter++;
                        }
                    }
                    if (lineIndex === this.textLines.length - 1) {
                        this.isWrapping = false;
                        this.listCounter = 0;
                    }
                    // render the text line
                    this._renderChars(method, ctx, line, left, top, lineIndex);
                    this._renderTextLine = renderTextLine;
                };


            $scope.stages[$scope.currentStage]['canvas'].add(t0);
        };
        $scope.addCurvedText = function (content) {
            var state = $scope.stages[$scope.currentStage].states;

            function addText() {
                var rtl = false;
                if (NBDESIGNCONFIG.lang_rtl == 'rtl') {
                    rtl = true;
                    content = content.split('').reverse().join('');
                }
                $scope.stages[$scope.currentStage]['canvas'].add(new fabric.CurvedText(content, {
                    radius: 100,
                    rtl: rtl,
                    top: 100,
                    left: 100,
                    fontFamily: fontName,
                    fontSize: 20,
                    ptFontSize: 20 / state.ratioConvertFont
                }));
            };
            var fontName = NBDESIGNCONFIG.default_font.alias,
                font = new FontFaceObserver(fontName);
            font.load($scope.settings.subsets[NBDESIGNCONFIG.default_font.subset]['preview_text']).then(function () {
                fabric.util.clearFabricFontCache(fontName);
                addText();
            }, function () {
                console.log('Fail to load font: ' + fontName);
                addText();
            });
        };
        /*Edit field option visual design*/
        if (typeof bdesign_customize_visual_option != "undefined") {
            function getIndex() {
                return new Promise((resolve, reject) => {
                    let layers = $scope.stages[$scope.currentStage].canvas.getObjects();
                    let index_title_vl = -1;
                    let index_title = -1;
                    let left_m = 0;
                    layers.forEach((element, index) => {
                        if (angular.isDefined(element.name) && element.name == "title") {
                            index_title = index;
                        }
                        if (angular.isDefined(element.name) && element.name == "title_vl") {
                            index_title_vl = index;
                            left_m = element.left;
                        }
                    })
                    let rs = {
                        index_title_vl: index_title_vl,
                        index_title: index_title,
                        left_m: left_m,
                    }
                    resolve(rs)
                });
            }

            $scope.setleftLayer = function () {
                var fGetIndex = getIndex();
                fGetIndex.then((resolve) => {
                    var layers = $scope.stages[$scope.currentStage].canvas.getObjects();
                    console.log(layers[resolve.index_title]);
                    console.log(layers[resolve.index_title_vl]);
                    setTimeout(function () {
                        console.log(layers[resolve.index_title].aCoords.br.x)
                        console.log(layers[resolve.index_title_vl].aCoords.bl.x)
                        console.log(layers[resolve.index_title_vl].left);
                        if (layers[resolve.index_title_vl].left != layers[resolve.index_title_vl].aCoords.bl.x) {
                            layers[resolve.index_title_vl].aCoords.bl.x = layers[resolve.index_title_vl].left;
                        }
                        if (layers[resolve.index_title].aCoords.br.x >= layers[resolve.index_title_vl].aCoords.bl.x) {
                            layers[resolve.index_title_vl].left = resolve.left_m + 10;
                        }
                        $scope.stages[$scope.currentStage]['canvas'].requestRenderAll();
                    }, 1000);

                })
            }
        }
        $scope.setLayerAttribute = function (type, value, item_index, layer_index) {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            if (!appConfig.ready) return;
            var item = angular.isDefined(item_index) ? _canvas.item(item_index) : _canvas.getActiveObject();
            if (!item) return;
            if (type == 'selectable' && !$scope.isTemplateMode && angular.isDefined(item.forceLock) && item.forceLock) return;
            $scope.beforeObjectModify(item);
            var itemType = item.get('type');
            if ((itemType == 'i-text' || itemType == 'textbox') && type == 'forceLock') {
                value == true ? item.set({editable: false}) : item.set({editable: true});
            }
            ;
            if (type == 'forceLock') {
                value == true ? item.set({selectable: false}) : item.set({selectable: true});
            }
            ;
            var ob = {};
            ob[type] = value;
            if (type == 'angle') {
                item.rotate(value);
            } else {
                item.set(ob);
            }
            ;
            var ob = {};
            ob[type] = value;
            /*Edit field option visual design*/
            if (typeof bdesign_customize_visual_option != "undefined") {
                if (typeof value != "boolean") {
                    var layer_now = $scope.stages[$scope.currentStage].canvas.getObjects();
                    if (layer_now[layer_index].name == "telephone" || layer_now[layer_index].name == "mobile") {
                        if (!Number.isInteger(parseInt(value)) && value.trim() !== '') {
                            alert("Please only enter number type!!");
                            return;
                        }
                        var ob_name = layer_now[layer_index].text.slice(0, 3);
                        var index_mobi = 0;
                        var index_tele = 0;
                        var margin_left_tele = 0;
                        var margin_left_mobi = 0;
                        layer_now.forEach((element, index) => {
                            if (angular.isDefined(element.name) && element.name == "telephone") {
                                margin_left_tele = element.margin_left_tele;
                                index_tele = index;
                            }
                            if (angular.isDefined(element.name) && element.name == "mobile") {
                                margin_left_mobi = element.margin_left_mobi;
                                index_mobi = index;
                            }
                        });
                        if (value.trim() == '') {
                            if (layer_now[layer_index].name == "telephone") {
                                layer_now[index_mobi].left = margin_left_tele;
                            }
                        } else {
                            if (layer_now[layer_index].name == "mobile") {
                                var title = "M:";
                                if (layer_now[layer_index].left == layer_now[index_tele].left && layer_now[index_tele].text != '') {
                                    layer_now[layer_index].left = layer_now[index_mobi].margin_left_mobi;
                                }
                                if (layer_now[index_tele].text != '') {
                                    var title = "| M:";
                                }
                            }
                            if (layer_now[layer_index].name == "telephone") {
                                var title = "T:";
                                if (layer_now[index_mobi].text != '') {
                                    layer_now[index_mobi].left = layer_now[index_mobi].margin_left_mobi;
                                    if (layer_now[index_mobi].text.indexOf("|") === -1) {
                                        layer_now[index_mobi].text = "| " + layer_now[index_mobi].text;
                                    }
                                }
                            }
                            var rs = "";
                            var ktval = Number.isInteger(parseInt(value));
                            if (ktval == true) {
                                var val = value.split("");
                                for (i = 2; i <= val.length; i += 3) {
                                    val.splice(i, 0, " ");
                                }
                                val = val.join("");
                                rs = title + " " + val.toString();
                                ob[type] = rs;
                            }
                        }
                    }
                    if (layer_now[layer_index].name == "title" || layer_now[layer_index].name == "title_vl") {
                        var index_title = 0;
                        var index_title_vl = 0;
                        var margin_left_title = 0;
                        var margin_left_title_vl = 0;
                        layer_now.forEach((element, index) => {
                            if (angular.isDefined(element.name) && element.name == "title") {
                                margin_left_title = element.margin_left_title;
                                index_title = index;
                            }
                            if (angular.isDefined(element.name) && element.name == "title_vl") {
                                margin_left_title_vl = element.margin_left_title_vl;
                                index_title_vl = index;
                            }
                        });
                        if (value.trim() == '') {
                            if (layer_now[layer_index].name == "title") {
                                layer_now[index_title_vl].left = margin_left_title;
                                layer_now[index_title_vl].text = layer_now[index_title_vl].text.replace("| ", "");
                            }
                        } else {
                            if (layer_now[layer_index].name == "title_vl") {
                                ob[type] = value;
                                if (layer_now[index_title].text != '') {
                                    ob[type] = "| " + value;
                                }
                                if (layer_now[layer_index].left == layer_now[index_title].left && layer_now[index_title].text != '') {
                                    layer_now[layer_index].left = layer_now[index_title_vl].margin_left_title_vl;
                                }
                            }
                            if (layer_now[layer_index].name == "title") {
                                if (layer_now[index_title_vl].text != '' && layer_now[index_title_vl].left <= layer_now[index_title_vl].margin_left_title_vl) {
                                    layer_now[index_title_vl].left = layer_now[index_title_vl].margin_left_title_vl;
                                }
                                if (layer_now[index_title_vl].text != '') {
                                    layer_now[index_title_vl].text = "| " + layer_now[index_title_vl].text.replace("| ", "");
                                }
                                setTimeout(function () {
                                    $scope.setleftLayer();
                                }, 1000);
                            }
                        }
                    }
                }
            }
            item.set(ob);
            switch (type) {
                case 'visible':
                case 'selectable':
                    $scope.deactiveAllLayer();
                    break;
                case 'lockScalingX':
                    var controlVisible = itemType == 'textbox' ? [] : ['tl', 'tr', 'bl', 'br'];
                    controlVisible.forEach(function (key) {
                        item.setControlVisible(key, !value);
                    });
                    break;
                case 'lockScalingY':
                    var controlVisible = itemType == 'textbox' ? [] : ['tl', 'tr', 'bl', 'br'];
                    controlVisible.forEach(function (key) {
                        item.setControlVisible(key, !value);
                    });
                    break;
                case 'lockRotation':
                    item.setControlVisible('mtr', !value);
                    break;
            }
            /*Edit field option visual design*/
            if (typeof bdesign_customize_visual_option !== "undefined") {
                switch (type) {
                    case 'hideFromEditor':
                        $scope.deactiveAllLayer();
                        break;
                    case 'hidePhoneEmpty':
                        hideIfEmpty("telephone", item);
                        break;
                    case 'hideMobileEmpty':
                        hideIfEmpty("mobile", item);
                        break;
                }

            }
            $scope.renderStage();
            if (angular.isDefined(item_index)) {
                $scope.stages[$scope.currentStage].layers[layer_index][type] = value;
            } else {
                $scope.stages[$scope.currentStage].states[type] = value;
            }
            if (type != 'text') {
                $scope.updateLayersList();
            }
            if (['i-text', 'text', 'textbox', 'curvedText'].indexOf(itemType) > -1) {
                $scope.normalizeText(item);
                if ($scope.settings.nbdesigner_enable_text_check_lang == 'yes') $scope.checkCharacter(item);
            }
            $scope.afterObjectModify();
            $scope.updateApp();
        };
        $scope.increaseFontSize = function () {
            $scope.stages[$scope.currentStage].states.text.ptFontSize = Number($scope.stages[$scope.currentStage].states.text.ptFontSize) + 2;
            $scope.setTextAttribute('fontSize', $scope.stages[$scope.currentStage].states.text.ptFontSize);
        }
        $scope.decreaseFontSize = function () {
            $scope.stages[$scope.currentStage].states.text.ptFontSize = Number($scope.stages[$scope.currentStage].states.text.ptFontSize) - 2;
            $scope.setTextAttribute('fontSize', $scope.stages[$scope.currentStage].states.text.ptFontSize);
        };
        $scope.increaseFontSizeMulti = function () {
            const _canvas = $scope.getCurrentStageCanvas();
            const objects = _canvas.getActiveObjects();
            if (objects.length > 1) {
                objects.forEach((o) => {
                    $scope.stages[$scope.currentStage].states.text.ptFontSize = Number($scope.stages[$scope.currentStage].states.text.ptFontSize) + 2;
                    $scope.setTextAttribute('fontSize', Number(o.fontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont) + 2, o);
                });
            } else if (objects.length) {
                $scope.stages[$scope.currentStage].states.text.ptFontSize = Number($scope.stages[$scope.currentStage].states.text.ptFontSize) + 2;
                $scope.setTextAttribute('fontSize', $scope.stages[$scope.currentStage].states.text.ptFontSize);
            }
        }
        $scope.decreaseFontSizeMulti = function () {
            const _canvas = $scope.getCurrentStageCanvas();
            const objects = _canvas.getActiveObjects();
            if (objects.length > 1) {
                objects.forEach((o) => {
                    $scope.stages[$scope.currentStage].states.text.ptFontSize = Number($scope.stages[$scope.currentStage].states.text.ptFontSize) - 2;
                    $scope.setTextAttribute('fontSize', Number(o.fontSize / $scope.stages[$scope.currentStage].states.ratioConvertFont) - 2, o);
                });
            } else if (objects.length) {
                $scope.stages[$scope.currentStage].states.text.ptFontSize = Number($scope.stages[$scope.currentStage].states.text.ptFontSize) - 2;
                $scope.setTextAttribute('fontSize', $scope.stages[$scope.currentStage].states.text.ptFontSize);
            }
        };
        $scope.applyTextPropertyToGroup = function (property, value) {
            const _canvas = $scope.getCurrentStageCanvas();
            if (!_canvas || angular.equals(_canvas, {})) {
                return;
            }
            const objects = _canvas.getActiveObjects();
            if (!objects || !objects.length) {
                return;
            }
            if (objects.length > 1) {
                objects.forEach((o) => {
                    $scope.setTextAttribute(property, value, o);
                });
            } else if (objects.length) {
                $scope.setTextAttribute(property, value, objects[0]);
            }
            if (property === 'fontFamily') {
                $scope.stages[$scope.currentStage].states.isTextGroupBoldDisabled = objects.some((o) => {
                    const font = $scope.getFontInfo(o.fontFamily);
                    return !(font.file.b && (o.fontStyle != 'italic' || (o.fontStyle == 'italic' && font.file.bi)));
                });
                $scope.stages[$scope.currentStage].states.isTextGroupItalicDisabled = objects.some((o) => {
                    const font = $scope.getFontInfo(o.fontFamily);
                    return !(font.file.i && (o.fontWeight != 'bold' || (o.fontWeight == 'bold' && font.file.bi)));
                });
            }
        }
        $scope.convertToBulletList = function () {
            const styles = ['\u25CF'];
            const _stage = $scope.stages[$scope.currentStage];
            const _canvas = _stage.canvas;
            const item = _canvas.getActiveObject();
            const text = _stage.states.text['text'];
            const textArray = text.split('\n')
            const tempStr = [];
            textArray.forEach((text, i) => {
                if (item.isList && styles.includes(text.substr(0, 1))) {
                    tempStr.push(text.replace(text.substr(0, 2), ''));
                } else if (!item.isList) {
                    tempStr.push('\u25CF' + ' ' + text);
                } else {
                    tempStr.push(text);
                }
            });
            item.set({text: tempStr.join('\n')});
            item.set({isList: !item.isList});
            _stage.states.text['text'] = tempStr.join('\n');
            $scope.stages[$scope.currentStage].canvas.renderAll();
        }
        /*nbdesigner adavanced*/
        if (typeof hvc_app_modern_js != "undefined") {
            if (type == 'scaleM') {
                var sm = item.get('scaleSM');
                var last = (typeof sm !== "undefined" ? sm : 10);
                if (last < value) {
                    $scope.scaleLayer('+', value);
                }
                if (last > value) {
                    $scope.scaleLayer('-', value);
                }
                var ob = {};
                ob['scaleSM'] = value;
                if (typeof sm !== "undefined") {
                } else {
                    ob['scaleXVL'] = item.get('scaleX');
                    ob['scaleYVL'] = item.get('scaleY');
                    ob['leftVL'] = item.get('left');
                    ob['topVL'] = item.get('top');
                }
                item.set(ob);
            }
        }
        ;

        /*advanced*/
        if (typeof add_change_fonts_colors != "undefined" || typeof udc_nbd_js_config != "undefined") {
            $scope.setSelectionStyle = function (item) {
                var _stage = $scope.stages[$scope.currentStage],
                    _states = _stage.states,
                    _canvas = _stage['canvas'];
                item.initDimensions();
                item.setCoords();
                $scope.afterObjectModify();
                angular.forEach(item.getSelectionStyles()[0], function (ele, key) {
                    _stage.states.text[key] = ele;
                    if (key == 'fontSize') {
                        _stage.states.text.ptFontSize = (ele / _stage.states.ratioConvertFont).toFixed(2);
                    }
                    if (key == 'fontFamily') {
                        _stage.states.text.font.alias = ele;
                        _stage.states.text.font.name = ele;
                    }
                });
                $scope.renderStage();
            };
        }
        $scope.setTextAttribute = function (type, value, itemToApply) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = itemToApply || _canvas.getActiveObject();
            if (item && item.isImageCropper) {
                const imageIndex = $scope.getLayerById(item.imageId);
                item = _canvas.item(imageIndex);
            }
            var items = _canvas.getActiveObjects();
            // custom change fonts letter
            if (typeof add_change_fonts_colors != "undefined" || typeof udc_nbd_js_config != "undefined") {
                var aliasd = $scope.getFontInfo(value);

                function isEmptyObject(obj) {
                    return JSON.stringify(obj) === '{}';
                }

                function setFontSelectionStyle(item) {
                    var font = new FontFaceObserver(_states.text.fontFamily, {
                        weight: item.getSelectionStyles()[0].fontWeight,
                        style: item.getSelectionStyles()[0].fontStyle
                    });
                    font.load(item.get('text')).then(function () {
                        fabric.util.clearFabricFontCache(_states.text.fontFamily);
                        $timeout(function () {
                            item.initDimensions();
                            item.setCoords();
                            angular.forEach(item.getSelectionStyles()[0], function (ele, key) {
                                _stage.states.text[key] = ele;
                            });
                            $scope.afterObjectModify();
                            $scope.renderStage();
                        });
                    }, function () {
                        item.setCoords();
                        $scope.renderStage();
                    });
                }

                if (item.selectionStart != item.selectionEnd && NBDESIGNCONFIG.checktopchange == 'yes') {
                    switch (type) {
                        case 'fontFamily':
                            item.setSelectionStyles({
                                fontFamily: aliasd.alias,
                                fontWeight: 'normal',
                                fontStyle: 'normal'
                            });
                            $scope.setSelectionStyle(item);
                            return;
                        case 'fontWeight':
                            if (item.getSelectionStyles()[0].fontWeight == 'normal' && item.getSelectionStyles()[0].fontStyle == 'italic') {
                                item.setSelectionStyles({fontWeight: 'bold', fontStyle: 'italic'});
                                setFontSelectionStyle(item);
                                return;
                            }
                            ;
                            if (isEmptyObject(item.getSelectionStyles()[0]) || item.getSelectionStyles()[0].fontWeight == 'normal') {
                                item.setSelectionStyles({fontWeight: 'bold', fontStyle: 'normal'});
                                setFontSelectionStyle(item);
                                return;
                            }
                            ;
                            if (item.getSelectionStyles()[0].fontWeight == 'bold' && item.getSelectionStyles()[0].fontStyle == 'italic') {
                                item.setSelectionStyles({fontWeight: 'normal', fontStyle: 'italic'});
                                setFontSelectionStyle(item);
                                return;
                            }
                            ;
                            item.setSelectionStyles({fontWeight: 'normal', fontStyle: 'normal'});
                            setFontSelectionStyle(item);
                            return;
                        case 'fontStyle':
                            if (item.getSelectionStyles()[0].fontStyle == 'normal' && item.getSelectionStyles()[0].fontWeight == 'bold') {
                                item.setSelectionStyles({fontWeight: 'bold', fontStyle: 'italic'});
                                setFontSelectionStyle(item);
                                return;
                            }
                            if (isEmptyObject(item.getSelectionStyles()[0]) || item.getSelectionStyles()[0].fontStyle == 'normal') {
                                item.setSelectionStyles({fontStyle: 'italic', fontWeight: 'normal'});
                                setFontSelectionStyle(item);
                                return;
                            }
                            if (item.getSelectionStyles()[0].fontWeight == 'bold' && item.getSelectionStyles()[0].fontStyle == 'italic') {
                                item.setSelectionStyles({fontWeight: 'bold', fontStyle: 'normal'});
                                setFontSelectionStyle(item);
                                return;
                            }
                            item.setSelectionStyles({fontWeight: 'normal', fontStyle: 'normal'});
                            setFontSelectionStyle(item);
                            return;
                        case 'strokeWidth':
                            item.setSelectionStyles({strokeWidth: value});
                            setFontSelectionStyle(item);
                            return;
                        case 'stroke':
                            item.setSelectionStyles({stroke: value});
                            setFontSelectionStyle(item);
                            return;
                        case 'textBackgroundColor':
                            item.setSelectionStyles({textBackgroundColor: value});
                            setFontSelectionStyle(item);
                            return;
                        case 'fontSize':
                            item.setSelectionStyles({
                                fontSize: value * _states.ratioConvertFont,
                                fontWeight: 'normal',
                                fontStyle: 'normal'
                            });
                            $scope.setSelectionStyle(item);
                            return;
                    }
                } else {
                    switch (type) {
                        case 'fontFamily':
                            item.removeStyle('fontFamily');
                            $scope.stages[$scope.currentStage].states.text['hasMultipleFonts'] = false;
                            break;
                        case 'fontSize':
                            item.removeStyle('fontSize');
                            break;
                        default:
                            break;
                    }
                }
            }
            if (!item || !items) return;
            $scope.beforeObjectModify(item);
            var ob = {};
            ob[type] = value;
            item.set(ob);
            /* item.set({[type]: value}); */
            if (type == 'fontSize') {
                var minSize = arrayMin($scope.listFontSizeInPt),
                    maxSize = arrayMax($scope.listFontSizeInPt);
                if ($scope.forceMinSize && minSize > value) value = minSize;
                if ($scope.forceMaxSize && maxSize < value) value = maxSize;
                item.set({'ptFontSize': value, 'fontSize': value * _states.ratioConvertFont});
                _states.text.ptFontSize = value;
                $scope.updateTextPxFontSize(item);
            }
            switch (type) {
// 			case 'underline':
// 				const isUnderlined = Boolean(item.underline);
//                 item.set({underline: !isUnderlined});
//                 break;
// 			case 'strikethrough':
// 				const isLinethrough = Boolean(item.linethrough);
//                 item.set({linethrough: !isLinethrough});
//                 break;
// 			case 'overline':
// 				const isOverlined = Boolean(item.overline);
//                 item.set({overline: !isOverlined});
//                 break;
                case 'is_uppercase':
                    value ? item.set({'text': item.get('text').toUpperCase()}) : item.set({'text': item.get('text').toLowerCase()});
                    break;
                case 'fontFamily':
                    if (!_.filter(_states.usedFonts, ['alias', value]).length) {
                        _states.usedFonts.push($scope.getFontInfo(value));
                    }
                    _states.text.font = $scope.getFontInfo(value);
                    if (!_states.text.font.file.b) {
                        item.set({fontWeight: 'normal'});
                        _states.text.fontWeight = 'normal';
                    }
                    ;
                    if (!_states.text.font.file.i) {
                        item.set({fontStyle: 'normal'});
                        _states.text.fontStyle = 'normal';
                    }
                    ;
                    if (!_states.text.font.file.bi && item.get('fontWeight') == 'bold' && item.get('fontStyle') == 'italic') {
                        item.set({fontWeight: 'normal', fontStyle: 'normal'});
                        _states.text.fontWeight = 'normal';
                        _states.text.fontStyle = 'normal';
                    }
                    ;
                    break;
            }
            _states.text[type] = value;
            if (type == 'rtl') {
                item.set({text: item.text.split('').reverse().join('')});
            }
            ;
            if (type.indexOf("font") > -1) {
                var font = new FontFaceObserver(_states.text.fontFamily, {
                    weight: _states.text.fontWeight,
                    style: _states.text.fontStyle
                });
                font.load(item.get('text')).then(function () {
                    fabric.util.clearFabricFontCache(_states.text.fontFamily);
                    $timeout(function () {
                        item.initDimensions();
                        item.setCoords();
                        // custom change fonts letter
                        if (typeof add_change_fonts_colors != "undefined" && NBDESIGNCONFIG.checktopchange == 'yes' || typeof udc_nbd_js_config != "undefined") {
                            if (item.selectionStart == item.selectionEnd && item.type !== 'curvedText') {
                                item.removeStyleFromTo();
                            }
                        }
                        $scope.afterObjectModify();
                        $scope.renderStage();
                    });
                }, function () {
                    item.setCoords();
                    $scope.renderStage();
                });
                if ($scope.settings.nbdesigner_enable_text_check_lang == 'yes') {
                    $scope.checkCharacter(item);
                }
            } else {
                item.setCoords();
                $scope.afterObjectModify();
                $scope.renderStage();
            }
            $scope.normalizeText(item);
            $scope.updateLayersList();
        };

        $scope.onGradientAngleChanged = function (e) {
            const _canvas = $scope.getCurrentStageCanvas();
            if (!_canvas || !_canvas.set) {
                return;
            }
            const activeObject = _canvas.getActiveObject();
            $scope.shapeGP.setDirection(`${e}deg`);
            activeObject.set({linearGradientAngle: Number(e || 0), dirty: true});
            $scope.updateApp();
            _canvas.renderAll();
        }

        $scope.onCanvasGradientAngleChanged = function (e) {
            const _canvas = $scope.getCurrentStageCanvas();
            if (!_canvas || !_canvas.set) {
                return;
            }
            $scope.backgroundGP.setDirection(`${e}deg`);
            _canvas.set({linearGradientAngle: Number(e || 0), dirty: true});
            $scope.updateApp();
            _canvas.renderAll();
        }
        /*advanced*/
        if (typeof ttp_enqueue_custom_admin_js1 != "undefined") {
            $scope.setTextAttributeLimit = function (type, value) {
                var _stage = $scope.stages[$scope.currentStage],
                    _states = _stage.states,
                    _canvas = _stage["canvas"];
                if (!appConfig.ready) return;
                var item = _canvas.getActiveObject();
                var items = _canvas.getActiveObjects();
                if (!item || !items) return;
                $scope.beforeObjectModify(item);
                if (item.lengthLimit != "undefined") {
                    if (type == "fontSize") {
                        Object.assign(item, {lengthLimit: value});
                    }
                }
                $scope.normalizeText(item);
                $scope.updateLayersList();
            };
        }
        $scope.setShadow = function () {
            const _canvas = $scope.stages[$scope.currentStage]['canvas'];
            if (!appConfig.ready) return;
            const item = _canvas.getActiveObject();
            if (!item) return;
            $scope.beforeObjectModify(item);
            let color;
            const shadowColor = $scope.stages[$scope.currentStage].states.shadow.color;
            let colorArr = fabric.Color.sourceFromHex(shadowColor);
            if (shadowColor && !Array.isArray(colorArr)) {
                color = shadowColor;
            } else if (Array.isArray(colorArr)) {
                color = `rgba(${colorArr[0]},${colorArr[1]},${colorArr[2]},${$scope.stages[$scope.currentStage].states.shadow.opacity})`;
            } else {
                color = 'black';
            }
            item.set({
                shadow: {
                    color,
                    offsetX: $scope.stages[$scope.currentStage].states.shadow.offsetX,
                    offsetY: $scope.stages[$scope.currentStage].states.shadow.offsetY,
                    blur: $scope.stages[$scope.currentStage].states.shadow.blur
                }
            });
            $scope.renderStage();
            $scope.afterObjectModify();
            $scope.updateApp();
        };
        $scope.removeShadow = function () {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            if (!item) return;
            $scope.beforeObjectModify(item);
            delete item.shadow;
            $scope.renderStage();
            $scope.afterObjectModify();
            $scope.updateApp();
        };
        /* Extenal Image */
        $scope.addImageFromClipboard = function (file, type) {
            $scope.toggleStageLoading();
            $scope.resource.upload.progressBar = 0;
            jQuery('.nbd-progress-bar').addClass('active');
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                object = _canvas.getActiveObject();
            if (!!object && !!object.get('maskId') && files.length == 1) {
                var maskId = object.get('maskId');
            }
            NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                var data = JSON.parse(data);
                if (data.flag == 1) {
                    if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                    if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {
                        $scope.toggleStageLoading();
                        alert(data.mes);
                        return;
                    }
                    ;
                    $scope.storeUploadFile(data, data.name);
                    if (maskId) {
                        $scope.addImage(data, false, true, false, false, maskId);
                    } else {
                        $scope.addImage(data, false, true);
                    }
                    jQuery("#tab-photo .tab-scroll").stop().animate({
                        scrollTop: jQuery("#tab-photo .tab-scroll").prop("scrollHeight")
                    }, 100);
                    localStorage.setItem('uploaded', $scope.resource.upload.data);
                    $scope.onEndRepeat('upload');
                } else {
                    $scope.toggleStageLoading();
                    alert(data.mes);
                }
                jQuery('.nbd-progress-bar').removeClass('active');
            }, function (progress) {
                $scope.resource.upload.progressBar = progress.toFixed(0);
            });
        };
        $scope.addImageFromUrl = function (dataImg, extenal, ilr, maskId) {
            var url = typeof dataImg == 'object' ? (dataImg.url.url || dataImg.url) : dataImg;
            if (typeof nbpdf_ai_to_svg != "undefined") {
                url = url.replace("-ai.svg", ".svg");
            }
            if (url == '') return;
            /*advanced*/
            if (typeof udc_nbd_js_config != 'undefined') {
                // replace Image
                var stageImg = $scope.stages[$scope.currentStage],
                    _canvas = stageImg['canvas'],
                    selectedObject = _canvas.getActiveObject();
                if (selectedObject && selectedObject.type == 'image') {
                    $scope.replaceImage(url);
                }
            }
            $scope.toggleStageLoading();
            $scope.showDesignTab();
            if (url.match(/\.(svg)$/) != null) {
                var art = {url: url, name: ''};
                $scope.addArt(art, false, true);
                return
            }
            ;
            if ($scope.resource.addImageContext == 'manual') {
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'],
                    object = _canvas.getActiveObject();
                if (!!object && !!object.get('maskId')) {
                    maskId = object.get('maskId');
                }
            }
            if (angular.isUndefined(extenal) || extenal) {
                if ($scope.resource.photo.type === 'Unsplash') {
                    const downloadUrl = `${dataImg.url.download}&client_id=${NBDESIGNCONFIG['nbdesigner_unsplash_api_key']}`;
                    $http({
                        method: 'GET',
                        url: downloadUrl
                    }).then(() => {
                        NBDDataFactory.get('nbdesigner_copy_image_from_url', {
                            url: url,
                            gapi: $scope.resource.gapi
                        }, function (data) {
                            data = JSON.parse(data);

                            // Add id pixabay
                            if (typeof PixabayId != 'undefined') {
                                data.src = data.src + "#" + $scope.resource.addImageId + "#" + $scope.resource.addImagetype;
                            }
                            if (data['flag'] == 1) {
                                if (angular.isDefined(maskId)) {
                                    $scope.addImage(data, false, true, false, false, maskId);
                                } else {
                                    $scope.addImage(data, false, true);
                                }
                                $scope.storeUploadFile(data, '');
                            } else {
                                alert('Try to download image and then upload to our server!');
                            }
                        });
                    });
                    $scope.resource.addImageContext = '';
                    return;
                }
                NBDDataFactory.get('nbdesigner_copy_image_from_url', {
                    url: url,
                    gapi: $scope.resource.gapi
                }, function (data) {
                    data = JSON.parse(data);

                    // Add id pixabay
                    if (typeof PixabayId != 'undefined') {
                        data.src = data.src + "#" + $scope.resource.addImageId + "#" + $scope.resource.addImagetype;
                    }
                    if (data['flag'] == 1) {
                        if (angular.isDefined(maskId)) {
                            $scope.addImage(data, false, true, false, false, maskId);
                        } else {
                            $scope.addImage(data, false, true);
                        }
                        $scope.storeUploadFile(data, '');
                    } else {
                        alert('Try to download image and then upload to our server!');
                    }
                });
            } else {
                if (ilr) $scope.resource.upload.ilr = true;
                if (angular.isDefined(maskId)) {
                    $scope.addImage(dataImg, false, true, false, false, maskId);
                } else {
                    $scope.addImage(dataImg, false, true);
                }
            }
            $scope.resource.addImageContext = '';
        };
        /* Image */
        $scope.getUniqMask = function () {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                count = 0,
                maskId = '';
            _canvas.forEachObject(function (obj, index) {
                if (!!obj.get('maskId')) {
                    count++;
                    if (maskId == '') {
                        maskId = obj.get('maskId');
                    }
                }
                ;
            });
            return count == 1 ? maskId : '';
        };
        $scope.getEmptyMask = function () {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                maskId = '';
            _canvas.forEachObject(function (obj, index) {
                if (!!obj.get('maskId') && obj.get('srcChanged') === false) {
                    if (maskId == '') {
                        maskId = obj.get('maskId');
                    }
                }
                ;
            });
            return maskId;
        };
        $scope.addImage = function (data, showLoading, hideLoading, additionalTitle, additionalValue, maskId) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                url = typeof data == 'object' ? (angular.isDefined(data.src) ? data.src : data.url) : data;
            if (showLoading) $scope.toggleStageLoading();
            if (angular.isUndefined(maskId) && !$scope.isTemplateMode && $scope.settings.nbdesigner_auto_fill_template_masks == 'yes') {
                var _maskId = $scope.getEmptyMask();
                if (_maskId != '') maskId = _maskId;
            }
            if (angular.isUndefined(maskId) && !$scope.isTemplateMode && $scope.settings.nbdesigner_limit_photo_by_masks == 'yes') {
                if (hideLoading) {
                    $timeout(function () {
                        $scope.toggleStageLoading();
                    });
                }
                return;
            }
            fabric.Image.fromURL(url, function (op) {
                if (angular.isDefined(maskId) || $scope.stages[$scope.currentStage].states.elementUpload) {
                    var object;
                    if (angular.isDefined(maskId)) {
                        object = $scope.getMaskedLayerByMaskId(maskId);
                    } else {
                        object = _canvas.getActiveObject();
                    }
                    /*advanced*/
                    if (typeof mia_nbd_js_config_design != "undefined") {
                        if (angular.isDefined(object.clipPath) && object.clipPath.isMask) {
                            let maskId = object.maskId;
                            object = $scope.getMaskedLayerByMaskId(maskId);
                        }
                    }
                    var element = object.getElement();
                    $scope.beforeObjectModify(object);
                    element.setAttribute("src", url);
                    var scaleX = object.width * object.scaleX / op.width,
                        scaleY = object.width * object.scaleX / op.width;
                    if (angular.isDefined(maskId)) {
                        var mask = $scope.getMaskLayer(maskId),
                            width = mask.get('width') * mask.get('scaleX'),
                            height = mask.get('height') * mask.get('scaleY'),
                            newWidth = width,
                            newHeight = height;
                        if ((op.width / op.height) > (width / height)) {
                            newWidth = op.width / op.height * newHeight;
                        } else {
                            newHeight = op.height / op.width * newWidth;
                        }
                        scaleX = newWidth / op.width;
                        scaleY = newHeight / op.height;

                        object.set({
                            isEmptyMask: false,
                            srcChanged: true
                        });
                        _canvas.discardActiveObject();
                        _canvas.setActiveObject(object);
                    }

                    /*advanced*/
                    if (typeof mia_nbd_js_config_design != "undefined" && angular.isUndefined(maskId)) {
                        // $scope.createClippingMask(15,object);
                        var widthmia = object.get('width'),
                            heightmia = object.get('height'),
                            topmia = object.get('top'),
                            leftmia = object.get('left'),
                            scaleXmia = object.get('scaleX'),
                            scaleYmia = object.get('scaleY'),
                            realWidthmia = scaleXmia * widthmia,
                            realHeightmia = scaleYmia * heightmia,
                            realLeftmia = leftmia - realWidthmia / 2,
                            realTopmia = topmia - realHeightmia / 2;
                        var path = new fabric.Path($scope.masks[15]);
                        $scope.contextAddLayers = 'addMask';
                        _canvas.add(path);
                        var pathObj = _canvas.item(_canvas.getObjects().length - 1);
                        var newWidthmia = realWidthmia, newHeightmia = realHeightmia, newLeftmia = realLeftmia,
                            newTopmia = realTopmia;
                        var d = new Date(),
                            itemId = d.getTime() + Math.floor(Math.random() * 1000);
                        if (angular.isUndefined(maskId)) {
                            let maskId = itemId;
                        }
                        pathObj.set({
                            scaleX: newWidthmia / pathObj.width,
                            scaleY: newHeightmia / pathObj.height,
                            isMask: 1,
                            left: newLeftmia,
                            top: newTopmia,
                            absolutePositioned: true,
                            strokeWidth: 0,
                            lockRotation: true,
                            selectable: false,
                            itemId: itemId,
                            fill: '#ffffff',
                            opacity: 0.001
                        });
                        object.set({
                            clipPath: pathObj,
                            perPixelTargetFind: true,
                            centeredScaling: true,
                            maskId: maskId,
                            width: op.width,
                            height: op.height,
                            scaleX: scaleX,
                            scaleY: scaleY,
                            lockMovementX: false,
                            lockMovementY: false,

                        });
                    }
                    object.set({
                        dirty: true,
                        width: op.width,
                        height: op.height,
                        scaleX: scaleX,
                        scaleY: scaleY,
                    });
                    /*advanced*/
                    if (typeof udc_nbd_js_config != 'undefined') {
                        op.oldScaleX = op.scaleX;
                        op.oldScaleY = op.scaleY;
                        op.oldWidth = op.width;
                        op.oldHeight = op.height;
                    }
                    if (typeof data == 'object' && angular.isDefined(data.origin_url)) {
                        if (angular.isDefined(maskId)) {
                            scaleX = newWidth / data.width;
                            scaleY = newHeight / data.height;
                        } else {
                            var scaleX = object.width * object.scaleX / data.width,
                                scaleY = object.width * object.scaleX / data.width;
                        }
                        object.set({
                            origin_url: data.origin_url,
                            origin_width: data.width,
                            origin_height: data.height,
                            width: data.width,
                            height: data.height,
                            scaleX: scaleX,
                            scaleY: scaleY
                        });
                    } else if (!!object.origin_url) {
                        delete object.origin_url;
                    }

                    object.setCoords();
                    if (angular.isDefined(maskId)) $scope.adjustMaskedLayers(object);
                    $scope.renderStage();
                    if (angular.isDefined(maskId)) {
                        $scope.adjustMaskedLayers(object);
                        if ($scope.checkActiveFilter && object.filters.length) {
                            object._originalElement = op._element;
                            object.applyFilters(false, function () {
                                setTimeout(() => $scope.renderStage(), 200);
                                setTimeout(() => $scope.renderStage(), 500);
                                setTimeout(() => $scope.renderStage(), 1000);
                            }, true);
                        } else {
                            $timeout(function () {
                                $scope.renderStage();
                            }, 500);
                            $timeout(function () {
                                $scope.renderStage();
                            }, 1000);
                            $timeout(function () {
                                $scope.renderStage();
                            }, 2000);
                            $timeout(function () {
                                $scope.renderStage();
                            }, 3000);
                        }
                    }
                    ;
                    $scope.afterObjectModify();
                    /*advanced*/
                    if (typeof mia_nbd_js_config_design != "undefined") {
                        $scope.adjustMaskedLayers(object);
                        $timeout(function () {
                            $scope.renderStage();
                        }, 500);
                        $timeout(function () {
                            $scope.renderStage();
                        }, 1000);
                        $timeout(function () {
                            $scope.renderStage();
                        }, 2000);
                        $timeout(function () {
                            $scope.renderStage();
                        }, 3000);
                    }
                } else {
                    var _ratio = NBDESIGNCONFIG.nbdesigner_enable_auto_fit_image == 'yes' ? 1 : 0.9;
                    var max_width = _canvas.width / scale * _ratio,
                        max_height = _canvas.height / scale * _ratio,
                        new_width = max_width;
                    if (op.width < max_width) new_width = op.width;
                    var width_ratio = new_width / op.width,
                        new_height = op.height * width_ratio;
                    if (new_height > max_height) {
                        new_height = max_height;
                        var height_ratio = new_height / op.height;
                        new_width = op.width * height_ratio;
                    }
                    ;
                    /*advanced*/
                    if (typeof asui_nbd_js_config_design != "undefined" && NBDESIGNCONFIG.nbdesigner_strech_image_upload == 'yes') {
                        var cv = stage.canvas;
                        op.set({
                            top: 0,
                            left: 0,
                            scaleX: cv.width / op.width / scale,
                            scaleY: cv.height / op.height / scale
                        });
                        _canvas.add(op);
                        cv.viewportCenterObjectH(op);
                        cv.viewportCenterObjectV(op);
                        $scope.deactiveAllLayer();
                        $scope.renderStage();
                        if (hideLoading) {
                            $timeout(function () {
                                $scope.toggleStageLoading();
                            });
                        }
                        $timeout(function () {
                            $scope.setAsBackground();
                        }, 1000);
                        return;
                    }
                    op.set({
                        fill: '#ff0000',
                        scaleX: new_width / op.width,
                        scaleY: new_height / op.height
                    });
                    if (typeof custom_richard != 'undefined') {
                        /*advanced*/
                        var ratioViewPort = stage.config.ratioViewPort;
                        new_width = op.width * ratioViewPort;
                        new_height = op.height * ratioViewPort;
                        if (new_width > _canvas.width || new_height > _canvas.height) {
                            stage.states.big = true;
                            $scope.settings.showWarning.big = true;
                        } else {
                            $scope.settings.showWarning.big = false;
                            stage.states.big = false;
                        }
                        op.set({
                            scaleX: new_width / op.width,
                            scaleY: new_height / op.height,
                            lockScalingX: true,
                            lockScalingY: true
                        });
                    }
                    if (typeof data == 'object' && angular.isDefined(data.origin_url)) {
                        op.set({
                            origin_url: data.origin_url,
                            origin_width: data.width,
                            origin_height: data.height,
                            width: data.width,
                            height: data.height,
                            scaleX: new_width / data.width,
                            scaleY: new_height / data.height
                        });
                    }

                    if (typeof data == 'object' && angular.isDefined(data.origin_pdf)) {
                        op.set({
                            origin_pdf: data.origin_pdf,
                            lockRotation: true,
                            hasRotatingPoint: false
                        });
                    }

                    if (additionalTitle) op[additionalTitle] = additionalValue;
                    if (typeof custom_richard != 'undefined') {
                        /*advanced*/
                        if (!stage.states.big) {
                            _canvas.add(op);
                        }
                    } else {
                        _canvas.add(op);
                    }
                }
                if (hideLoading) {
                    $timeout(function () {
                        $scope.toggleStageLoading();
                    });
                }
            }, {crossOrigin: 'anonymous'});
        };
        /*advanced*/
        if (typeof udc_nbd_js_config != 'undefined') {
            $scope.svgMaskCreate = function () {
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'];

                fabric.Image.fromURL('https://dpeuzbvf3y4lr.cloudfront.net/cliparts/clipart-25940.svg', function (img) {
                    img1 = img;
                    fabric.Image.fromURL('https://cdn.pixabay.com/photo/2020/10/30/16/27/mountain-5699035_150.jpg', function (img) {
                        img1.scaleToWidth(_canvas.getWidth());
                        img2 = img;
                        img2.scaleToHeight(300);
                        img2.left = 50;
                        img2.top = 50;
                        img2.globalCompositeOperation = 'source-atop';
                        _canvas.add(img1);
                        _canvas.add(img2);
                    });
                });
            };
        }
        $scope.mask = 1;
        $scope.pathCommand = '';
        $scope.svgPath = '';
        $scope.getPathCommand = function () {
            var svgStr = $scope.svgPath.replace(/<!--[\s\S]*?-->/g, "").replace(/<\?xml[\s\S]*?\?>/g, "").replace(/<style[\s\S]*?style>/g, "").replace(/\n|\r/gm, " ").replace(/  /g, " ").replace(/^ /g, "").replace(/ $/g, "").replace(/(?:class|id|style|xmlns\:xlink|xml\:space|fill|enable-background)=['\"][^'\"]*['\"]/g, "").replace(/<\/?g>/g, "").replace(/\s{2,}/g, ' ').replace(/(\/?>) </g, '$1<');
            var _regex = /d=["'](.*?)["']/gm;
            $scope.pathCommand = '';
            if (svgStr.match(/<path.*\/>/gm) && svgStr.match(_regex)) {
                matches = _regex.exec(svgStr);
                $scope.pathCommand = angular.isDefined(matches[1]) ? matches[1] : '';
            }
        };
        $scope.createClippingMask = function (maskIndex, obj) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                obj = obj ? obj : _canvas.getActiveObject();
            if (obj) {
                var width = obj.get('width'),
                    height = obj.get('height'),
                    top = obj.get('top'),
                    left = obj.get('left'),
                    scaleX = obj.get('scaleX'),
                    scaleY = obj.get('scaleY'),
                    realWidth = scaleX * width,
                    realHeight = scaleY * height,
                    realLeft = left - realWidth / 2,
                    realTop = top - realHeight / 2;
                var pathCommand = maskIndex > -1 ? $scope.masks[maskIndex] : $scope.pathCommand;
                if (pathCommand == '') return;
                var path = new fabric.Path(pathCommand);
                $scope.contextAddLayers = 'addMask';
                _canvas.add(path);
                var pathObj = _canvas.item(_canvas.getObjects().length - 1);
                var newWidth = realWidth, newHeight = realHeight, newLeft = realLeft, newTop = realTop;
                if ((realWidth / realHeight) > (pathObj.width / pathObj.height)) {
                    newWidth = newHeight * pathObj.width / pathObj.height;
                    newLeft += (realWidth - newWidth) / 2;
                } else {
                    newHeight = newWidth * pathObj.height / pathObj.width;
                    newTop += (realHeight - newHeight) / 2;
                }
                var d = new Date(),
                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                pathObj.set({
                    scaleX: newWidth / pathObj.width,
                    scaleY: newHeight / pathObj.height,
                    isMask: 1,
                    left: newLeft,
                    top: newTop,
                    absolutePositioned: true,
                    strokeWidth: 0,
                    lockRotation: true,
                    itemId: itemId,
                    selectable: false,
                    fill: '#ffffff',
                    opacity: 0.001
                });
                pathObj.setCoords();
                $timeout(function () {
                    obj.set({
                        clipPath: pathObj,
                        perPixelTargetFind: true,
                        centeredScaling: true,
                        maskId: itemId
                    });
                    $scope.stages[$scope.currentStage].states.isMasked = true;
                    $scope.updateMaskLayer();
                    $scope.updateLayersList();
                    $scope.renderStage();
                });
            }
        };

        $scope.createClippingMaskFromShape = function () {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                obj = obj ? obj : _canvas.getActiveObject();
            if (obj) {
                const index = $scope.getLayerById(obj.itemId);
                var width = obj.get('width'),
                    height = obj.get('height'),
                    top = obj.get('top'),
                    left = obj.get('left'),
                    scaleX = obj.get('scaleX'),
                    scaleY = obj.get('scaleY'),
                    realWidth = scaleX * width,
                    realHeight = scaleY * height,
                    realLeft = left - realWidth / 2,
                    realTop = top - realHeight / 2;

                obj.clone((cloned) => {
                    var path = cloned;
                    $scope.contextAddLayers = 'addMask';
                    _canvas.add(path);
                    var pathObj = _canvas.item(_canvas.getObjects().length - 1);
                    var newWidth = realWidth, newHeight = realHeight;
                    if ((realWidth / realHeight) > (pathObj.width / pathObj.height)) {
                        newWidth = newHeight * pathObj.width / pathObj.height;
                    } else {
                        newHeight = newWidth * pathObj.height / pathObj.width;
                    }
                    var d = new Date(),
                        itemId = d.getTime() + Math.floor(Math.random() * 1000);
                    pathObj.set({
                        scaleX: newWidth / pathObj.width,
                        scaleY: newHeight / pathObj.height,
                        isMask: 1,
                        left: left,
                        top: top,
                        absolutePositioned: true,
                        strokeWidth: 0,
                        lockRotation: true,
                        itemId: itemId,
                        selectable: false,
                        fill: '#ffffff',
                        opacity: 0.001
                    });
                    pathObj.setCoords();
                    $timeout(function () {
                        obj.set({
                            clipPath: pathObj,
                            perPixelTargetFind: true,
                            centeredScaling: true,
                            maskId: itemId
                        });
                        $scope.stages[$scope.currentStage].states.isMasked = true;
                        $scope.updateMaskLayer();
                        $scope.updateLayersList();
                        $scope.renderStage();
                        $scope.detachShape(index);
                    });
                });
            }
        };
        $scope.removeClippingMask = function (obj, needreRender, withoutRemoveMask) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'];
            obj = obj ? obj : _canvas.getActiveObject();
            if (!!obj.get('maskId')) {
                var maskLayerInsex = $scope.getLayerById(obj.get('maskId')),
                    maskLayer = _canvas.item(maskLayerInsex);
                !withoutRemoveMask && _canvas.remove(maskLayer);
            }
            $scope.stages[$scope.currentStage].states.isMasked = false;
            obj.maskId = null;
            obj.clipPath = null;
            obj.perPixelTargetFind = false;
            if (NBDESIGNCONFIG.nbdesigner_object_center_scaling == 'no') {
                obj.centeredScaling = false;
            }
            needreRender = angular.isDefined(needreRender) ? needreRender : true;
            $scope.updateMaskLayer();
            needreRender && $scope.renderStage();
            $scope.updateLayersList();
        };
        $scope.editMask = function () {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                obj = _canvas.getActiveObject();
            if (obj) {
                var maskId = obj.get("maskId"),
                    maskObjIndex = $scope.getLayerById(maskId),
                    maskLayer = _canvas.item(maskObjIndex);
                obj.moveTo(maskObjIndex);
                if (obj.isEmptyMask) {
                    const selection = new fabric.ActiveSelection([obj, maskLayer], {
                        canvas: _canvas,
                    });
                    _canvas.setActiveObject(selection);
                    _canvas.requestRenderAll();
                } else {
                    maskLayer.set({selectable: true, hasRotatingPoint: false});
                    _canvas.setActiveObject(maskLayer);
                }
                $scope.ctxMenuStyle.visibility = 'hidden';
                $scope.updateApp();
            }
        };
        $scope.detachShape = function (originalIndex) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                obj = _canvas.getActiveObject();
            if (obj) {
                var maskId = obj.get("maskId"),
                    maskObjIndex = $scope.getLayerById(maskId),
                    maskLayer = _canvas.item(maskObjIndex),
                    maskedLayerInsex = $scope.getLayerById(obj.get('itemId')),
                    defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';
                fabric.Image.fromURL(defaultMaskImageUrl, function (op) {
                    $scope.contextAddLayers = 'addMask';
                    var top = maskLayer.get('top'),
                        left = maskLayer.get('left'),
                        scaleX = maskLayer.get('scaleX'),
                        scaleY = maskLayer.get('scaleY'),
                        width = maskLayer.get('width'),
                        height = maskLayer.get('height'),
                        angle = maskLayer.get('angle'),
                        originX = maskLayer.get('originX'),
                        originY = maskLayer.get('originY'),
                        realWidth = width * scaleX,
                        realHeight = height * scaleY,
                        newWidth = realWidth,
                        newHeight = realHeight;
                    if ((op.width / op.height) > (realWidth / realHeight)) {
                        newWidth = op.width / op.height * newHeight;
                    } else {
                        newHeight = op.height / op.width * newWidth;
                    }
                    var d = new Date(),
                        itemId = d.getTime() + Math.floor(Math.random() * 1000);
                    op.set({
                        clipPath: maskLayer,
                        perPixelTargetFind: true,
                        centeredScaling: true,
                        maskId: maskId,
                        scaleX: newWidth / op.width,
                        scaleY: newHeight / op.height,
                        top: top + realHeight / 2,
                        left: left + realWidth / 2,
                        itemId: itemId,
                        isEmptyMask: true,
                        srcChanged: false
                    });
                    if (angle) {
                        op.set({
                            top,
                            left,
                            angle,
                            originX,
                            originY,
                        });
                    }
                    $scope.deactiveAllLayer();
                    $scope.removeClippingMask(obj, false, true);
                    _canvas.add(op);
                    op.moveTo(originalIndex);
                    _canvas.remove(obj);
                    $timeout(function () {
                        _canvas.setActiveObject(op);
                        $scope.updateMaskLayer();
                        $scope.renderStage();
                        $scope.updateLayersList();
                    });
                }, {crossOrigin: 'anonymous'});
            }
        };
        $scope.detachImage = function () {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                obj = _canvas.getActiveObject();
            if (obj) {
                var maskId = obj.get("maskId"),
                    maskObjIndex = $scope.getLayerById(maskId),
                    maskLayer = _canvas.item(maskObjIndex),
                    maskedLayerInsex = $scope.getLayerById(obj.get('itemId')),
                    defaultMaskImageUrl = NBDESIGNCONFIG.assets_url + 'images/placeholder.png';
                fabric.Image.fromURL(defaultMaskImageUrl, function (op) {
                    $scope.contextAddLayers = 'addMask';
                    var top = maskLayer.get('top'),
                        left = maskLayer.get('left'),
                        scaleX = maskLayer.get('scaleX'),
                        scaleY = maskLayer.get('scaleY'),
                        width = maskLayer.get('width'),
                        height = maskLayer.get('height'),
                        realWidth = width * scaleX,
                        realHeight = height * scaleY,
                        newWidth = realWidth,
                        newHeight = realHeight;
                    if ((op.width / op.height) > (realWidth / realHeight)) {
                        newWidth = op.width / op.height * newHeight;
                    } else {
                        newHeight = op.height / op.width * newWidth;
                    }
                    var d = new Date(),
                        itemId = d.getTime() + Math.floor(Math.random() * 1000);
                    op.set({
                        clipPath: maskLayer,
                        perPixelTargetFind: true,
                        centeredScaling: true,
                        maskId: maskId,
                        scaleX: newWidth / op.width,
                        scaleY: newHeight / op.height,
                        top: top + realHeight / 2,
                        left: left + realWidth / 2,
                        itemId: itemId,
                        isEmptyMask: true,
                        srcChanged: false
                    });
                    $scope.deactiveAllLayer();
                    $scope.removeClippingMask(obj, false, true);
                    _canvas.add(op);
                    op.moveTo(maskedLayerInsex);
                    $timeout(function () {
                        obj.set({
                            top: obj.get('top'),
                            left: obj.get('left')
                        });
                        obj.moveTo(maskedLayerInsex + 1);
                        _canvas.setActiveObject(obj);
                        $scope.updateMaskLayer();
                        $scope.renderStage();
                    });
                }, {crossOrigin: 'anonymous'});
            }
        };
        $scope.exitMaskMode = function () {
            $scope.deactiveAllLayer();
            $scope.updateMaskLayer();
            $scope.renderStage();
        };
        $scope.masks = [
            "M 12 4.248 c -3.148 -5.402 -12 -3.825 -12 2.944 c 0 4.661 5.571 9.427 12 15.808 c 6.43 -6.381 12 -11.147 12 -15.808 c 0 -6.792 -8.875 -8.306 -12 -2.944 Z",
            "M 18 1 l -6 4 l -6 -4 l -6 5 v 7 l 12 10 l 12 -10 v -7 Z",
            "M 12 0 c -2.995 2.995 -7.486 4 -11 4 c 0 8.583 5.068 16.097 11 20 c 5.932 -3.903 11 -11.417 11 -20 c -3.514 0 -8.005 -1.005 -11 -4 Z",
            "M 1 4 c 0 8.578 5.071 16.1 11 20 c 5.929 -3.9 11 -11.422 11 -20 c -2.828 -2.329 -7.153 -4 -11 -4 c -3.838 0 -8.172 1.671 -11 4 Z",
            "M 12.01 21.49L23.64 7c-.45-.34-4.93-4-11.64-4C5.28 3 .81 6.66.36 7l11.63 14.49.01.01.01-.01 Z",
            "M 12 0 l 2.139 2.629 l 3.068 -1.441 l 0.786 3.297 l 3.389 0.033 l -0.722 3.312 l 3.039 1.5 l -2.088 2.67 l 2.088 2.67 l -3.039 1.5 l 0.722 3.312 l -3.389 0.033 l -0.786 3.297 l -3.068 -1.441 l -2.139 2.629 l -2.139 -2.629 l -3.068 1.441 l -0.786 -3.297 l -3.389 -0.033 l 0.722 -3.312 l -3.039 -1.5 l 2.088 -2.67 l -2.088 -2.67 l 3.039 -1.5 l -0.722 -3.312 l 3.389 -0.033 l 0.786 -3.297 l 3.068 1.441 Z",
            "M 0.000 16.000 L 12.000 20.785 L 13.856 8.000 L 24.000 0.000 L 13.856 -8.000 L 12.000 -20.785 L 0.000 -16.000 L -12.000 -20.785 L -13.856 -8.000 L -24.000 0.000 L -13.856 8.000 L -12.000 20.785 Z",
            "M 12 0.587 l 3.668 7.568 l 8.332 1.151 l -6.064 5.828 l 1.48 8.279 l -7.416 -3.967 l -7.417 3.967 l 1.481 -8.279 l -6.064 -5.828 l 8.332 -1.151 Z",
            "M 24 16.971 l -7.029 7.029 h -9.942 l -7.029 -7.029 v -9.942 l 7.029 -7.029 h 9.942 l 7.029 7.029 Z",
            "M0 0 L24 0 L12 20.78Z",
            "M-12,0a12,12 0 1,0 24,0a12,12 0 1,0 -24,0Z",
            "M 9 0 c -5 0 -9 7 -9 14 c 0 5 3 10 9 10 c 6 0 9 -5 9 -10 c 0 -7 -4 -14 -9 -14 Z",
            "M10,10 h20 a2,2 0 0 0.1 2,2 v20 a2,2 0 0 0.1 -2,2 h-20 a2,2 0 0 0.1 -2,-2 v-20 a2,2 0 0 0.1 2,-2 Z",
            "M 0.054 23 c 0.971 -1.912 2.048 -4.538 1.993 -6.368 c -1.308 -1.562 -2.047 -3.575 -2.047 -5.625 c 0 -5.781 5.662 -10.007 12 -10.007 c 6.299 0 12 4.195 12 10.007 c 0 6.052 -6.732 11.705 -15.968 9.458 c -1.678 1.027 -5.377 2.065 -7.978 2.535 Z",
            "M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z",
            "M0 0 L24 0 L24 24 L0 24Z",
            "M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z",
            "M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z",
            "M5.94 18.99H15c.65 0 1.26-.31 1.63-.84l3.95-5.57c.25-.35.25-.81 0-1.16l-3.96-5.58C16.26 5.31 15.65 5 15 5H5.94c-.81 0-1.28.93-.81 1.59L9 12l-3.87 5.41c-.47.66 0 1.58.81 1.58z",
            "M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7s2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z",
            "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z",
            "M13.2 7.07L10.25 11l2.25 3c.33.44.24 1.07-.2 1.4-.44.33-1.07.25-1.4-.2-1.05-1.4-2.31-3.07-3.1-4.14-.4-.53-1.2-.53-1.6 0l-4 5.33c-.49.67-.02 1.61.8 1.61h18c.82 0 1.29-.94.8-1.6l-7-9.33c-.4-.54-1.2-.54-1.6 0z",
            "M6.05,8.05c-2.73,2.73-2.73,7.15-0.02,9.88c1.47-3.4,4.09-6.24,7.36-7.93c-2.77,2.34-4.71,5.61-5.39,9.32 c2.6,1.23,5.8,0.78,7.95-1.37c2.99-2.99,3.83-11.14,4.01-13.38c0.02-0.31-0.23-0.56-0.53-0.53C17.19,4.22,9.04,5.06,6.05,8.05z",
            "M12.43 2.3c-2.38-.59-4.68-.27-6.63.64-.35.16-.41.64-.1.86C8.3 5.6 10 8.6 10 12c0 3.4-1.7 6.4-4.3 8.2-.32.22-.26.7.09.86 1.28.6 2.71.94 4.21.94 6.05 0 10.85-5.38 9.87-11.6-.61-3.92-3.59-7.16-7.44-8.1z",
            "M7 2v11h3v9l7-12h-4l3-8z"
        ];
        $scope.replaceMaskedImage = function () {
            if (!$scope.imageSelectionMask) {
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'];
                var object = _canvas.getActiveObject();
                $scope.imageSelectionMask = object;

                document.addEventListener('mouseup', () => {
                    $timeout(() => {
                        $scope.imageSelectionMask = null;
                    });
                }, {once: true});
            }
            $timeout(function () {
                jQuery('#nav-photos').triggerHandler('click');
                $timeout(function () {
                    if (jQuery('#tab-photo .result-loaded').hasClass('loaded')) {
                        jQuery('[data-type=""]').click();
                        $timeout(function () {
                            jQuery('[data-type=""]').click();
                        }, 400);
                    } else {
                        jQuery('[data-type=""]').click();
                    }
                }, 400);
            });
        };

        $scope.toolbarBackgroundColor = function () {
            $timeout(function () {
                jQuery('#nav-background').trigger('click');
                $timeout(function () {
                    if (jQuery('#tab-backgrounds #style-3 #bgcolorpicker1').hasClass('loaded')) {
                        jQuery('[data-type=""]').click();
                        $timeout(function () {
                            jQuery('[data-type=""]').click();
                        }, 400);
                    } else {
                        jQuery('[data-type=""]').click();
                    }
                }, 400);
            });
        };

        $scope.onStrokeColorChanged = function (color) {
            $scope.changeObjectColor('stroke', color);
            $scope.applySpectrumStrokeColor(color);
        }
        $scope.onShadowColorChanged = function (color) {
            $scope.setShadowcolor(color);
        }
        $scope.onShadowTextColorChanged = function (color) {
            $scope.setShadowTextcolor(color);
        }
        $scope.onCanvasBackgroundColorChanged = function (color) {
            $scope.changeBackgroundCanvas(color, false);
        }

        $scope.onGlobalColorChanged = function (color) {
            $scope.selectGlobalPicker(color, false);
        }

        $scope.getCurrentStage = function () {
            return $scope.stages[$scope.currentStage];
        }
        $scope.getCurrentStageCanvas = function () {
            const stage = $scope.getCurrentStage();
            if (!stage) {
                return null;
            }
            return stage['canvas'];
        }
        $scope.getActiveObject = function (_canvas) {
            const canvas = _canvas || $scope.getCurrentStageCanvas();
            if (!canvas) {
                return null;
            }
            return canvas.getActiveObject();
        }
        $scope.cropObj = {status: false};
        $scope.initCrop = function () {
            const canvas = $scope.getCurrentStageCanvas();
            let activeObject = $scope.getActiveObject(canvas);
            if (!activeObject) {
                return;
            }
            if (activeObject.type !== 'image') {
                return;
            }
            if (activeObject.maskId) {
                $scope.initCropOld();
                return;
            }
            if (activeObject.crop) {
                $scope.handleInitCropWithOriginSrc();
            } else {
                $scope.handleInitCrop();
            }
        }
        $scope.removeImageBackground = function () {
            const canvas = $scope.getCurrentStageCanvas();
            const activeObject = canvas.getActiveObject();
            if (!activeObject && activeObject.type !== 'image') {
                return;
            }
            $scope.toggleStageLoading();
            NBDDataFactory.get('nbd_remove_image_background', {url: activeObject.getSrc()}, function (response) {
                if (response) {
                    const data = JSON.parse(response);
                    if (data.error != undefined) {
                        // your code for notifying user he ran out of clicks
                        alert('You have reached your Background Removal credit limit for this month. Please contact our support if you require additional assistance or need more credits. You can track your limit on your account page.');
                        $scope.toggleStageLoading();
                        return;
                    }
                    NBDDataFactory.get('nbdesigner_copy_image_from_url', {url: data.output_image_url}, function (uploaded) {
                        const uploadedData = JSON.parse(uploaded);
                        if (uploadedData.flag) {
                            $scope.replaceImage(uploadedData.src);
                        }
                        $scope.toggleStageLoading();
                    });
                } else {
                    $scope.toggleStageLoading();
                }
            });
        }

        $scope.handleInitCrop = function () {
            const canvas = $scope.getCurrentStageCanvas();
            let activeObject = $scope.getActiveObject(canvas);
            const cropBeforeCropInit = activeObject.get('crop') || {};
            activeObject.set({
                ignoreDeselect: false
            });
            $scope.contextAddLayers = 'template';
            canvas.set({
                uniScaleTransform: true
            });
            const rect = $scope.constructCroppingRect(activeObject);
            rect.on('scaling', (e) => {
                $scope.onImageCropScaling(e.target, activeObject)
            });
            rect.on('moving', (e) => {
                $scope.onImageCropMoving(e.target, activeObject);
            });

            rect.on('deselected', () => {
                if (!activeObject.get('ignoreDeselect')) {
                    $scope.finishCrop(rect);
                } else {
                    activeObject.set({
                        crop: cropBeforeCropInit
                    });
                    activeObject.setCoords();
                    canvas.remove(rect);
                    canvas.renderAll();
                    $scope.updateLayersList();
                    $scope.getCurrentStage()
                        .states.isImageCropper = false;
                }
                canvas.set({
                    uniScaleTransform: false
                });
            });
            canvas.add(rect);
            canvas.setActiveObject(rect);
            $scope.getCurrentStage()
                .states.opacity = fabric.util.toFixed(activeObject.get('opacity') * 100);
        }

        $scope.handleInitCropWithOriginSrc = function () {
            const canvas = $scope.getCurrentStageCanvas();
            let activeObject = $scope.getActiveObject(canvas);
            activeObject.set({
                ignoreDeselect: false
            });
            const cropBeforeCropInit = activeObject.get('crop') || {};
            $scope.contextAddLayers = 'template';
            const currentWidth = activeObject.width;
            const currentHeight = activeObject.height;
            const {width: originalWidth, height: originalHeight} = activeObject.getOriginalSize();
            activeObject.set({
                dirty: true,
                crop: {},
                width: originalWidth,
                height: originalHeight
            });
            canvas.set({
                uniScaleTransform: true
            });
            activeObject.setCoords();
            const rect = $scope.constructCroppingRect(activeObject);
            rect.on('scaling', (e) => {
                $scope.onImageCropScaling(e.target, activeObject)
            });
            rect.on('moving', (e) => {
                $scope.onImageCropMoving(e.target, activeObject);
            });
            rect.on('deselected', () => {
                if (!activeObject.get('ignoreDeselect')) {
                    $scope.finishCrop(rect);
                } else {
                    activeObject.set({
                        crop: cropBeforeCropInit,
                        width: currentWidth,
                        height: currentHeight
                    });
                    activeObject.setCoords();
                    canvas.remove(rect);
                    canvas.renderAll();
                    $scope.updateLayersList();
                    $scope.getCurrentStage()
                        .states.isImageCropper = false;
                }
                canvas.set({
                    uniScaleTransform: false
                });
            });
            canvas.add(rect);
            canvas.setActiveObject(rect);
            $scope.getCurrentStage()
                .states.opacity = fabric.util.toFixed(activeObject.get('opacity') * 100);
        }
        $scope.constructCroppingRect = function (activeObject) {
            return new fabric.Rect({
                originX: activeObject.originX,
                originY: activeObject.originY,
                width: activeObject.getScaledWidth(),
                height: activeObject.getScaledHeight(),
                top: activeObject.top,
                left: activeObject.left,
                fill: 'rgba(255,255,255,0.15)',
                cornerStyle: 'circle',
                cornerStrokeColor: 'white',
                cornerSize: 10,
                borderColor: '#0070F0',
                borderOpacityWhenMoving: 1,
                borderDashArray: [1, 0],
                hasRotatingPoint: false,
                lockRotation: true,
                lastGoodTop: activeObject.top,
                lastGoodLeft: activeObject.left,
                isImageCropper: true,
                lockScalingFlip: true,
                imageId: activeObject.itemId,
                strokeWidth: 0,
            });
        }
        $scope.onImageCropMoving = function (rect, target) {
            const bounding = rect.getBoundingRect(true);
            const boundingTarget = target.getBoundingRect(true);
            if (bounding.left < boundingTarget.left) {
                rect.set({
                    left: boundingTarget.left + bounding.width / 2
                });
            }
            ;
            if (bounding.left + bounding.width > boundingTarget.left + boundingTarget.width) {
                rect.set({
                    left: bounding.left - ((bounding.left + bounding.width) - (boundingTarget.left + boundingTarget.width)) + bounding.width / 2
                });
            }
            ;
            if (bounding.top < boundingTarget.top) {
                rect.set({
                    top: boundingTarget.top + bounding.height / 2
                });
            }
            ;
            if (bounding.top + bounding.height > boundingTarget.top + boundingTarget.height) {
                rect.set({
                    top: bounding.top - ((bounding.top + bounding.height) - (boundingTarget.top + boundingTarget.height)) + bounding.height / 2
                });
            }
            ;
        }
        $scope.onImageCropScaling = function (rect) {
            if (rect.scaleX > 1) {
                rect.scaleX = 1;
                rect.left = rect.lastGoodLeft;
                rect.top = rect.lastGoodTop;
            }
            if (rect.scaleY > 1) {
                rect.scaleY = 1;
                rect.left = rect.lastGoodLeft;
                rect.top = rect.lastGoodTop;
            }
            rect.lastGoodTop = rect.top;
            rect.lastGoodLeft = rect.left;
        }

        $scope.finishCrop = function (rect) {
            $scope.cropImageNew(rect);
        }

        $scope.finishCropFromToolbar = function () {
            const canvas = $scope.getCurrentStageCanvas();
            const activeObject = $scope.getActiveObject(canvas);
            const imageIndex = $scope.getLayerById(activeObject.imageId);
            const image = canvas.item(imageIndex);
            if (imageIndex === undefined || !image) {
                return;
            }
            image.set({
                ignoreDeselect: false
            });
            canvas.discardActiveObject();
        }

        $scope.cancelCropFromToolbar = function () {
            const canvas = $scope.getCurrentStageCanvas();
            const activeObject = $scope.getActiveObject(canvas);
            const imageIndex = $scope.getLayerById(activeObject.imageId);
            const image = canvas.item(imageIndex);
            if (imageIndex === undefined || !image) {
                return;
            }
            image.set({
                ignoreDeselect: true
            });
            canvas.discardActiveObject();
        }

        $scope.initCropOld = function () {
            const canvas = $scope.getCurrentStageCanvas();
            let activeObject = $scope.getActiveObject(canvas);
            if (activeObject.type !== 'image') {
                return;
            }
            if (activeObject.maskId) {
                $scope.initCropOld();
                return;
            }
            if (activeObject.origin_src) {
                $scope.handleInitCropWithOriginSrc();
            } else {
                $scope.handleInitCrop();
            }
        }
        $scope.initCropOld = function () {
            $scope.cropObj.status = true;
            jQuery('.nbd-popup.popup-nbd-crop').nbShowPopup();
            $scope.cropObj.src = $scope.stages[$scope.currentStage].states.origin_src;
            $scope.cropObj.origin_url = $scope.stages[$scope.currentStage].states.origin_url;
            jQuery('.nbd-popup.popup-nbd-crop .overlay-popup').addClass('nbo-disable');
            jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
            var img = new Image();
            img.src = $scope.cropObj.src;
            img.onload = function () {
                $scope.cropObj.width = this.width;
                $scope.cropObj.height = this.height;
                if ($scope.stages[$scope.currentStage].states.origin_width) {
                    $scope.cropObj.width = $scope.stages[$scope.currentStage].states.origin_width;
                    $scope.cropObj.height = $scope.stages[$scope.currentStage].states.origin_height;
                }
                $timeout(function () {
                    $scope.cropObj.canvas = $scope.cropObj.canvas ? $scope.cropObj.canvas : new FabricWindow.Canvas('crop-handle-wrap');
                    var width = jQuery('#crop-source').width(),
                        height = jQuery('#crop-source').height();
                    $scope.cropObj.canvas.setDimensions({'width': width, 'height': height});
                    $scope.cropObj.canvas.clear();
                    $scope.cropObj.canvas.on('mouse:down', function (e) {
                        $scope.cropObj.canvas.item(0);
                    });
                    $scope.cropObj.canvas.on('object:modified', function (options) {
                        var obj = options.target;
                        var boundingRect = obj.getBoundingRect(true);
                        if (boundingRect.left < 0) obj.left = 0;
                        if (boundingRect.top < 0) obj.top = 0;
                        obj.setCoords();
                        boundingRect = obj.getBoundingRect(true);
                        var left = boundingRect.left > 0 ? boundingRect.left : 0,
                            top = boundingRect.top > 0 ? boundingRect.top : 0;
                        if (boundingRect.left + boundingRect.width > $scope.cropObj.canvas.getWidth()) {
                            obj.scaleX = obj.scaleX * (($scope.cropObj.canvas.getWidth() - left) / boundingRect.width);
                        }
                        if (boundingRect.top + boundingRect.height > $scope.cropObj.canvas.getHeight()) {
                            obj.scaleY = obj.scaleY * (($scope.cropObj.canvas.getHeight() - top) / boundingRect.height);
                        }
                        ;
                        obj.setCoords();
                    });
                    var rect = new fabric.Rect({
                        left: 0,
                        top: 0,
                        fill: 'rgba(255,255,255,0.0)',
                        width: 200,
                        height: 200,
                        strokeWidth: 1,
                        stroke: '#ffffff',
                        strokeDashArray: [1, 1]
                    });
                    $scope.cropObj.canvas.add(rect);
                    var item = $scope.cropObj.canvas.item(0);
                    item.setControlVisible('mtr', false);
                    $scope.cropObj.canvas.setActiveObject(item);
                    if (angular.isUndefined($scope.stages[$scope.currentStage].states.crop_left)) {
                        $scope.cropObj.canvas.viewportCenterObject(item);
                    }
                }, 100);
            };
        };
        $scope.cancelCrop = function () {
            jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
            jQuery('.nbd-popup.popup-nbd-crop .close-popup').triggerHandler('click');
        };
        $scope.cropImage = function () {
            function _cropImage(img, bounds) {
                img.set('crop', {
                    x: bounds.left,
                    y: bounds.top,
                    width: bounds.width,
                    height: bounds.height
                });
                img.set({
                    ignoreDeselect: false,
                    dirty: true,
                });
                canvas.renderAll();
                $scope.updateLayersList();
                $scope.getCurrentStage()
                    .states.isImageCropper = false;
                jQuery('.nbd-popup.popup-nbd-crop').find('.overlay-main').removeClass('active');
                jQuery('.nbd-popup.popup-nbd-crop .close-popup').triggerHandler('click');
            }

            const stage = $scope.stages[$scope.currentStage],
                canvas = stage['canvas'];
            const image = canvas.getActiveObject();
            const bound = $scope.cropObj.canvas.item(0).getBoundingRect(true),
                imgScale = $scope.cropObj.width / $scope.cropObj.canvas.width;
            $scope.cropObj.bound = {
                left: $scope.cropObj.canvas.item(0).get('left'),
                top: $scope.cropObj.canvas.item(0).get('top'),
                width: $scope.cropObj.canvas.item(0).get('width'),
                height: $scope.cropObj.canvas.item(0).get('height'),
                scaleX: $scope.cropObj.canvas.item(0).get('scaleX'),
                scaleY: $scope.cropObj.canvas.item(0).get('scaleY')
            };
            const bounds = {
                left: bound.left * imgScale,
                top: bound.top * imgScale,
                width: bound.width * imgScale,
                height: bound.height * imgScale
            };
            _cropImage(image, bounds);
        };

        $scope.cropImageNew = function (_rect) {
            function cropImage(img) {
                img.set('crop', {
                    x: bounds.left,
                    y: bounds.top,
                    width: bounds.width,
                    height: bounds.height
                });
                img.set({
                    ignoreDeselect: false,
                    dirty: true,
                    width: bounds.width,
                    height: bounds.height
                });
                canvas.remove(rect);
                canvas.renderAll();
                $scope.updateLayersList();
                $scope.getCurrentStage()
                    .states.isImageCropper = false;
            }

            function add_image(url, originalUrl) {
                const _canvas = $scope.getCurrentStageCanvas();
                var object = _canvas.getActiveObject();
                object.setSrc(url, () => {
                    object.set({
                        ignoreDeselect: false
                    });
                    $scope.cropObj.bound = {};
                    _canvas.getActiveObject().set({
                        dirty: true,
                    });
                    canvas.remove(rect);
                    _canvas.renderAll();
                    $scope.updateLayersList();
                    $scope.getCurrentStage()
                        .states.isImageCropper = false;
                    $scope.toggleStageLoading();
                }, {crossOrigin: 'anonymous'});
            }

            const canvas = $scope.getCurrentStageCanvas();
            const rect = _rect || $scope.getActiveObject(canvas);
            const imageIndex = $scope.getLayerById(rect.imageId);
            const image = canvas.item(imageIndex);
            if (imageIndex === undefined || !image) {
                canvas.remove(rect);
                canvas.renderAll();
                $scope.updateLayersList();
                $scope.getCurrentStage()
                    .states.isImageCropper = false;
                return;
            }
            const rectBounds = rect.getBoundingRect(true);
            const imageBounds = image.getBoundingRect(true);
            const bounds = {
                top: Math.max(0, rectBounds.top - imageBounds.top) / image.scaleY,
                left: Math.max(0, rectBounds.left - imageBounds.left) / image.scaleX,
                width: Math.min(image.width, rectBounds.width / image.scaleX),
                height: Math.min(image.height, rectBounds.height / image.scaleY),
            };
            const src = image.getSrc();
            const isBase64Like = $scope.isBase64Like(src);
            if (!isBase64Like) {
                cropImage(image);
            } else {
                $scope.toggleStageLoading();
                const croppedBase64 = $scope.cropBase64Image(image, bounds);
                canvas.setActiveObject(image);
                add_image(croppedBase64, src);
            }
        };
        $scope.isBase64Like = function (str) {
            return str.startsWith("data:");
        }
        $scope.cropBase64Image = function (image, bounds) {
            if (!image) {
                return null;
            }
            return image.toDataURL({
                left: bounds.left,
                top: bounds.top,
                width: bounds.width,
                height: bounds.height,
                withoutTransform: true
            });
        }
        $scope.addMask = function (shapeIndex) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                max_width = _canvas.width / scale * .3,
                max_height = _canvas.height / scale * .3,
                new_width = max_width;
            var pathCommand = shapeIndex > -1 ? $scope.masks[shapeIndex] : $scope.pathCommand;
            if (pathCommand == '') return;

            var path = new fabric.Path(pathCommand);
            var width_ratio = new_width / path.width,
                new_height = path.height * width_ratio;
            if (new_height > max_height) {
                new_height = max_height;
                var height_ratio = new_height / path.height;
                new_width = path.width * height_ratio;
            }
            path.scaleToWidth(new_width);
            path.scaleToHeight(new_height);
            path.set({
                isTemMask: true,
                fill: '#dddddd'
            });
            _canvas.add(path);
        };
        $scope.addPhotoFrame = function (frame) {
            var url = '//dpeuzbvf3y4lr.cloudfront.net/frames/svg/s' + (frame + 1) + '.svg',
                defaultImageUrl = NBDESIGNCONFIG.assets_url + 'images/frame-bg.jpg',
                stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                max_width = _canvas.width / scale * .3,
                max_height = _canvas.height / scale * .3,
                new_width = max_width;

            $scope.toggleStageLoading();

            function onFail() {
                $scope.toggleStageLoading();
            }

            fabric.loadSVGFromURL(url, function (ob, op) {
                if (ob) {
                    $scope.contextAddLayers = 'addMask';
                    var d = new Date(),
                        itemId = d.getTime() + Math.floor(Math.random() * 1000);

                    if (op.width < max_width) new_width = op.width;
                    var width_ratio = new_width / op.width,
                        new_height = op.height * width_ratio;
                    if (new_height > max_height) {
                        new_height = max_height;
                        var height_ratio = new_height / op.height;
                        new_width = op.width * height_ratio;
                    }
                    var object = fabric.util.groupSVGElements(ob, op);
                    object.scaleToWidth(new_width);
                    object.scaleToHeight(new_height);

                    object.set({
                        itemId: itemId,
                        isMask: 1,
                        absolutePositioned: true,
                        strokeWidth: 0,
                        lockRotation: true,
                        selectable: false,
                        fill: '#ffffff',
                        opacity: 0.001
                    });

                    _canvas.add(object);

                    $timeout(function () {
                        $scope.contextAddLayers = 'addMask';
                        var maskLayer = _canvas.item(_canvas.getObjects().length - 1);
                        _canvas.viewportCenterObject(maskLayer);
                        fabric.Image.fromURL(defaultImageUrl, function (op) {
                            var top = maskLayer.get('top'),
                                left = maskLayer.get('left'),
                                scaleX = maskLayer.get('scaleX'),
                                scaleY = maskLayer.get('scaleY'),
                                width = maskLayer.get('width'),
                                height = maskLayer.get('height'),
                                realWidth = width * scaleX,
                                realHeight = height * scaleY,
                                newWidth = realWidth,
                                newHeight = realHeight;
                            if ((op.width / op.height) > (realWidth / realHeight)) {
                                newWidth = op.width / op.height * newHeight;
                            } else {
                                newHeight = op.height / op.width * newWidth;
                            }
                            op.set({
                                clipPath: maskLayer,
                                perPixelTargetFind: true,
                                centeredScaling: true,
                                maskId: itemId,
                                scaleX: newWidth / op.width,
                                scaleY: newHeight / op.height,
                                top: top + realHeight / 2,
                                left: left + realWidth / 2,
                                isEmptyMask: true,
                                srcChanged: false
                            });
                            _canvas.add(op);
                            $scope.toggleStageLoading();
                        });
                    }, 100);
                } else {
                    onFail();
                }
            });
        };
        $scope.addFrame = function (frame) {
            var rows = frame.areas.match(/[^"]+(?=(" ")|"$)/g),
                numCols = rows[0].split(" ").length,
                numRows = rows.length,
                colWidths = [],
                rowHeights = [];
            if (frame.columns != '') {
                colWidths = frame.columns.replace(/fr/g, '').split(" ").map(function (col) {
                    return 1 * col;
                });
            } else {
                for (var i = 0; i < numCols; i++) {
                    colWidths.push(1);
                }
                ;
            }
            if (frame.rows != '') {
                rowHeights = frame.rows.replace(/fr/g, '').split(" ").map(function (col) {
                    return 1 * col;
                });
            } else {
                rows.forEach(function () {
                    rowHeights.push(1);
                });
            }
            var totalWidth = colWidths.reduce((accumulator, currentValue, currentIndex, array) => {
                return accumulator + currentValue;
            });
            var totalHeight = rowHeights.reduce((accumulator, currentValue, currentIndex, array) => {
                return accumulator + currentValue;
            });
            var panels = {};
            rows.forEach(function (row, idx) {
                var rowArr = row.split(" ");
                rowArr.forEach(function (r, i) {
                    if (typeof panels[r] == 'undefined') {
                        panels[r] = {
                            x: i,
                            y: idx,
                            colWidth: colWidths[i],
                            rowHeight: rowHeights[idx],
                            rows: [idx],
                            columns: [i]
                        };
                    } else {
                        if (panels[r].rows.indexOf(idx) == -1) {
                            panels[r].rowHeight += rowHeights[idx];
                            panels[r].rows.push(idx);
                        }
                        if (panels[r].columns.indexOf(i) == -1) {
                            panels[r].colWidth += colWidths[i];
                            panels[r].columns.push(i);
                        }
                    }
                });
            });
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                gap = 2,
                cellWidth = (_canvas.width - gap * (totalWidth - 1)) / totalWidth,
                cellHeight = (_canvas.height - gap * (totalHeight - 1)) / totalHeight;
            var url = NBDESIGNCONFIG.assets_url + 'images/frame-bg.jpg';
            angular.forEach(panels, function (panel, key) {
                $scope.contextAddLayers = 'addMask';
                var d = new Date(),
                    itemId = d.getTime() + Math.floor(Math.random() * 1000);
                var colLeft = 0, rowTop = 0;
                for (var i = 0; i < colWidths.length; i++) {
                    if (i < panel.x) {
                        colLeft += colWidths[i];
                    }
                }
                for (var i = 0; i < rowHeights.length; i++) {
                    if (i < panel.y) {
                        rowTop += rowHeights[i];
                    }
                }
                var path = new fabric.Path($scope.masks[15]);
                path.set({
                    top: rowTop * (cellHeight + gap),
                    left: colLeft * (cellWidth + gap),
                    scaleX: (panel.colWidth * cellWidth + (panel.colWidth - 1) * gap) / path.get('width'),
                    scaleY: (panel.rowHeight * cellHeight + (panel.rowHeight - 1) * gap) / path.get('height'),
                    isMask: 1,
                    itemId: itemId,
                    absolutePositioned: true,
                    strokeWidth: 0,
                    lockRotation: true,
                    selectable: false,
                    fill: '#ffffff',
                    opacity: 0.001
                });
                panel.itemId = itemId;
                _canvas.add(path);
            });
            angular.forEach(panels, function (panel, key) {
                fabric.Image.fromURL(url, function (op) {
                    $scope.contextAddLayers = 'addMask';
                    var mask = $scope.getMaskLayer(panel.itemId),
                        top = mask.get('top'),
                        left = mask.get('left'),
                        scaleX = mask.get('scaleX'),
                        scaleY = mask.get('scaleY'),
                        width = mask.get('width'),
                        height = mask.get('height'),
                        realWidth = width * scaleX,
                        realHeight = height * scaleY,
                        newWidth = realWidth,
                        newHeight = realHeight;
                    if ((op.width / op.height) > (realWidth / realHeight)) {
                        newWidth = op.width / op.height * newHeight;
                    } else {
                        newHeight = op.height / op.width * newWidth;
                    }
                    var d = new Date(),
                        itemId = d.getTime() + Math.floor(Math.random() * 1000);
                    op.set({
                        clipPath: mask,
                        perPixelTargetFind: true,
                        centeredScaling: true,
                        maskId: panel.itemId,
                        scaleX: newWidth / op.width,
                        scaleY: newHeight / op.height,
                        top: top + realHeight / 2,
                        left: left + realWidth / 2,
                        itemId: itemId,
                        isEmptyMask: true,
                        srcChanged: false
                    });
                    _canvas.add(op);
                }, {crossOrigin: 'anonymous'});
            });
        };
        $scope.addImageFilter = function (type) {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            var object = _canvas.getActiveObject();
            if (object && (object.type == 'image' || object.type == 'custom-image')) {
                var filter = new fabric.Image.filters.CustomFilter({
                    jOptions: '{"type":"' + type + '"}'
                });

                var index;
                object.filters.forEach(function (filter, _index) {
                    var options = JSON.parse(filter.jOptions);
                    if (options.type == type) index = _index;
                });
                if (angular.isDefined(index)) {
                    /*
                    //to modify filter
                    object.filters[index] = filter;
                */
                    object.filters.splice(index, 1);
                    $scope.stages[$scope.currentStage].states.filters[type] = false;
                } else {
                    object.filters.push(filter);
                    $scope.stages[$scope.currentStage].states.filters[type] = true;
                }

                object.applyFilters(false, function () {
                    setTimeout(() => $scope.renderStage());
                });
            }
        };
        $scope.removeImageFilter = function (type) {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            var object = _canvas.getActiveObject();
            if (object && (object.type == 'image' || object.type == 'custom-image')) {
                var index;
                object.filters.forEach(function (filter, _index) {
                    var options = JSON.parse(filter.jOptions);
                    if (options.type == type) index = _index;
                });
                if (angular.isDefined(index)) {
                    object.filters.splice(index, 1);
                    object.applyFilters(false, function () {
                        setTimeout(() => $scope.renderStage());
                    });
                }
                $scope.stages[$scope.currentStage].states.filters[type] = false;
            }
        };
        $scope.checkActiveFilter = function (type, filters) {
            var index;
            filters.forEach(function (filter, _index) {
                var options = JSON.parse(filter.jOptions);
                if (options.type == type) index = _index;
            });
            if (angular.isDefined(index)) {
                return true;
            }
            return false;
        };
        $scope.removeImageFilters = function () {
            var _canvas = $scope.stages[$scope.currentStage]['canvas'];
            var object = _canvas.getActiveObject();
            if (object && (object.type == 'image' || object.type == 'custom-image')) {
                object.filters = [];
                object.applyFilters(false, function () {
                    setTimeout(() => $scope.renderStage());
                });
                $scope.stages[$scope.currentStage].states.filters = [];
            }
        };
        $scope.addSvgFromBlob = function () {
            const svg = document.querySelector('#blobid34');
            if (!svg) {
                return;
            }
            const svgXml = new XMLSerializer();
            const svgString = svgXml.serializeToString(svg);
            $scope.addSvgFromString(svgString);
        }
        $scope.addSvgFromWave = function () {
            const svg = document.querySelector('#wave-container svg'); // Select the wave SVG inside the container
            if (!svg) {
                return;
            }
            const svgXml = new XMLSerializer();
            const svgString = svgXml.serializeToString(svg);
            $scope.addSvgFromString(svgString);
        }
        $scope.addYoutubeThumbnail = function () {
            const thumbnail = document.querySelector('#youtube-thumbnail');
            if (!thumbnail) {
                return;
            }
            $scope.addImageFromUrl(thumbnail.getAttribute('src'));
        }
        $scope.addAIAvatar = function () {
            const aiavatar = document.querySelector('#ai-person-placeholder');
            if (!aiavatar) {
                return;
            }
            $scope.addImageFromUrl(thumbnail.getAttribute('src'));
        }
        /* SVG */
        $scope.addSvgFromString = function (svg, showLoading) {
            if (angular.isUndefined(showLoading)) $scope.toggleStageLoading();
            fabric.loadSVGFromString(svg, function (ob, op) {
                $scope._addSvg(ob, op, {name: ''}, true);
            });
        };
        $scope.addSvgFromMedia = function (art, $index) {
            if (angular.isDefined($index) && $scope.settings.valid_license == '0' && $index > 19) {
                alert($scope.settings.nbdlangs.pro_license_alert);
                return;
            }
            $scope.showDesignTab();
            $scope.toggleStageLoading();
            $http({
                method: 'GET',
                url: appConfig.mediaUrl + '/clipart?get_svg=' + art.url.replace("//dpeuzbvf3y4lr.cloudfront.net/", "")
            }).then(function successCallback(response) {
                var svg = response.data.data;
                if (!svg) {
                    $scope.toggleStageLoading();
                    return;
                }
                $scope.addSvgFromString(svg, false);
            }, function errorCallback(response) {
                console.log('Fail to load: svg');
            });
        };
        $scope.addSvgRepoArt = function (art, showLoading, hideLoading) {
            art.url = `${art.url}?fetch=true`;
            $scope.addArt(art, showLoading, hideLoading);
        }
        $scope.addArt = function (art, showLoading, hideLoading) {
            if (showLoading) $scope.toggleStageLoading();
            if (art.url.match(/\.(jpeg|jpg|gif|png)$/) != null) {
                $scope.addImage(art.url, false, hideLoading);
            } else {
                fabric.loadSVGFromURL(art.url, function (ob, op) {
                    if (ob) {
                        $scope._addSvg(ob, op, art, hideLoading);
                    } else {
                        alert('Try again!');
                        $scope.toggleStageLoading();
                    }
                });
            }
        };

        $scope.addAIAvatar = function (e) {
            const url = e.target.getAttribute('data-url');
            if (!url || !e) {
                return;
            }
            $scope.addImageFromUrl(url);
        };

        $scope.addIconfinderIcon = function (art, showLoading, hideLoading) {
            if (showLoading) $scope.toggleStageLoading();
            NBDDataFactory.get('nbd_get_iconfinder_icon', {url: art.url}, function (response) {
                const data = JSON.parse(response);
                if (data) {
                    fabric.loadSVGFromURL(data.url, function (ob, op) {
                        if (ob) {
                            $scope._addSvg(ob, op, art, hideLoading);
                        } else {
                            alert('Try again!');
                            $scope.toggleStageLoading();
                        }
                    });
                }
            });
        };

        $scope.addArtFromComponent = function ($art, $showLoading, $hideLoading, $addAsBackground) {
            if ($addAsBackground) {
                $scope.setCanvasBGimage($art.url);
            } else {
                $scope.addArt($art, $showLoading, $hideLoading);
            }
        }
        $scope.addOverlayFromComponent = function (overlay, showLoading, hideLoading, e, addAsBackground) {
            if (addAsBackground) {
                $scope.setCanvasBGimage(overlay.url);
            } else {
                $scope.addOverlayNew(overlay, showLoading, hideLoading, e);
            }
        }
        $scope._addSvg = function (ob, op, art, hideLoading) {
            var stage = $scope.stages[$scope.currentStage],
                _canvas = stage['canvas'],
                scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                max_width = _canvas.width / scale * .9,
                max_height = _canvas.height / scale * .9,
                new_width = max_width;

            if (op.width < max_width) new_width = op.width;
            var width_ratio = new_width / op.width,
                new_height = op.height * width_ratio;
            if (new_height > max_height) {
                new_height = max_height;
                var height_ratio = new_height / op.height;
                new_width = op.width * height_ratio;
            }
            var object = fabric.util.groupSVGElements(ob, op);
            object.scaleToWidth(new_width);
            object.scaleToHeight(new_height);
            if (angular.isDefined(art.type) && art.type == 'qrcode') {
                object.set({qrContent: art.qrContent, isQrcode: 1});
            } else if (angular.isDefined(art.type) && art.type == 'barcode') {
                object.set({barCodeContent: art.barCodeContent, isBarcode: 1});
            }
            _canvas.add(object);
            if (hideLoading) $scope.toggleStageLoading();
        };
        $scope.addQrCode = function () {
            /* var qr = qrcode(4, 'L', NBDESIGNCONFIG.nbdesigner_default_color); */
            var qr = qrcode(0, 'M', NBDESIGNCONFIG.nbdesigner_default_color);
            qr.addData($scope.resource.qrText);
            qr.make();
            var _qrcode = qr.createSvgTag();
            fabric.loadSVGFromString(_qrcode, function (ob, op) {
                $scope._addSvg(ob, op, {name: '', type: 'qrcode', qrContent: $scope.resource.qrText}, false);
            });
            jQuery('#barcode').html('');
            jQuery('.main-qrcode').html('').append(_qrcode);
        };
        $scope.updateQrCode = function () {
            var _stage = this.stages[this.currentStage],
                _canvas = _stage.canvas,
                obj = _canvas.getActiveObject();
            if (!obj) return;
            var qr = qrcode(4, 'L', NBDESIGNCONFIG.nbdesigner_default_color),
                content = $scope.stages[$scope.currentStage].states.qrContent;
            qr.addData(content);
            qr.make();
            var _qrcode = qr.createSvgTag();
            fabric.loadSVGFromString(_qrcode, function (ob, op) {
                var object = fabric.util.groupSVGElements(ob, op);
                obj.set({
                    dirty: true,
                    qrContent: content,
                    path: object.path
                });
                $scope.renderStage();
            });
        };
        $scope.addBarCode = function () {
            jQuery('.main-qrcode').html('');
            JsBarcode("#barcode", $scope.resource.qrText, {
                font: NBDESIGNCONFIG.default_font.alias,
                lineColor: NBDESIGNCONFIG.nbdesigner_default_color
            });
            $timeout(function () {
                fabric.loadSVGFromString(jQuery('#barcode').wrap('<div/>').parent().html(), function (ob, op) {
                    $scope._addSvg(ob, op, {name: '', barCodeContent: $scope.resource.qrText, type: 'barcode'}, false);
                    jQuery('#barcode').unwrap();
                });
            });
        };
        $scope.updateBarCode = function () {
            var _stage = this.stages[this.currentStage],
                _canvas = _stage.canvas,
                obj = _canvas.getActiveObject();
            if (!obj) return;
            var content = $scope.stages[$scope.currentStage].states.barCodeContent;
            jQuery('.main-qrcode').html('');
            JsBarcode("#barcode", content, {
                font: NBDESIGNCONFIG.default_font.alias,
                lineColor: NBDESIGNCONFIG.nbdesigner_default_color
            });
            $timeout(function () {
                fabric.loadSVGFromString(jQuery('#barcode').wrap('<div/>').parent().html(), function (ob, op) {
                    var object = fabric.util.groupSVGElements(ob, op);
                    object.set({
                        originX: 'center',
                        originY: 'center'
                    });
                    obj.set({
                        dirty: true,
                        width: object.width,
                        barCodeContent: content,
                        _objects: object._objects
                    });
                    obj.setCoords();
                    $scope.renderStage();
                    jQuery('#barcode').unwrap();
                });
            });
        };
        $scope.mapLayerWith = function (key) {
            var _stage = this.stages[this.currentStage],
                _canvas = _stage.canvas,
                obj = _canvas.getActiveObject();
            if (!obj) return;
            if (angular.isDefined(obj.field_mapping) && obj.field_mapping == key) {
                delete obj.field_mapping;
                delete $scope.stages[$scope.currentStage].states.field_mapping;
            } else {
                obj.set({field_mapping: key});
                $scope.stages[$scope.currentStage].states.field_mapping = key;
            }
            jQuery('.second-contexts').addClass('deactive');
        };
        $scope.generateVcard = function (callback) {
            var strVcard = '';

            function getFieldValue(fieldKey) {
                var value = '';
                _.each($scope.settings.vcard_fields, function (field, index) {
                    if (field.key == fieldKey) value = field.value;
                });
                return value;
            }

            strVcard += 'BEGIN:VCARD\nVERSION:3.0\n';
            strVcard += 'N:' + getFieldValue('last_name') + ';' + getFieldValue('first_name') + '\n' + 'FN:' + getFieldValue('first_name') + ' ' + getFieldValue('last_name');
            strVcard += '\nADR;TYPE=home:;;' + getFieldValue('address') + ';' + getFieldValue('city') + ';;' + getFieldValue('postcode') + ';' + getFieldValue('country');
            strVcard += '\nTEL;TYPE=home:' + getFieldValue('phone');
            strVcard += '\nTEL;TYPE=work:' + getFieldValue('mobile');
            strVcard += '\nEMAIL;TYPE=internet,work:' + getFieldValue('email');
            strVcard += '\nURL;TYPE=work:' + getFieldValue('website');
            strVcard += '\nEND:VCARD';
            var qr = qrcode('0', 'M', NBDESIGNCONFIG.nbdesigner_default_color);
            qr.addData(strVcard);
            qr.make();
            var _qrcode = qr.createSvgTag();
            fabric.loadSVGFromString(_qrcode, function (ob, op) {
                var object = fabric.util.groupSVGElements(ob, op);
                if (typeof callback == 'function') {
                    callback(object);
                } else {
                    var stage = $scope.stages[$scope.currentStage],
                        _canvas = stage['canvas'],
                        scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio,
                        max_width = _canvas.width / scale * .9,
                        max_height = _canvas.height / scale * .9,
                        new_width = max_width;
                    if (op.width < max_width) new_width = op.width;
                    var width_ratio = new_width / op.width,
                        new_height = op.height * width_ratio;
                    if (new_height > max_height) {
                        new_height = max_height;
                        var height_ratio = new_height / op.height;
                        new_width = op.width * height_ratio;
                    }
                    object.scaleToWidth(new_width);
                    object.scaleToHeight(new_height);
                    object.v_card = 1;
                    _canvas.add(object);
                }
            });
        };
        $scope.updateTemplate = function () {
            $scope.clearAllStage();
            $scope.insertTemplate(false, {id: $scope.currentLocalTempId});
        };


        $scope.scrollTemplatesTagsRight = function (selector) {
            const wrapper = document.querySelector(`${selector}`);
            const activeItem = document.querySelector(`${selector} .template-tag__template--active`);
            const nextItem = activeItem && activeItem.nextElementSibling;
            const leftArrow = wrapper.parentElement.querySelector(`.template-tag__templates-arrow--left`);
            const rightArrow = wrapper.parentElement.querySelector(`.template-tag__templates-arrow--right`);
            if (!activeItem || !nextItem) {
                return;
            }
            if (nextItem.nextElementSibling) {
                rightArrow.style.display = 'block';
            } else {
                rightArrow.style.display = 'none';
            }
            leftArrow.style.display = 'block';
            if (isInView(nextItem, wrapper) && nextItem.nextElementSibling) {
                nextItem.nextElementSibling.scrollIntoView({inline: 'nearest', block: 'nearest', behavior: 'smooth'});
                activeItem.classList.remove('template-tag__template--active');
                nextItem.nextElementSibling.classList.add('template-tag__template--active');
                if (nextItem.nextElementSibling && nextItem.nextElementSibling.nextElementSibling) {
                    rightArrow.style.display = 'block';
                } else {
                    rightArrow.style.display = 'none';
                }
                return;
            }
            nextItem.scrollIntoView({inline: 'nearest', behavior: 'smooth', block: 'nearest'});
            activeItem.classList.remove('template-tag__template--active');
            nextItem.classList.add('template-tag__template--active');
            if (!nextItem.nextElementSibling) {
                const previous = nextItem.previousElementSibling;
                nextItem.classList.remove('template-tag__template--active');
                previous.classList.add('template-tag__template--active');
            }
        };

        $scope.scrollTemplatesTagsLeft = function (selector) {
            const wrapper = document.querySelector(`${selector}`);
            const activeItem = document.querySelector(`${selector} .template-tag__template--active`);
            const previousItem = activeItem && activeItem.previousElementSibling;
            const leftArrow = wrapper.parentElement.querySelector(`.template-tag__templates-arrow--left`);
            const rightArrow = wrapper.parentElement.querySelector(`.template-tag__templates-arrow--right`);
            if (!activeItem || !previousItem) {
                return;
            }
            if (previousItem.previousElementSibling) {
                leftArrow.style.display = 'block';
            } else {
                leftArrow.style.display = 'none';
            }
            rightArrow.style.display = 'block';
            if (isInView(previousItem, wrapper) && previousItem.previousElementSibling) {
                previousItem.previousElementSibling.scrollIntoView({
                    inline: 'nearest',
                    behavior: 'smooth',
                    block: 'nearest'
                });
                activeItem.classList.remove('template-tag__template--active');
                previousItem.previousElementSibling.classList.add('template-tag__template--active');
                if (previousItem.previousElementSibling && previousItem.previousElementSibling.previousElementSibling) {
                    leftArrow.style.display = 'block';
                } else {
                    leftArrow.style.display = 'none';
                }
                return;
            }
            previousItem.scrollIntoView({inline: 'nearest', behavior: 'smooth', block: 'nearest'});
            activeItem.classList.remove('template-tag__template--active');
            previousItem.classList.add('template-tag__template--active');
            if (!previousItem.previousElementSibling) {
                const nextItem = previousItem.nextElementSibling;
                previousItem.classList.remove('template-tag__template--active');
                nextItem.classList.add('template-tag__template--active');
            }
        };
        $scope.tourGuide = {
            firstTime: true,
            currentStep: -1,
            steps: []
        };
        $scope.tourGuideShowing = false;
        $scope.startTourGuide = function () {
            if ($scope.settings.is_mobile) {
                return;
            }
            if ($scope.tourGuide.currentStep == -1) {
                var steps = [];
                jQuery.each(jQuery('[data-tour]'), function () {
                    var el = jQuery(this),
                        dataTour = el.attr('data-tour'),
                        priority = el.attr('data-tour-priority');
                    steps.push({
                        priority: priority,
                        template: 'tour_guide.' + dataTour,
                        element: el
                    });
                });
                $scope.tourGuide.steps = _.sortBy(steps, [function (s) {
                    return s.priority;
                }]);
            }
            ;
            $scope.tourGuideShowing = true;
            localStorage.setItem('showTourGuide', 1);
            $scope.tourGuide.currentStep = -1;
            $timeout(function () {
                $scope.nextTour();
            }, 300);
        };
        $scope.processTourComponents = function (close) {
            var targetEl = $scope.tourGuide.steps[$scope.tourGuide.currentStep].element;
            if (close) {
                jQuery('.tour-guide').removeClass('active');
                $scope.tourGuideShowing = false;
                $scope.showTemplateFieldsPopup();
                return;
            }
            ;
            var tourStepEl = jQuery('.nbd-tourStep'),
                bgTourTop = jQuery('.bgTour-top'),
                bgTourRight = jQuery('.bgTour-right'),
                bgTourBottom = jQuery('.bgTour-bottom'),
                bgTourLeft = jQuery('.bgTour-left'),
                height = targetEl.outerHeight(),
                width = targetEl.outerWidth();
            if ($scope.tourGuide.firstTime) {
                width = 75;
                $scope.tourGuide.firstTime = false;
            }
            var offset = targetEl.offset(),
                top = offset.top,
                left = offset.left,
                bottom = jQuery(window).outerHeight() - height - top,
                right = jQuery(window).outerWidth() - left - width;
            bgTourTop.css({
                height: top + 'px'
            });
            bgTourBottom.css({
                height: bottom + 'px'
            });
            bgTourRight.css({
                top: top + 'px',
                left: left + width + 'px',
                height: height + 'px'
            });
            bgTourLeft.css({
                top: top + 'px',
                width: left + 'px',
                height: height + 'px'
            });
            if (jQuery(window).width() > (left * 2)) {
                tourStepEl.attr('data-pos', 'left');
                tourStepEl.css({
                    top: top + 'px',
                    left: left + width + 7 + 'px'
                });
            } else {
                tourStepEl.attr('data-pos', 'right');
                tourStepEl.css({
                    top: top + 'px',
                    left: left - 7 + 'px'
                });
            }
            jQuery('.tour-guide').addClass('active');
        };
        $scope.nextTour = function () {
            if ($scope.tourGuide.currentStep < ($scope.tourGuide.steps.length - 1)) {
                $scope.tourGuide.currentStep++;
                $scope.processTourComponents();
            }
        };
        $scope.prevTour = function () {
            if ($scope.tourGuide.currentStep > 0) {
                $scope.tourGuide.currentStep--;
                $scope.processTourComponents();
            }
        };
        $scope.updateMapUrl = function () {
            if ($scope.resource.maps.address != '') {
                var address = $scope.resource.maps.address.replace(/\s/g, '+'),
                    width = parseInt($scope.resource.maps.width),
                    height = parseInt($scope.resource.maps.height);
                width = width > 640 ? 640 : width;
                height = height > 640 ? 640 : height;

                $scope.resource.maps.loading = true;
                $scope.resource.maps.url = 'https://maps.googleapis.com/maps/api/staticmap?center=';
                $scope.resource.maps.url += address + '&zoom=' + $scope.resource.maps.zoom + '&scale=2&size=' + width + 'x' + height;
                $scope.resource.maps.url += '&maptype=' + $scope.resource.maps.maptype + '&format=jpg&markers=size:' + $scope.resource.maps.markers.size;
                $scope.resource.maps.url += '|color:0x' + $scope.resource.maps.markers.color.replace('#', '') + '|label:' + $scope.resource.maps.markers.label + '|' + address + '&key=' + $scope.settings.nbdesigner_static_map_api_key + '&.jpg';

                var img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function () {
                    $scope.resource.maps.loading = false;
                }
                img.src = $scope.resource.maps.url;
                img.onerror = function () {
                    $scope.resource.maps.url = '';
                    $scope.resource.maps.loading = false;
                }
            }
        };
        if (typeof bagr_background != 'undefined') {
            /* NBDesigner Advanced */
            $scope.uploadBackgroundImage = function (files, indexFile) {
                indexFile = angular.isDefined(indexFile) ? indexFile : 0;
                var file = files[indexFile],
                    max_size = parseInt($scope.settings.nbdesigner_maxsize_upload),
                    min_size = parseInt($scope.settings.nbdesigner_minsize_upload);
                if ((file.type.indexOf("image") === -1 && file.type.indexOf("pdf") === -1) || (file.type.indexOf("pdf") != -1 && !$scope.settings.is_available_imagick)) {
                    alert($scope.settings.is_available_imagick ? $scope.settings.nbdlangs.supported_extensions2 : $scope.settings.nbdlangs.supported_extensions);
                    return;
                }
                if (file.size > max_size * 1024 * 1024) {
                    alert($scope.settings.nbdlangs.max_file_size + max_size + " MB");
                    return;
                } else if (file.size < min_size * 1024 * 1024) {
                    alert($scope.settings.nbdlangs.min_file_size + min_size + " MB");
                    return;
                }
                ;
                NBDDataFactory.get('nbdesigner_customer_upload', {file: file}, function (data) {
                    var data = JSON.parse(data);
                    if (data.flag == 1) {
                        if (angular.isDefined(data.ilr)) $scope.resource.upload.ilr = true;
                        if ($scope.resource.upload.ilr && NBDESIGNCONFIG['nbdesigner_enable_low_resolution_image'] == 'no') {
                            $scope.toggleStageLoading();
                            alert(data.mes);
                            return;
                        }
                        ;
                        $scope.addBackgrounds(data.src, true, true);
                    } else {
                        $scope.toggleStageLoading();
                        alert(data.mes);
                    }
                }, function (progress) {
                    $scope.resource.upload.progressBar = progress.toFixed(0);
                });
            }
            $scope.getBackgroundLayer = function () {
                var _stage = this.stages[this.currentStage],
                    _canvas = _stage.canvas,
                    obj = _canvas.getActiveObject();
                var bgItemObj = false;
                _canvas.forEachObject(function (obj) {
                    if (obj.type === "rect" && obj.isBg != undefined) {
                        bgItemObj = obj;
                    }
                });
                return bgItemObj;
            };
            $scope.colorBackground = '#fff';
            $scope.addBackground = function (color) {
                var _stage = this.stages[this.currentStage];
                if (angular.isUndefined(_stage)) {
                    return;
                }
                var _canvas = _stage.canvas,
                    obj = _canvas.getActiveObject();
                _canvas.setBackgroundImage(null);
                _canvas.setBackgroundColor(color, _canvas.renderAll.bind(_canvas));
            };
            $scope.changeBackgroundColor = function (color) {
                $scope.addBackground(color);
            };
            $scope.addImageBackground = function (url, showLoading, hideLoading) {
                var stage = $scope.stages[$scope.currentStage],
                    _canvas = stage['canvas'],
                    scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                if (showLoading) $scope.toggleStageLoading();
                fabric.Image.fromURL(url, function (op) {
                    var _ratio = 1;
                    var max_width = _canvas.width / scale * _ratio,
                        max_height = _canvas.height / scale * _ratio,
                        new_width = max_width;
                    if (op.width < max_width) new_width = op.width;
                    var width_ratio = new_width / op.width,
                        new_height = op.height * width_ratio;
                    if (new_height < max_height) {
                        new_height = max_height;
                        var height_ratio = new_height / op.height;
                        new_width = op.width * height_ratio;
                    }
                    ;
                    op.set({
                        scaleX: new_width / op.width,
                        scaleY: new_height / op.height,
                        originX: 'left', originY: 'top'
                    })
                    _canvas.setBackgroundImage(op, _canvas.renderAll.bind(_canvas));
                    if (hideLoading) $scope.toggleStageLoading();
                });
            };
            $scope.addBackgrounds = function (background, showLoading, hideLoading) {
                var url = typeof background == 'object' ? background.url : background;
                if (url.match(/\.(jpeg|jpg|gif|png)$/) != null) {
                    $scope.addImageBackground(url);
                } else {
                    fabric.loadSVGFromURL(url, function (ob, op) {
                        if (ob) {
                            $scope._addSvg(ob, op, art, hideLoading);
                        } else {
                            alert('Try again!');
                            $scope.toggleStageLoading();
                        }
                    });
                }
            };
        }
        if (typeof ssnb_nbd_js_config != 'undefined') {
            $scope.addblock = function (block, showLoading, hideLoading) {
                if (block.url.match(/\.(jpeg|jpg|gif|png)$/) != null) {
                    $scope.addImage(block.url);
                } else {
                    fabric.loadSVGFromURL(block.url, function (ob, op) {
                        if (ob) {
                            $scope._addSvg(ob, op, block, hideLoading);
                        } else {
                            alert('Try again!');
                            $scope.toggleStageLoading();
                        }
                    });
                }
            }
        }
        /*advanced*/
        $scope.addoverlay = function (overlay, showLoading, hideLoading, e) {
            if (!$scope.canAddMoreLayer()) return;
            var stage = $scope.stages[$scope.currentStage],
                btn = e.currentTarget,
                tempUrl = jQuery(btn).attr('data-type-src'),
                jsonData = jQuery.getJSON(tempUrl);
            _canvas = stage['canvas'];
            $scope.showDesignTab();
            jsonData.then(function (data, textStatus, jqxhr) {
                var result = jqxhr.responseJSON;
                $scope.loadOverlaysCustomize(result);
            })
        }
        $scope.addOverlayNew = function (overlay, showLoading, hideLoading, e) {
            if (!$scope.canAddMoreLayer()) return;
            var stage = $scope.stages[$scope.currentStage],
                btn = e.currentTarget,
                tempUrl = jQuery(btn).attr('data-type-src'),
                jsonData = jQuery.getJSON(tempUrl),
                _canvas = stage['canvas'];
            $scope.showDesignTab();
            jsonData.then(function (data, textStatus, jqxhr) {
                var result = jqxhr.responseJSON;
                $scope.loadOverlaysCustomizeNew(result);
            })
        }
        $scope.loadOverlaysCustomizeNew = function (json) {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            $scope.toggleStageLoading();
            if (_canvas) {
                if (!json) return false;
                // var json = JSON.parse(json);
                if (json.frame_0) {
                    json = JSON.stringify(json.frame_0);
                    json = JSON.parse(json);

                    var ffs = $scope.getFFs(json, 'fontFamily');
                    ffs = $scope.removeDuplicates(ffs);
                    if (ffs && ffs.length == 0) ffs.push('Arvo');

                    WebFont.load({
                        google: {
                            families: ffs
                        },
                        active: function () {
                            var objects = json.objects;
                            fabric.util.enlivenObjects(objects, function (objects) {
                                $scope.diffuseAnimation = true;
                                _canvas.discardActiveObject();
                                objects.forEach(function (o) {
                                    _canvas.add(o);
                                    o.setCoords();
                                });
                                _canvas.discardActiveObject();
                                _canvas.requestRenderAll();

                                $scope.diffuseAnimation = false;
                                $scope.toggleStageLoading();
                            });
                        },
                        classes: false
                    });
                } else {
                    var stage = $scope.stages[$scope.currentStage];
                    var scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                    var ffs = $scope.getFFs(json, 'fontFamily');
                    ffs = $scope.removeDuplicates(ffs);

                    layers = json.objects;
                    $scope.resource.tempData.template = [];

                    function loadLayers() {
                        $scope.loadTemplatesLayers(layers, function (objects) {
                            objects.forEach((object) => {
                                if (object.shadow && object.shadow.color === 'rgb(0,0,0)') {
                                    object.shadow = null;
                                }
                                $scope.contextAddLayers = 'template';
                                _canvas.add(object);
                                if (object.maskId) {
                                    $scope.contextAddLayers = 'addMask';
                                    _canvas.add(object.clipPath);
                                }
                                var _item = _canvas.item(_canvas.getObjects().length - 1);
                                $scope.resource.tempData.template.push(_item);
                            });
                            var selection = new fabric.ActiveSelection($scope.resource.tempData.template, {
                                canvas: _canvas
                            });
                            _canvas.setActiveObject(selection);
                            selection.addWithUpdate();
                            if ((selection.width * scale) > (_canvas.width * 0.8)) {
                                var canvasWidth = _canvas.width;
                                selection.scaleX = selection.scaleX * canvasWidth * 0.8 / (selection.width * scale);
                                selection.scaleY = selection.scaleY * canvasWidth * 0.8 / (selection.width * scale);
                                selection.width = selection.width * canvasWidth * 0.8 / (selection.width * scale);
                                selection.addWithUpdate();
                                if ((selection.height * scale) > (_canvas.height * 0.8)) {
                                    var canvasHeight = _canvas.height;
                                    selection.scaleX = selection.scaleX * canvasHeight * 0.8 / (selection.height * scale);
                                    selection.scaleY = selection.scaleY * canvasHeight * 0.8 / (selection.height * scale);
                                    selection.height = selection.height * canvasHeight * 0.8 / (selection.height * scale);
                                    selection.addWithUpdate();
                                }
                            }
                            _canvas.viewportCenterObjectH(selection);
                            _canvas.viewportCenterObjectV(selection);
                            $scope.renderStage();
                            $scope.toggleStageLoading();
                            $scope.setHistory($scope.currentStage, true);
                        })
                    };

                    if (ffs.length) {
                        _.each(ffs, function (font, index) {
                            if (typeof font !== 'object') {
                                font = $scope.getFontInfo(font);
                            }
                            if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                                $scope.resource.font.data.push(font);
                            }
                            ;
                            if (index == ffs.length - 1) {
                                $scope.insertTemplateFont(font.alias, function () {
                                    loadLayers();
                                    if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                        stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                                    }
                                    ;
                                });
                            } else {
                                $scope.insertTemplateFont(font.alias, function () {
                                    if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                        stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                                    }
                                    ;
                                });
                            }
                        });
                    } else {
                        loadLayers();
                    }
                }
            } else {
                console.log("Not loading WebFonts");
                return false;
            }
        };
        $scope.loadOverlaysCustomize = function (json) {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            $scope.toggleStageLoading();
            if (_canvas) {
                if (!json) return false;
                // var json = JSON.parse(json);
                if (json.frame_0) {
                    json = JSON.stringify(json.frame_0);
                    json = JSON.parse(json);

                    var ffs = $scope.getFFs(json, 'fontFamily');
                    ffs = $scope.removeDuplicates(ffs);
                    if (ffs && ffs.length == 0) ffs.push('Arvo');

                    WebFont.load({
                        google: {
                            families: ffs
                        },
                        active: function () {
                            var objects = json.objects;
                            fabric.util.enlivenObjects(objects, function (objects) {
                                $scope.diffuseAnimation = true;
                                _canvas.discardActiveObject();
                                objects.forEach(function (o) {
                                    _canvas.add(o);
                                    o.setCoords();
                                });
                                _canvas.discardActiveObject();
                                _canvas.requestRenderAll();

                                $scope.diffuseAnimation = false;
                                $scope.toggleStageLoading();
                            });
                        },
                        classes: false
                    });
                } else {
                    var stage = $scope.stages[$scope.currentStage];
                    var scale = stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                    var ffs = $scope.getFFs(json, 'fontFamily');
                    ffs = $scope.removeDuplicates(ffs);

                    layers = json.objects;
                    $scope.resource.tempData.template = [];

                    function loadLayers() {
                        $scope.loadTemplatesLayers(layers, function (objects) {
                            objects.forEach((object) => {
                                if (object.shadow && object.shadow.color === 'rgb(0,0,0)') {
                                    object.shadow = null;
                                }
                                $scope.contextAddLayers = 'template';
                                if (object.maskId) {
                                    _canvas.add(object);
                                    $scope.contextAddLayers = 'addMask';
                                    _canvas.add(object.clipPath);
                                } else if (object.isMask) {
                                    //
                                } else {
                                    _canvas.add(object);

                                }
                                if (!object.isMask) {
                                    var _item = _canvas.item(_canvas.getObjects().length - 1);
                                    $scope.resource.tempData.template.push(_item);
                                }
                            });
                            var selection = new fabric.ActiveSelection($scope.resource.tempData.template, {
                                canvas: _canvas
                            });
                            _canvas.setActiveObject(selection);
                            selection.addWithUpdate();
                            if ((selection.width * scale) > (_canvas.width * 0.8)) {
                                var canvasWidth = _canvas.width;
                                selection.scaleX = selection.scaleX * canvasWidth * 0.8 / (selection.width * scale);
                                selection.scaleY = selection.scaleY * canvasWidth * 0.8 / (selection.width * scale);
                                selection.width = selection.width * canvasWidth * 0.8 / (selection.width * scale);
                                selection.addWithUpdate();
                                if ((selection.height * scale) > (_canvas.height * 0.8)) {
                                    var canvasHeight = _canvas.height;
                                    selection.scaleX = selection.scaleX * canvasHeight * 0.8 / (selection.height * scale);
                                    selection.scaleY = selection.scaleY * canvasHeight * 0.8 / (selection.height * scale);
                                    selection.height = selection.height * canvasHeight * 0.8 / (selection.height * scale);
                                    selection.addWithUpdate();
                                }
                            }
                            _canvas.viewportCenterObjectH(selection);
                            _canvas.viewportCenterObjectV(selection);
                            $scope.renderStage();
                            $scope.toggleStageLoading();
                            $scope.setHistory($scope.currentStage, true);
                        })

                    };

                    if (ffs.length) {
                        _.each(ffs, function (font, index) {
                            if (typeof font !== 'object') {
                                font = $scope.getFontInfo(font);
                            }
                            if (!_.filter($scope.resource.font.data, ['alias', font.alias]).length) {
                                $scope.resource.font.data.push(font);
                            }
                            ;
                            if (index == ffs.length - 1) {
                                $scope.insertTemplateFont(font.alias, function () {
                                    loadLayers();
                                    if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                        stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                                    }
                                    ;
                                });
                            } else {
                                $scope.insertTemplateFont(font.alias, function () {
                                    if (!_.filter(stage.states.usedFonts, ['alias', font.alias]).length) {
                                        stage.states.usedFonts.push($scope.getFontInfo(font.alias));
                                    }
                                    ;
                                });
                            }
                        });
                    } else {
                        loadLayers();
                    }
                }
            } else {
                console.log("Not loading WebFonts");
                return false;
            }
        };

        $scope.getFFs = function (obj, key) {
            var objects = [];
            for (var i in obj) {
                if (!obj.hasOwnProperty(i)) continue;
                if (typeof obj[i] == 'object') {
                    objects = objects.concat($scope.getFFs(obj[i], key));
                } else if (i === key) {
                    objects.push(obj[i]);
                }
            }
            return objects;
        };
        $scope.getUrlIframe = function (id) {
            jQuery('.nbd-popup.popup-nbt-video-help').find('.overlay-main').addClass('active');
            $scope.settings.idIframe = id;
            $('.nbd-popup.popup-nbt-video-help').nbShowPopup();
            angular.forEach($scope.settings.elementCustomize, function (ele, key) {
                if ($scope.settings.idIframe == ele.id) {
                    $scope.settings.nameIframe = ele.name;
                }
            });
            $timeout(function () {
                jQuery('.nbd-popup.popup-nbt-video-help').find('.overlay-main').removeClass('active');
            }, 2000);
        }
        $scope.matrixFilter = [
            {"name": "Original", "position": " 0px 0px", "key": 99, "type": "original", "check": 0},
            {"name": "B&W", "position": "-92px 0px", "key": 0, "type": "blackwhite", "check": 0},
            {"name": "Kodachrome", "position": "-184px 0px", "key": 18, "type": "kodachrome", "check": 0},
            {"name": "Technicolor", "position": "-276px 0px", "key": 14, "type": "technicolor", "check": 0},
            {"name": "Vintage", "position": "-368px 0px", "key": 9, "type": "vintage", "check": 0},
            {"name": "Polaroid", "position": "-460px 0px", "key": 15, "type": "polaroid", "check": 0},
            {"name": "Brownie", "position": "0px -92px", "key": 4, "type": "brownie", "check": 0},
            {"name": "Sepia", "position": "-92px -92px", "key": 3, "type": "sepia", "check": 0},
            {"name": "Invert", "position": "0px -92px", "key": 1, "type": "invert", "check": 0},
            {"name": "Grayscale", "position": "-184px -92px", "key": 0, "type": "grayscale", "check": 0},
            {"name": "Average", "position": "-276px -92px", "key": 0, "type": "average", "check": 0},
            {"name": "Luminance", "position": "-368px -92px", "key": 0, "type": "luminosity", "check": 0},
            {"name": "Lightness", "position": "-460px -92px", "key": 0, "type": "lightness", "check": 0},
            {"name": "Sharpen", "position": " 0px -184px", "key": 12, "type": "sharpen", "check": 0},
            {"name": "Emboss", "position": "-92px -184px", "key": 13, "type": "emboss", "check": 0},
        ];
        $scope.attributeImage = {
            "blur": 0,
            "saturation": 0,
            "huerotation": 0,
            "brightness": 0,
            "contrast": 0,
            "noise": 0,
            "pixelate": 0,
            "r": 0,
            "g": 0,
            "b": 0,
            "removecolor": 0,
            "color": "#00f900",
            "mode": "",
            "apha": 1
        };
        $scope.modeImage = [
            {"name": "Default", "value": "add", "select": false}, {"name": "Diff", "value": "diff", "select": false},
            {"name": "Subtract", "value": "subtract", "select": false}, {
                "name": "Multiply",
                "value": "multiply",
                "select": false
            },
            {"name": "Screen", "value": "screen", "select": false}, {
                "name": "Lighten",
                "value": "lighten",
                "select": false
            },
            {"name": "Darken", "value": "darken", "select": false}, {
                "name": "Overlay",
                "value": "overlay",
                "select": false
            },
            {"name": "Exclusion", "value": "exclusion", "select": false}, {
                "name": "Tint",
                "value": "tint",
                "select": false
            },
        ];
        $scope.blendImage = [
            {"name": "Multiply", "value": "multiply", "select": false},
            {"name": "Mask", "value": "mask", "select": false},
        ];
        $scope.updateScrollBarCustomize = function (jSelector) {
            $timeout(function () {
                jQuery(jSelector).perfectScrollbar();
            });
        };
        $scope.showFilterColorPicker = false;
        $scope.showFilterColorPickerBlend = false;
        $scope.showFilterImageColorPicker = function () {
            $scope.showFilterColorPicker = !$scope.showFilterColorPicker;
        };
        $scope.showFilterImageColorPickerBlend = function () {
            $scope.showFilterColorPickerBlend = !$scope.showFilterColorPickerBlend;
        };
        $scope.currentColorCustomizeBlend = $scope.settings.nbdesigner_default_color;
        $scope.resetImage = function () {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!appConfig.ready) return;
            var imageObj = _canvas.getActiveObject();
            if (!imageObj) return;
            imageObj.opacity = fabric.util.toFixed(imageObj.get('opacity') * 100);
            imageObj.angle = 0;
            $scope.stages[$scope.currentStage].states.opacity = 100;
            $scope.stages[$scope.currentStage].states.angle = 0;
            $scope.checkGamma = 0;
            $scope.checkBlendColor = false;
            $scope.checkBlendImage = false;
            $scope.currentColorCustomizeBlend = '#00f900';
            $scope.currentColorCustomize = $scope.settings.nbdesigner_default_color;
            angular.forEach($scope.attributeImage, function (value, key) {
                $scope.attributeImage[key] = 0;
                if (key == 'huerotation') {
                    $scope.attributeImage[key] = -0.02;
                }
                if (key == 'r' || key == 'g' || key == 'b') {
                    $scope.attributeImage[key] = 1;
                }
                if (key == 'color') {
                    $scope.attributeImage[key] = '#00f900';
                }
                if (key == 'mode') {
                    $scope.attributeImage[key] = '';
                }
            });
            $scope.matrixFilter.forEach(function (f, i) {
                $scope.matrixFilter[i].check = 0;
            });
            $timeout(() => {
                imageObj.filters = [];
                imageObj.applyFilters(false, function () {
                    $timeout(() => $scope.renderStage(), 0);
                }, true);
                angular.forEach(imageObj, function (value, index) {
                    delete imageObj.filters[index];
                });
                imageObj.applyFilters();
                $scope.renderStage();
            }, 200);

        };
        $scope.applyFilterValue = function (index, prop, value) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var obj = _canvas.getActiveObject();
            if (obj.filters[index]) {
                obj.filters[index][prop] = value;
                var timeStart = +new Date();
                obj.applyFilters(false, function () {
                    $timeout(() => $scope.renderStage(), 0);
                }, true);
                var timeEnd = +new Date();
                var dimString = _canvas.getActiveObject().width + ' x ' +
                    _canvas.getActiveObject().height;
                $('#bench').innerHTML = dimString + 'px ' +
                    parseFloat(timeEnd - timeStart) + 'ms';
                _canvas.renderAll();
            }
        };
        $scope.matrixFilters = function (index, filter, type) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            var image = _canvas.getActiveObject();
            // $scope.filterCheck = $scope.stages[$scope.currentStage].states.filters.length;
            var f = fabric.Image.filters;
            $scope.matrixFilter[index].check = $scope.matrixFilter[index].check ? 0 : 1;
            switch (type) {
                case "original":
                    $scope.matrixFilter[index].check = $scope.matrixFilter[index].check ? 0 : 1;
                    $scope.resetImage();
                    break;
                case "grayscale":
                    // fix case uncheck option
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Grayscale());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "lightness":
                    // fix case uncheck option
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Grayscale());
                        $scope.applyFilterValue(filter, 'mode', type);
                        console.log(image.filters)
                    } else {
                        console.log(image.filters)
                        delete image.filters[filter];
                        console.log(image.filters)
                    }
                    break;
                case "luminosity":
                    // fix case uncheck option
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Grayscale());
                        $scope.applyFilterValue(filter, 'mode', type);
                        console.log(image.filters)
                    } else {
                        console.log(image.filters)
                        delete image.filters[filter];
                        console.log(image.filters)
                    }
                    break;
                case "average":
                    // fix case uncheck option
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Grayscale());
                        $scope.applyFilterValue(filter, 'mode', type);
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "blackwhite":
                    // fix case uncheck option
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.BlackWhite());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "sharpen":
                    // fix case uncheck option
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Convolute({
                            matrix: [0, -1, 0,
                                -1, 5, -1,
                                0, -1, 0]
                        }));
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "emboss":
                    // fix case uncheck option
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Convolute({
                            matrix: [1, 1, 1,
                                1, 0.7, -1,
                                -1, -1, -1]
                        }));
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "kodachrome":
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Kodachrome());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "polaroid":
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Polaroid());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "vintage":
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Vintage());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "technicolor":
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Technicolor());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "brownie":
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Brownie());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "sepia":
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Sepia());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
                case "invert":
                    if ($scope.matrixFilter[index].check != 0) {
                        $scope.applyFilterImage(filter, true && new f.Invert());
                    } else {
                        delete image.filters[filter];
                    }
                    break;
            }
            image.applyFilters(false, function () {
                $timeout(() => $scope.renderStage(), 0);
            }, true);
            _canvas.renderAll();
        }
        $scope.setImageAttribute = function (type, value) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            var f = fabric.Image.filters;
            $scope.attributeImage.type = value;
            if (angular.isUndefined($scope.attributeImage.type)) return;
            switch (type) {
                case "brightness":
                    $scope.applyFilterImage(5, new f.Brightness({
                        brightness: parseFloat($scope.attributeImage.type)
                    }));
                    $scope.applyFilterValue(5, 'brightness', parseFloat($scope.attributeImage.type));
                    break;
                case "saturation":
                    $scope.applyFilterImage(7, new f.Saturation({
                        saturation: parseFloat($scope.attributeImage.type)
                    }));
                    $scope.applyFilterValue(7, 'saturation', parseFloat($scope.attributeImage.type));
                    break;
                case "contrast":
                    $scope.applyFilterImage(6, new f.Contrast({
                        contrast: parseFloat($scope.attributeImage.type)
                    }));
                    $scope.applyFilterValue(6, 'contrast', parseFloat($scope.attributeImage.type));
                    break;
                case "blur":
                    fabric.filterBackend = webglBackend;
                    fabric.isWebglSupported(fabric.textureSize);
                    $scope.applyFilterImage(11, new f.Blur({
                        value: parseFloat($scope.attributeImage.type)
                    }));
                    $scope.applyFilterValue(11, 'blur', parseFloat($scope.attributeImage.type));
                    break;
                case "noise":
                    $scope.applyFilterImage(8, new f.Noise({
                        noise: parseInt($scope.attributeImage.type)
                    }));
                    $scope.applyFilterValue(8, 'noise', parseInt($scope.attributeImage.type));
                    break;
                case "pixelate":
                    $scope.applyFilterImage(10, new f.Pixelate({
                        blocksize: parseInt($scope.attributeImage.type)
                    }));
                    $scope.applyFilterValue(10, 'blocksize', parseInt($scope.attributeImage.type));
                    break;
                case "hue":
                    $scope.applyFilterImage(21, new f.HueRotation({
                        rotation: parseFloat($scope.attributeImage.type)
                    }));
                    $scope.applyFilterValue(21, 'rotation', parseFloat($scope.attributeImage.type));
                    break;
                case "removecolor":
                    $scope.applyFilterImage(2, true && new f.RemoveColor({
                        distance: $scope.attributeImage.type,
                        color: $scope.currentColorCustomize,
                    }));
                    $scope.applyFilterValue(2, 'color', $scope.currentColorCustomize);
                    $scope.applyFilterValue(2, 'distance', $scope.attributeImage.type);
                    break;

            }
            item.applyFilters(false, function () {
                $timeout(() => $scope.renderStage(), 0);
            }, true);
            _canvas.renderAll();
        }
        $scope.checkGamma = 0;
        $scope.checkBlendColor = false;
        $scope.checkBlendImage = false;
        $scope.setImageGammaClick = function (type, array) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            var f = fabric.Image.filters;
            $scope.checkGamma = $scope.checkGamma ? 0 : 1;
            if ($scope.checkGamma != 0) {
                $scope.applyFilterImage(17, true && new f.Gamma({
                    gamma: array
                }));
            } else {
                angular.forEach(item.filters, function (value, key) {
                    var type = value.type;
                    if (type == "Gamma") {
                        value.gamma = [1, 1, 1];
                    }
                    ;
                });
            }
            $timeout(function () {
                jQuery('#customize-filter-mask').perfectScrollbar('update');
            });
            item.applyFilters(false, function () {
                $timeout(() => $scope.renderStage(), 0);
            }, true);
            _canvas.renderAll();
        };
        $scope.setImageGamma = function (type, array) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            var f = fabric.Image.filters;
            if ($scope.check != 0 && $scope.checkGamma != 0) {
                $scope.applyFilterImage(17, true && new f.Gamma({
                    gamma: array
                }));
                angular.forEach(item.filters, function (value, key) {
                    var type = value.type;
                    if (type == "Gamma") {
                        $scope.applyFilterValue(17, 'gamma', value.gamma);
                    }
                    ;
                });
                array.forEach(function (f, i) {
                    if (array.indexOf("undefined") !== -1) {
                        return;
                    }
                });
            }
            item.applyFilters(false, function () {
                $timeout(() => $scope.renderStage(), 0);
            }, true);
            _canvas.renderAll();
        };
        $scope.setImageBlendClick = function (type, color, mode, alpha) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            var f = fabric.Image.filters;
            var imageObject;
            switch (type) {
                case "blendcolor":
                    $scope.checkBlendColor = $scope.checkBlendColor ? false : true;
                    mode = mode == "" ? "add" : $scope.blendValue;
                    color = $scope.currentColorCustomizeBlend;
                    alpha = $scope.attributeImage.apha;
                    if ($scope.checkBlendColor) {
                        $scope.applyFilterImage(16, $scope.checkBlendColor && new f.BlendColor({
                            color: color,
                            mode: mode,
                            alpha: alpha
                        }));
                        $scope.applyFilterValue(16, 'mode', mode);
                        $scope.applyFilterValue(16, 'color', color);
                        $scope.applyFilterValue(16, 'alpha', alpha);
                    } else {
                        delete item.filters[16];
                    }
                    break;
                case "blendimage":
                    $scope.checkBlendImage = $scope.checkBlendImage ? false : true;
                    mode = mode == "" ? "multiply" : $scope.modeImageBlend;
                    alpha = alpha ? 1 : $scope.aphaImage;
                    console.log($scope.checkBlendImage)
                    console.log(mode)
                    console.log(alpha)
                    if ($scope.checkBlendImage) {
                        fabric.Image.fromURL(item.getSvgSrc(), function (img) {
                            img.set({
                                width: 200,
                                left: 100,
                                top: 100,
                                selectable: false,
                                height: 200,
                                originX: 'center',
                                originY: 'center',
                                scaleX: 1,
                                scaleY: 1
                            })
                            imageObject = img;
                            img.scaleX = 1;
                            img.scaleY = 1;
                            img.top = 15;
                            img.left = 15;
                            $scope.applyFilterImage(20, $scope.checkBlendImage && new f.BlendImage({
                                image: img,
                            }));
                            $scope.applyFilterValue(20, 'mode', mode);
                        });
                    } else {
                        delete item.filters[20];
                    }
                    break;
            }
            $timeout(function () {
                jQuery('#customize-filter-mask').perfectScrollbar('update');
            });
            item.applyFilters(false, function () {
                $timeout(() => $scope.renderStage(), 0);
            }, true);
            _canvas.renderAll();
        };
        $scope.setImageBlendColor = function (type, color, mode, alpha) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            var f = fabric.Image.filters;
            mode = mode == "" ? "add" : $scope.blendValue;
            color = $scope.currentColorCustomizeBlend;
            if ($scope.checkBlendColor != 0) {
                $scope.applyFilterImage(16, true && new f.BlendColor({
                    color: color,
                    mode: mode,
                    alpha: alpha
                }));
            }
            item.applyFilters(false, function () {
                $timeout(() => $scope.renderStage(), 0);
            }, true);
            _canvas.renderAll();
        };
        $scope.setBlendAttritube = function (index, val, color, alpha) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            var f = fabric.Image.filters;
            $scope.modeImage[index].select = $scope.modeImage[index].select ? false : true;
            color = $scope.currentColorCustomizeBlend || color;
            if ($scope.modeImage[index].select) {
                $scope.nameMode = $scope.modeImage[index].name;
                $scope.blendValue = val;
                $scope.attributeImage.mode = val;
                $scope.applyFilterImage(16, $scope.modeImage[index].select && new f.BlendColor({
                    color: color,
                    mode: val,
                    alpha: alpha
                }));
                $scope.modeImage[index].select = false;
                item.applyFilters(false, function () {
                    $timeout(() => $scope.renderStage(), 0);
                }, true);
                _canvas.renderAll();
            } else {
                $scope.nameMode = "";
                $scope.blendValue = "add";
                $scope.attributeImage.mode = "add";
                $scope.modeImage[index].select = false;
            }
        };
        $scope.setBlendAttritubeImage = function (index, val, alpha) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            var f = fabric.Image.filters;
            $scope.blendImage[index].select = $scope.blendImage[index].select ? false : true;
            if ($scope.blendImage[index].select) {
                $scope.modeImageBlend = val;
                $scope.nameModeImage = $scope.blendImage[index].name;
                $scope.aphaImage = alpha;
                fabric.Image.fromURL(item.getSvgSrc(), function (img) {
                    img.set({
                        width: 200,
                        left: 100,
                        top: 100,
                        selectable: false,
                        height: 200,
                        originX: 'center',
                        originY: 'center',
                        scaleX: 1,
                        scaleY: 1
                    })
                    imageObject = img;
                    img.scaleX = 1;
                    img.scaleY = 1;
                    img.top = 15;
                    img.left = 15;
                    $scope.applyFilterImage(20, $scope.blendImage[index].select && new f.BlendImage({
                        image: img,
                    }));
                    $scope.applyFilterValue(20, 'mode', $scope.modeImageBlend);
                    $scope.blendImage[index].select = false;
                });
                item.applyFilters(false, function () {
                    $timeout(() => $scope.renderStage(), 0);
                }, true);
                _canvas.renderAll();
            } else {
                $scope.nameModeImage = "";
                $scope.modeImageBlend = "multiply";
                $scope.aphaImage = alpha;
                $scope.blendImage[index].select = false;
            }
            item.applyFilters(false, function () {
                $timeout(() => $scope.renderStage(), 0);
            }, true);
            _canvas.renderAll();
        };
        $scope.setImageBlend = function (type, apha, mode) {
            var _stage = $scope.stages[$scope.currentStage],
                _states = _stage.states,
                _canvas = _stage['canvas'];
            if (!appConfig.ready) return;
            var item = _canvas.getActiveObject();
            var f = fabric.Image.filters;
            if ($scope.checkBlendImage) {
                fabric.Image.fromURL(item.getSvgSrc(), function (img) {
                    img.set({
                        width: 200,
                        left: 100,
                        top: 100,
                        selectable: false,
                        height: 200,
                        originX: 'center',
                        originY: 'center',
                        scaleX: 1,
                        scaleY: 1
                    })
                    imageObject = img;
                    img.scaleX = 1;
                    img.scaleY = 1;
                    img.top = 15;
                    img.left = 15;
                    $scope.applyFilterImage(20, true && new f.BlendImage({
                        image: img,
                    }));
                    $scope.applyFilterValue(20, 'mode', mode);
                });
            }
            item.applyFilters(false, function () {
                $timeout(() => $scope.renderStage(), 0);
            }, true);
            _canvas.renderAll();
        };
        $scope.applyFilterImage = function (index, filter, force = false) {
            var _canvas = this.stages[$scope.currentStage]['canvas'];
            if (!appConfig.ready) return;
            var obj = _canvas.getActiveObject();
            if (!obj) return;
            var filters = ['Grayscale', 'Invert', 'RemoveColor', 'Sepia', 'Brownie',
                'Brightness', 'Contrast', 'Saturation', 'Noise', 'Vintage',
                'Pixelate', 'Blur', 'Sharpen', 'Emboss', 'Technicolor',
                'Polaroid', 'BlendColor', 'Gamma', 'Kodachrome',
                'BlackWhite', 'BlendImage', 'HueRotation', 'Resize'];
            if (obj.filters.length > 0) {
                var exist = false, indexExists = false;
                obj.filters.forEach(function (f, i) {
                    if (f.type == filters[index]) {
                        console.log()
                        exist = true;
                        obj.filters[i] = filter;
                    }
                    if (index == i) {
                        indexExists = true;
                    }
                });
                if (!exist && indexExists) {
                    obj.filters.splice(index, 0, filter);
                } else if (!exist && !indexExists) {
                    obj.filters[index] = filter;
                }
            } else {
                obj.filters[index] = filter;
            }
            var timeStart = +new Date();
            obj.applyFilters();
            var timeEnd = +new Date();
            var dimString = _canvas.getActiveObject().width + ' x ' +
                _canvas.getActiveObject().height;
            $('bench').innerHTML = dimString + 'px ' +
                parseFloat(timeEnd - timeStart) + 'ms';
            _canvas.renderAll();
        };
        /*advanced*/
        $scope.threeDimensionPreview = {
            existedFrame: false,
            modelLoaded: false,
            size: 'minimize',
        };
        $scope.resize3DPreview = function (type) {
            if (type == 'minimize') {
                jQuery('#preview-3d-wrapper').removeAttr('style');
            } else {
                jQuery('#preview-3d-wrapper').css({
                    width: window.innerWidth + 'px',
                    height: window.innerHeight - 40 + 'px',
                    left: 0,
                    top: '40px'
                });
            }
            $scope.threeDimensionPreview.size = type;
        };
        $scope.show3DPreview = function () {
            var dragHandleEl = jQuery('#preview-3d-drag-handle'),
                resizeHandleEl = jQuery('#preview-3d-resize-handle'),
                wrapperEl = jQuery('#preview-3d-wrapper'),
                startX, startY, currentWidth, currentHeight, startLeft, startTop, startWidth, startHeight, currentLeft,
                currentTop,
                windowWidth = window.innerWidth,
                windowHeight = window.innerHeight;

            function startDrag(e) {
                var left = startLeft + e.clientX - startX,
                    top = startTop + e.clientY - startY;
                left = left < 0 ? 0 : left;
                if ((left + currentWidth) > windowWidth) {
                    left = windowWidth - currentWidth;
                }
                top = top < 40 ? 40 : top;
                if ((top + currentHeight) > windowHeight) {
                    top = windowHeight - currentHeight;
                }
                wrapperEl.css({
                    top: top + 'px',
                    left: left + 'px'
                });
            }

            function stopDrag(e) {
                jQuery(document).off('mousemove', startDrag);
                jQuery(document).off('mouseup', stopDrag);
            }

            function initDraggable() {
                dragHandleEl.on('mousedown', function (e) {
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = wrapperEl.offset().left;
                    startTop = wrapperEl.offset().top;
                    currentWidth = wrapperEl.width();
                    currentHeight = wrapperEl.height();
                    jQuery(document).on('mousemove', startDrag);
                    jQuery(document).on('mouseup', stopDrag);
                });
            }

            function startResize(e) {
                var width = startWidth + e.clientX - startX,
                    height = startHeight + e.clientY - startY;
                width = width < 400 ? 400 : width;
                if ((width + currentLeft) > windowWidth) {
                    width = windowWidth - currentLeft;
                }
                height = height < 300 ? 300 : height;
                if ((height + currentTop) > windowHeight) {
                    height = windowHeight - currentTop;
                }
                wrapperEl.css({
                    width: width + 'px',
                    height: height + 'px'
                });
            }

            function stopResize(e) {
                jQuery(document).off('mousemove', startResize);
                jQuery(document).off('mouseup', stopResize);
                jQuery('.preview-3d-resize-overlay').removeClass('active');
            }

            function initResizeable() {
                resizeHandleEl.on('mousedown', function (e) {
                    startX = e.clientX;
                    startY = e.clientY;
                    currentLeft = wrapperEl.offset().left;
                    currentTop = wrapperEl.offset().top;
                    startWidth = wrapperEl.width();
                    startHeight = wrapperEl.height();
                    jQuery('.preview-3d-resize-overlay').addClass('active');
                    jQuery(document).on('mousemove', startResize);
                    jQuery(document).on('mouseup', stopResize);
                });
            }

            function _show3DPreview() {
                if (!$scope.threeDimensionPreview.existedFrame) {
                    var iframe_src = NBDESIGNCONFIG.home_url + '?nbd-route=nbd-3d-preview&product_id=' + NBDESIGNCONFIG.product_id;
                    jQuery('.preview-3d-wrap-inner').prepend('<iframe id="preview-3d-wrap"  width="100%" height="100%" scrolling="no" frameborder="0" noresize="noresize" allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true" src="' + iframe_src + '"></iframe>');
                    $scope.threeDimensionPreview.existedFrame = true;
                    initDraggable();
                    initResizeable();
                }
                jQuery('.preview-3d-wrap').addClass('active');
                if ($scope.threeDimensionPreview.modelLoaded) {
                    $scope.update3DPreviewTexture();
                }
            }

            $scope.saveDesign();
            if ($scope.checkSaveStatus()) {
                _show3DPreview();
            } else {
                var interval = $interval(function () {
                    if ($scope.checkSaveStatus()) {
                        $interval.cancel(interval);
                        _show3DPreview();
                    }
                }, 100);
            }
        };
        $scope.close3DPreview = function () {
            jQuery('.preview-3d-wrap').removeClass('active');
        };
        $scope.update3DPreviewTexture = function () {
            var frame = document.getElementById('preview-3d-wrap');
            frame.contentWindow.postMessage(['update_design', $scope.stages[0].design]);
        };
        $scope.stickerCutline = {
            pathCmd: '',
            svg: '',
            patternSvg: '',
            active: false
        };
        $scope.generateStickerCutline = function (onSaveDesign) {
            if (!onSaveDesign) $scope.toggleStageLoading();
            $scope.stickerCutline.active = false;
            var _stage = $scope.stages[0],
                _canvas = _stage.canvas,
                width = Math.floor(_canvas.width),
                height = Math.floor(_canvas.height),
                bleedTB = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio * _stage.config.bleed_tb,
                bleedLR = _stage.states.scaleRange[_stage.states.currentScaleIndex].ratio * _stage.config.bleed_lr,
                margin = Math.ceil(Math.max(bleedTB, bleedLR));
            margin = margin > 1 ? margin : 1;
            var options = {
                color: 'none',
                outline: '#FF0000',
                margin: margin
            };
            _canvas.discardActiveObject().calcOffset().renderAll();

            function _showStickerPreview() {
                $timeout(function () {
                    var ctx = _canvas.getContext('2d');
                    imgdataObj = ctx.getImageData(margin, margin, width - 2 * margin, height - 2 * margin);

                    Potrace.clear();
                    Potrace.setParameter(options);
                    Potrace.loadData(imgdataObj, width, height);
                    Potrace.process(function () {
                        var svg = Potrace.getSVG(1, "curve", true);
                        $scope.stickerCutline.pathCmd = svg.pathcmd;
                        buildCutlineSvg();
                        if (!onSaveDesign) $scope.toggleStageLoading();
                    });
                }, 100);
            }

            function buildCutlineSvg() {
                $scope.stickerCutline.svg = '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg">';
                $scope.stickerCutline.svg += '<path d="';
                $scope.stickerCutline.svg += $scope.stickerCutline.pathCmd;
                $scope.stickerCutline.svg += '" stroke="' + options.outline + '" stroke-width="' + (onSaveDesign ? 0.1 : 1) + '" fill="' + options.color + '" />';
                $scope.stickerCutline.svg += '</svg>';

                jQuery('.sticker-contour-wrap').html('').append($scope.stickerCutline.svg);

                if (angular.isDefined($scope.settings.product_data.product[0].pattern)) {
                    var pattern = $scope.settings.product_data.product[0].pattern;

                    $scope.stickerCutline.patternSvg = '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg">';
                    $scope.stickerCutline.patternSvg += '<defs>';
                    if (pattern.type == 'image') {
                        var patternWidth = 100, patternHeight = 100;
                        $scope.stickerCutline.patternSvg += '<pattern id="sticker_material_pattern" x="0" y="0" width="' + patternWidth / width + '" height="' + patternHeight / width + '" ><image x="0px" y="0px" width="' + patternWidth + '" height="' + patternHeight + '" xlink:href="' + pattern.src + '"></image></pattern>';
                    }
                    $scope.stickerCutline.patternSvg += '</defs>';
                    $scope.stickerCutline.patternSvg += '<path d="';
                    $scope.stickerCutline.patternSvg += $scope.stickerCutline.pathCmd;
                    if (pattern.type == 'color') {
                        $scope.stickerCutline.patternSvg += '" stroke-width="0" fill="' + options.color + '" />';
                    } else {
                        $scope.stickerCutline.patternSvg += '" stroke-width="0" fill="url(#sticker_material_pattern)" />';
                    }
                    $scope.stickerCutline.patternSvg += '</svg>';

                    jQuery('.sticker-contour-pattern-wrap').html('').append($scope.stickerCutline.patternSvg);
                }

                $scope.stickerCutline.active = true;
            }

            $timeout(function () {
                _showStickerPreview();
            }, 100);
        };
        jQuery(document).ready(function () {
            /*advanced*/
            if (typeof cmyk_nbd_js_config_design != "undefined") {
                function toHexRgb(color) {
                    var rgb = color.getRGB();
                    return "#" + Math.floor(rgb.r * 255.0).toString(16) + Math.floor(rgb.g * 255.0).toString(16) + Math.floor(rgb.b * 255.0).toString(16);
                }

                jQuery('.cp').colorpicker({
                    parts: ['map', 'bar', 'hex', 'rgb', 'cmyk', 'footer'],
                    showOn: 'both',
                    colorFormat: ['EXACT', 'cp,mp,yp,kp'],
                    buttonImageOnly: false,
                    buttonColorize: true,
                    //buttonImage: 'http://vanderlee.github.io/colorpicker/images/ui-colorpicker.png',

                    init: function (event, color) {
                        var v = jQuery(this).val();
                        var separator = v.indexOf(',') != -1 ? ',' : ';'; // Use either ',' or ';' as separator
                        var cmyk = v.split(separator);
                        color.colorPicker.color.setCMYK(cmyk[0] / 100.0, cmyk[1] / 100.0, cmyk[2] / 100.0, cmyk[3] / 100.0);
                        color.colorPicker.setColor(toHexRgb(color.colorPicker.color));
                    },

                    open: function (event, color) {
                        var v = jQuery(this).val();
                        var separator = v.indexOf(',') != -1 ? ',' : ';'; // Use either ',' or ';' as separator
                        var cmyk = v.split(separator);
                        color.colorPicker.color.setCMYK(cmyk[0] / 100.0, cmyk[1] / 100.0, cmyk[2] / 100.0, cmyk[3] / 100.0);
                        color.colorPicker.setColor(toHexRgb(color.colorPicker.color));
                    },

                    select: function (event, color) {
                        //console.log(color);
                        var hex = color.colorPicker.color.toHex();
                        jQuery('#rgb').val('#' + color);
                        var v = jQuery(this).val();
                        var separator = v.indexOf(',') != -1 ? ',' : ';'; // Use either ',' or ';' as separator
                        var cmyk = v.split(separator);

                        var c0 = String(Math.round(cmyk[0]));
                        var c1 = String(Math.round(cmyk[1]));
                        var c2 = String(Math.round(cmyk[2]));
                        var c3 = String(Math.round(cmyk[3]));

                        var a = isNaN(c0);
                        if (!a) {
                            jQuery('#rgb').val(c0 + ',' + c1 + ',' + c2 + ',' + c3);
                            var _stage = $scope.stages[$scope.currentStage],
                                _canvas = _stage.canvas;
                            if (angular.isDefined(_canvas) && !angular.equals({}, _canvas)) {
                                console.log(hex);
                                $scope.changeFill('#' + hex);
                            }

                        } else {
                            jQuery('#rgb').val('0,0,0,0');
                        }
                        ;
                    },
                });
            }
            $scope.init();
            if (NBDESIGNCONFIG['ui_mode'] != 3) {
                jQuery(document).triggerHandler('nbd_modern_app_init');
            }
            /*advanced*/
            if (typeof hvc_app_modern_js != "undefined") {
                var w = window.screen.width;
                var h = window.screen.height;
                if (w < 768) {
                    jQuery('.nbd-mode-2 .nbd-main-bar .logo').css({
                        'display': 'block',
                        'margin-left': '10px',
                        'margin-right': '0px'
                    });
                }
                jQuery('.nbd-mode-2 .nbd-main-bar .logo').attr({
                    'href': '#',
                    'onclick': 'window.history.back();'
                }).text('Back');
                jQuery('.nbd-popup .close-popup').after('<i class="icon-nbd icon-nbd-clear close-popup2" style="display: inline;"></i>');
                jQuery("body").on("click", ".nbd-popup .close-popup2", function () {
                    if (jQuery(this).siblings('.head').find('h2').text() != 'Crop image' && jQuery(this).siblings('.head').find('h2').length > 0) {
                        jQuery('body').css('pointer-events', 'none');
                        window.history.back();
                    } else {
                        jQuery(this).siblings('.close-popup').click();
                    }
                });
            }
            $scope.check = $scope.settings.version;
            $scope.backpopup = function () {
                jQuery(".popup-template-designer.custom").removeClass('nb-show');
            }
            var width = jQuery('.nbd-button.custom-email').width();
            jQuery('.nbd-button.backpopup').css('width', width);
            $scope.listHours = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
            jQuery('#txtdate').datepicker({
                dateFormat: 'dd/mm/yy',
                todayHighlight: true,
                autoclose: true,
                showButtonPanel: true
            })
            $scope.addTextVourcher = function () {
                var _canvas = this.stages[$scope.currentStage]["canvas"];
                date = NBDESIGNCONFIG.date;
                idOrder = NBDESIGNCONFIG.id_order;
                valueVourcher = NBDESIGNCONFIG.value_vourcher;
                money = NBDESIGNCONFIG.val_money;
                var str = money;
                str = str.replace("&pound;", "£");
                money = str;
                var stage = $scope.stages[$scope.currentStage];
                _canvas = stage.canvas;
                var fontName = NBDESIGNCONFIG.default_font.alias;
                font = new FontFaceObserver(fontName);
                font.load().then(
                    function () {
                        fabric.util.clearFabricFontCache(fontName);

                        function addText() {
                            var textbox1 = new fabric.IText(
                                "Vourcher No: " +
                                idOrder +
                                "\n" +
                                "Value: " +
                                money +
                                "\n" +
                                "Issue Date: " +
                                date,
                                {
                                    fontSize: 14,
                                    editable: false,
                                    textAlign: "right",
                                    fontFamily: fontName,
                                    objectCaching: false,
                                    itemId: "vourcher",
                                    fill: "#ffffff",
                                    originY: "center",
                                }
                            );
                            _canvas.add(textbox1);
                            _canvas.setActiveObject(textbox1);
                            item = _canvas.getActiveObject(textbox1);
                            scale =
                                stage.states.scaleRange[stage.states.currentScaleIndex].ratio;
                            bound = item.getBoundingRect();
                            $scope.beforeObjectModify(item);
                            var left = item.get("left");
                            var top = item.get("top");
                            var originY = item.get("originY");
                            var _top =
                                    originY == "center"
                                        ? bound.height / 2 / scale
                                        : top - bound.top / scale,
                                _left =
                                    left + (_canvas.width - bound.width - bound.left) / scale;
                            item.set({top: _top, left: _left});
                            item.setCoords();
                            _canvas.renderAll();

                            function replaceObject() {
                                var stage = $scope.stages[$scope.currentStage];
                                _canvas = stage.canvas;
                                var objects = _canvas.getObjects();
                                money = NBDESIGNCONFIG.val_money;
                                var str = money;
                                str = str.replace("&pound;", "£");
                                money = str;
                                for (var i = 0; i < objects.length; i++) {
                                    if (objects[i].itemId === "vourcher") {
                                        objects[i].text =
                                            "Vourcher No: " + NBDESIGNCONFIG.id_order +
                                            "\n" +
                                            "Issue Date: " +
                                            NBDESIGNCONFIG.date;
                                    }
                                }
                            }

                            replaceObject();
                        }

                        $timeout(function () {
                            addText();
                        }, 100);
                    },
                    function () {
                        console.log("Fail to load font: " + fontName);
                        addText();
                    }
                );
            };
            $scope.addTextHidden = function (content, type, additionalObj) {
                content = angular.isDefined(content)
                    ? content
                    : $scope.settings.nbdesigner_default_text;
                type = angular.isUndefined(type) ? "bodytext" : type;
                var textType = "IText",
                    fontSize = 16,
                    fontName = NBDESIGNCONFIG.default_font.alias;
                var state = $scope.stages[$scope.currentStage].states;
                switch (type) {
                    case "Sample voucher":
                        textType = "Textbox";
                        fontSize = 15;
                        break;
                    case "Term and condition":
                        textType = "Textbox";
                        fontSize = 5;
                        break;
                }
                var textObj = {
                    fontFamily: fontName,
                    radius: 50,
                    objectCaching: false,
                    fontSize: fontSize,
                    ptFontSize: (fontSize / state.ratioConvertFont).toFixed(2),
                };
                if (type == 'Term and condition') angular.extend(textObj, {
                    textAlign: 'left',
                    fill: '#848484',
                    termCodition: 'coditionText'
                });
                if (type == 'Sample voucher') angular.extend(textObj, {sampleText: 'sampleText'});
                if (additionalObj) {
                    angular.extend(textObj, additionalObj);
                }

                function addText() {
                    $scope.stages[$scope.currentStage]["canvas"].add(
                        new FabricWindow[textType](content, textObj)
                    );
                }

                var font = new FontFaceObserver(fontName);
                font.load(content).then(
                    function () {
                        fabric.util.clearFabricFontCache(fontName);
                        var container = document.createElement("span"),
                            scale = state.scaleRange[state.currentScaleIndex].ratio;
                        container.innerHTML = content;
                        container.style.cssText = [
                            "position:absolute",
                            "width:auto",
                            "font-size: " + fontSize + "px",
                            "font-family: " + fontName,
                            "left:-99999px",
                        ].join(" !important;");
                        document.body.appendChild(container);
                        var textWidth = container.clientWidth + 2;
                        document.body.removeChild(container);
                        var canvasWidth = $scope.stages[$scope.currentStage]["canvas"].width;
                        if (textWidth * scale > canvasWidth * 0.8) {
                            textObj.width = (canvasWidth * 0.8) / scale;
                            textObj.fontSize =
                                ((canvasWidth * 0.8) / (textWidth * scale)) * fontSize;
                            textObj.ptFontSize = (
                                textObj.fontSize / state.ratioConvertFont
                            ).toFixed(2);
                        } else {
                            textObj.width = textWidth / scale;
                        }
                        $timeout(function () {
                            addText();
                        }, 100);
                    },
                    function () {
                        console.log("Fail to load font: " + fontName);
                        addText();
                    }
                );
            };
            $scope.setLayerAttributeValue = function (itemIndex) {
                var _canvas = this.stages[$scope.currentStage]["canvas"];
                money = NBDESIGNCONFIG.val_money;
                var str = money;
                str = str.replace("&pound;", "£");
                money = str;
                var item = angular.isDefined(itemIndex)
                    ? _canvas.item(itemIndex)
                    : _canvas.getActiveObject();
                if (item.type) {
                    var _text = money;
                    item.set({text: _text});
                    item.setCoords();
                    _canvas.renderAll();
                    $scope.setHistory($scope.currentStage, true);
                    _canvas.discardActiveObject().requestRenderAll();
                }
                $scope.updateLayersList();
                return;
            };
            /*advanced*/
            if (typeof pmu_nbd_custom_preview_js != 'undefined') {
                $('#preview-form').hide();
                $scope.buttonClickPreview = function () {
                    var stage = $scope.stages[$scope.currentStage];
                    var area_design = $scope.settings.product_data.product[$scope.currentStage];
                    var ratio = area_design.product_height / area_design.product_width;
                    var new_height = ratio * 500;
                    var ratio_width_desgin = area_design.real_width / area_design.product_width;
                    var ratio_height_desgin = area_design.real_height / area_design.product_height;
                    var ratio_top = area_design.real_top / area_design.product_height;
                    var ratio_left = area_design.real_left / area_design.product_width
                    var width_left = 500 * ratio_left;
                    var width_top = new_height * ratio_top;
                    $scope.background = {
                        width: '500px',
                        height: new_height + 'px',
                        position: 'relative',
                        display: 'inline-block',
                        'z-index': 1,
                        'background-color': stage.config.bgType == 'image' ? '#fff' : ((stage.config.bgType == 'color' && ((!stage.config.show_overlay == '1' && stage.config.img_overlay != '') || !areaDesignShapes[$index])) ? stage.config.bgColor : 'transparent')
                    };
                    $scope.design_zone = {
                        width: ratio_width_desgin * 500 + 'px',
                        height: ratio_height_desgin * new_height + 'px',
                        top: width_top,
                        left: width_left,
                        position: 'absolute',
                        'z-index': 2
                    };
                    $scope.design_overlay = {
                        width: '500px',
                        height: new_height + 'px',
                        position: 'absolute',
                        display: 'inline-block',
                        'z-index': 5,
                        top: 0,
                        left: 0,
                    };
                }
                jQuery(document).on("click", ".nbd-main-menu .btn-live", function () {
                    if ($('.nbd-main-menu .btn-live').hasClass('active')) {
                        $('.nbd-main-menu .btn-live').removeClass('active');
                        $('#preview-form').hide();
                    } else {
                        $('.nbd-main-menu .btn-live').addClass('active');
                        $('#preview-form').show();
                        $scope.buttonClickPreview();
                        nbd_window.NBDESIGNERPRODUCT.hide_close_button();
                    }
                });
                jQuery(document).on("click", ".container-popup .close-popup", function () {
                    $('#preview-form').hide();
                    nbd_window.NBDESIGNERPRODUCT.show_close_button();
                });
            }
            if (typeof zin_nbd_customize_js != 'undefined') {
                $scope.ninetyDegree = function () {
                    var _stage = $scope.stages[$scope.currentStage],
                        _canvas = _stage['canvas'];
                    if (!appConfig.ready) return;
                    var item = _canvas.getActiveObject();
                    var curAngle = item.angle;
                    item.angle = 90;
                    _canvas.renderAll();
                }
                $scope.minusNinetyDegree = function () {
                    var _stage = $scope.stages[$scope.currentStage],
                        _canvas = _stage['canvas'];
                    if (!appConfig.ready) return;
                    var item = _canvas.getActiveObject();
                    var curAngle = item.angle;
                    item.angle = -90;
                    _canvas.renderAll();
                }
                $scope.oneHundredEightyDegree = function () {
                    var _stage = $scope.stages[$scope.currentStage],
                        _canvas = _stage['canvas'];
                    if (!appConfig.ready) return;
                    var item = _canvas.getActiveObject();
                    var curAngle = item.angle;
                    item.angle = 180;
                    _canvas.renderAll();
                }
                $scope.minusOneHundredEightyDegree = function () {
                    var _stage = $scope.stages[$scope.currentStage],
                        _canvas = _stage['canvas'];
                    if (!appConfig.ready) return;
                    var item = _canvas.getActiveObject();
                    var curAngle = item.angle;
                    item.angle = -180;
                    _canvas.renderAll();
                }
                $scope.twoHundredSeventyDegree = function () {
                    var _stage = $scope.stages[$scope.currentStage],
                        _canvas = _stage['canvas'];
                    if (!appConfig.ready) return;
                    var item = _canvas.getActiveObject();
                    var curAngle = item.angle;
                    item.angle = 270;
                    _canvas.renderAll();
                }
                $scope.minusTwoHundredSeventyDegree = function () {
                    var _stage = $scope.stages[$scope.currentStage],
                        _canvas = _stage['canvas'];
                    if (!appConfig.ready) return;
                    var item = _canvas.getActiveObject();
                    var curAngle = item.angle;
                    item.angle = -270;
                    _canvas.renderAll();
                }
                jQuery(document).on("click", ".main-ranges-button .Angle-degree90", function () {
                    jQuery('.nbd-main-menu .menu-item').removeClass('active');
                    $scope.ninetyDegree();
                })
                jQuery(document).on("click", ".main-ranges-button .Angle-degree-90", function () {
                    jQuery('.nbd-main-menu .menu-item').removeClass('active');
                    $scope.minusNinetyDegree();
                })
                jQuery(document).on("click", ".main-ranges-button .Angle-degree180", function () {
                    jQuery('.nbd-main-menu .menu-item').removeClass('active');
                    $scope.oneHundredEightyDegree();
                })
                jQuery(document).on("click", ".main-ranges-button .Angle-degree-180", function () {
                    jQuery('.nbd-main-menu .menu-item').removeClass('active');
                    $scope.minusOneHundredEightyDegree();
                })
                jQuery(document).on("click", ".main-ranges-button .Angle-degree270", function () {
                    jQuery('.nbd-main-menu .menu-item').removeClass('active');
                    $scope.twoHundredSeventyDegree();
                })
                jQuery(document).on("click", ".main-ranges-button .Angle-degree-270", function () {
                    jQuery('.nbd-main-menu .menu-item').removeClass('active');
                    $scope.minusTwoHundredSeventyDegree();
                })
            }
        });
    }]);
/*advanced*/
if (typeof udc_nbd_js_config != "undefined") {
    function access() {
        var iFrame = document.getElementById("iframe-custom");
        var iFrameWindow = iFrame.contentWindow;
        iFrameWindow.addEventListener("dragstart", function (event) {
            var src = jQuery(event.target).attr('src'),
                width = jQuery(event.target).attr('width'),
                height = jQuery(event.target).attr('height');
            if (jQuery(event.target).is('img')) {
                var type = event.target.type = 'image';
            }
            event.dataTransfer.setData("src", src);
            event.dataTransfer.setData("extenal", false);
            event.dataTransfer.setData("type", type);
            $('.popup-nbt-video-help .main-popup .close-popup').click();
        });
        //iFrameWindow.addEventListener("dragenter", function(e){
        //$('.popup-nbt-video-help .main-popup .close-popup').click();
        //})
    }
}

function buildSvgFilter(jOptions, _in) {
    var options = JSON.parse(jOptions),
        filter = '';
    _in = angular.isDefined(_in) ? _in : 'SourceGraphic';
    switch (options.type) {
        case 'blur':
            var value = angular.isDefined(options.value) ? options.value : 5;
            filter += '<feGaussianBlur stdDeviation="' + value + '" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'desaturate':
            filter += '<feColorMatrix type="saturate" in="' + _in + '" values="0" result="' + options.type + '"/>';
            break;
        case 'contrast':
            var slope = angular.isDefined(options.slope) ? options.slope : 5;
            var intercept = -(0.3 * slope) + 0.3;
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter += '<feFuncR type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter += '<feFuncG type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter += '<feFuncB type="linear" slope="' + slope + '" intercept="' + intercept + '"/>';
            filter += '</feComponentTransfer>';
            break;
        case 'sepiatone':
            filter += '<feColorMatrix type="matrix" in="' + _in + '" values=".343 .669 .119 0 0 .249 .626 .130 0 0 .172 .334 .111 0 0 .000 .000 .000 1 0" result="' + options.type + '"/>';
            break;
        case 'hue':
            var rotate = angular.isDefined(options.value) ? options.value : 180;
            filter += '<feColorMatrix type="hueRotate" values="' + rotate + '" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'luminance':
            filter += '<feColorMatrix type="luminanceToAlpha" in="' + _in + '" result="' + options.type + '"/>';
            break;
        case 'colorize':
            filter += '<feColorMatrix type="matrix" in="' + _in + '" values="1.0 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1.0 0" result="' + options.type + '"/>';
            break;
        case 'posterize':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter += '<feFuncR type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter += '<feFuncG type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter += '<feFuncB type="discrete" tableValues="0 0.2 0.4 0.6 0.8 1" />';
            filter += '</feComponentTransfer>';
            break;
        case 'darken':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter += '<feFuncR type="linear" slope="0.2" />';
            filter += '<feFuncG type="linear" slope="0.2" />';
            filter += '<feFuncB type="linear" slope="0.2" />';
            filter += '</feComponentTransfer>';
            break;
        case 'lighten':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter += '<feFuncR type="linear" slope="1.5" intercept="0.2" />';
            filter += '<feFuncG type="linear" slope="1.5" intercept="0.2" />';
            filter += '<feFuncB type="linear" slope="1.5" intercept="0.2" />';
            filter += '</feComponentTransfer>';
            break;
        case 'invert':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter += '<feFuncR type="table" tableValues="1 0" />';
            filter += '<feFuncG type="table" tableValues="1 0" />';
            filter += '<feFuncB type="table" tableValues="1 0" />';
            filter += '</feComponentTransfer>';
            break;
        case 'gamma1':
            filter += '<feComponentTransfer in="' + _in + '" result="' + options.type + '">';
            filter += '<feFuncR type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter += '<feFuncG type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter += '<feFuncB type="gamma" amplitude="1" exponent="0.5" offset="0" />';
            filter += '</feComponentTransfer>';
            break;
    }
    return filter;
};
nbdApp.factory('FabricWindow', ['$window', function ($window) {
    /* Fabric configuration */
    fabric.disableStyleCopyPaste = true;
    fabric.Object.NUM_FRACTION_DIGITS = 10;
    $window.fabric.Object.prototype.set({
        transparentCorners: false,
        borderColor: 'rgba(139, 61, 255, 0.85)',
        cornerStyle: 'circle',
        borderDashArray: [0, 0],
        fill: NBDESIGNCONFIG.nbdesigner_default_color,
        hoverCursor: 'pointer',
        borderOpacityWhenMoving: 0.2,
        controlsAboveOverlay: true,
        cornerColor: '#FFF',
        borderScaleFactor: 2.5,
        cornerStrokeColor: '#0E98FC',
    });


    if (NBDESIGNCONFIG.nbdesigner_object_center_scaling == 'yes') {
        $window.fabric.Object.prototype.set({centeredScaling: true});
    }
    ;
    if (checkMobileDevice()) $window.fabric.Object.prototype.set({cornerSize: 17});
    $window.fabric.IText.prototype.set({
        cursorWidth: 1,
        cursorColor: '#000',
        selectionColor: "rgba(1, 196, 204, 0.3)",
        cursorDuration: 500,
        strokeWidth: 0
    });
    if (NBDESIGNCONFIG.nbdesigner_enable_text_free_transform == 'no') {
        $window.fabric.IText.prototype.set({
            _controlsVisibility: {
                tl: true,
                tr: true,
                br: true,
                bl: true,
                ml: false,
                mt: false,
                mr: false,
                mb: false,
                mtr: NBDESIGNCONFIG.nbdesigner_text_rotate == '1' ? true : false
            }
        });
    }
    /*advanced*/
    if (typeof udc_nbd_js_config != 'undefined') {
        fabric.Image.prototype.set({
            crossOrigin: 'anonymous'
        });
    }
    $window.fabric.Canvas.prototype.set({
        preserveObjectStacking: true,
        controlsAboveOverlay: true,
        selectionColor: 'rgba(1, 196, 204, 0.3)',
        selectionBorderColor: '#01c4cc',
        selectionLineWidth: 0.5,
        centeredKey: "shiftKey",
        uniScaleKey: "altKey"
    });
    /*advanced*/
    if (typeof udc_nbd_js_config != 'undefined') {
        Object.assign($window.fabric.Canvas.prototype, {skipTargetFind: false, renderOnAddRemove: false});
    }
    $window.fabric.Textbox.prototype.set({
        _controlsVisibility: {
            tl: true,
            tr: true,
            br: true,
            bl: true,
            ml: true,
            mt: false,
            mr: true,
            mb: false,
            mtr: NBDESIGNCONFIG.nbdesigner_text_rotate == '1' ? true : false
        },
        paintFirst: NBDESIGNCONFIG.nbdesigner_enable_cloud2print_api == 'yes' ? "stroke" : "fill",
        /* strokeLineJoin: 'round' */
    });
    fabric.Textbox.prototype.onInput = (function () {
        return function (e) {
            const fromPaste = this.fromPaste;
            this.fromPaste = false;
            e && e.stopPropagation();
            if (!this.isEditing) {
                return;
            }
            // decisions about style changes.
            let nextText = this._splitTextIntoLines(
                    this.hiddenTextarea.value
                ).graphemeText,
                charCount = this._text.length,
                nextCharCount = nextText.length,
                removedText,
                insertedText,
                charDiff = nextCharCount - charCount,
                selectionStart = this.selectionStart,
                selectionEnd = this.selectionEnd,
                selection = selectionStart !== selectionEnd,
                copiedStyle,
                removeFrom,
                removeTo;
            if (this.hiddenTextarea.value === "") {
                this.styles = {};
                this.updateFromTextArea();
                this.fire("changed");
                if (this.canvas) {
                    this.canvas.fire("text:changed", {target: this});
                    this.canvas.requestRenderAll();
                }
                return;
            }

            var textareaSelection = this.fromStringToGraphemeSelection(
                this.hiddenTextarea.selectionStart,
                this.hiddenTextarea.selectionEnd,
                this.hiddenTextarea.value
            );
            var backDelete = selectionStart > textareaSelection.selectionStart;

            if (selection) {
                removedText = this._text.slice(selectionStart, selectionEnd);
                charDiff += selectionEnd - selectionStart;
            } else if (nextCharCount < charCount) {
                if (backDelete) {
                    removedText = this._text.slice(
                        selectionEnd + charDiff,
                        selectionEnd
                    );
                } else {
                    removedText = this._text.slice(
                        selectionStart,
                        selectionStart - charDiff
                    );
                }
            }
            insertedText = nextText.slice(
                textareaSelection.selectionEnd - charDiff,
                textareaSelection.selectionEnd
            );
            if (removedText && removedText.length) {
                if (insertedText.length) {
                    // let's copy some style before deleting.
                    // we want to copy the style before the cursor OR the style at the cursor if selection
                    // is bigger than 0.
                    copiedStyle = this.getSelectionStyles(
                        selectionStart,
                        selectionStart + 1,
                        false
                    );
                    // now duplicate the style one for each inserted text.
                    copiedStyle = insertedText.map(function () {
                        // this return an array of references, but that is fine since we are
                        // copying the style later.
                        return copiedStyle[0];
                    });
                }
                if (selection) {
                    removeFrom = selectionStart;
                    removeTo = selectionEnd;
                } else if (backDelete) {
                    // detect differencies between forwardDelete and backDelete
                    removeFrom = selectionEnd - removedText.length;
                    removeTo = selectionEnd;
                } else {
                    removeFrom = selectionEnd;
                    removeTo = selectionEnd + removedText.length;
                }
                this.removeStyleFromTo(removeFrom, removeTo);
            }
            if (insertedText.length) {
                if (
                    fromPaste &&
                    insertedText.join("") === fabric.copiedText &&
                    !fabric.disableStyleCopyPaste
                ) {
                    this.insertNewStyleBlock(
                        insertedText,
                        selectionStart,
                        fabric.copiedTextStyle
                    );
                } else {
                    if (copiedStyle) {
                        this.insertNewStyleBlock(
                            insertedText,
                            selectionStart,
                            copiedStyle
                        );
                    } else {
                        this.insertNewStyleBlock(insertedText, selectionStart);
                    }
                }
            }
            this.updateFromTextArea();
            this.fire("changed");
            if (this.canvas) {
                this.canvas.fire("text:changed", {target: this});
                this.canvas.requestRenderAll();
            }
        }
    })(fabric.Textbox.prototype.onInput);
    fabric.Textbox.prototype.selectWord = (function (originalSelectWord) {
        return function (...args) {
            if (!args || !args.length) {
                return;
            }
            const selectionIndex = Number(args[0]);
            originalSelectWord.call(this, selectionIndex);
            const isNewLineCharacter = Boolean(this.getSelectedText().split('\n')[0]);
            if (!isNewLineCharacter) {
                this.setSelectionStart(this.selectionStart + 1);
            }
            return this;
        };
    })(fabric.Textbox.prototype.selectWord);
    $window.fabric.Image.prototype.set({
        originX: 'center',
        originY: 'center'
    });
    /*advanced*/
    if (typeof udc_nbd_js_config != 'undefined') {
        Object.assign($window.fabric.Canvas.prototype, {crossOrigin: 'anonymous'});
    }
    $window.fabric.CurvedText.prototype.set({
        originX: 'center',
        originY: 'top'
    });
    fabric.enableGLFiltering = false;
    fabric.PathGroup = {};
    fabric.PathGroup.fromObject = function (object, callback) {
        var originalPaths = object.paths;
        delete object.paths;
        if (typeof originalPaths === 'string') {
            fabric.loadSVGFromURL(originalPaths, function (elements) {
                var pathUrl = originalPaths;
                var group = fabric.util.groupSVGElements(elements, object, pathUrl);
                group.type = 'group';
                object.paths = originalPaths;
                callback(group);
            });
        } else {
            fabric.util.enlivenObjects(originalPaths, function (enlivenedObjects) {
                enlivenedObjects.forEach(function (obj) {
                    obj._removeTransformMatrix();
                });
                var group = new fabric.Group(enlivenedObjects, object);
                group.type = 'group';
                object.paths = originalPaths;
                callback(group);
            });
        }
    };
    /*advanced*/
    if (typeof udc_nbd_js_config == "undefined" && NBDESIGNCONFIG['svg_filter'] != 'no') {
        fabric.Image.prototype._toSVG = function () {
            var svgString = [], imageMarkup = [], strokeSvg,
                x = -this.width / 2, y = -this.height / 2, clipPath = '', imageFilter = '';
            if (this.hasCrop()) {
                var clipPathId = fabric.Object.__uid++;
                svgString.push(
                    '<clipPath id="imageCrop_' + clipPathId + '">\n',
                    '\t<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
                    '</clipPath>\n'
                );
                clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
            }
            if (this.filters.length) {
                var width = this._element.width || this._element.naturalWidth,
                    height = this._element.height || this._element.height;
                if (!!this.origin_url && !angular.isDefined(this.cropped)) {
                    width = this.origin_width;
                    height = this.origin_height;
                }
                var filters = this.filters,
                    d = new Date(),
                    randomId = d.getTime() + Math.floor(Math.random() * 1000),
                    filterId = 'filter_' + randomId,
                    filterCode = '<filter id="' + filterId + '" x="' + (x - this.cropX) + '" y="' + (y - this.cropY) + '" width="' + width + '" height="' + height + '" filterUnits="userSpaceOnUse">';
                filters.forEach(function (filter, index) {
                    var _in;
                    if (index > 0) {
                        var options = JSON.parse(filters[index - 1].jOptions);
                        _in = options.type;
                    }
                    filterCode += buildSvgFilter(filter.jOptions, _in);
                });
                filterCode += '</filter>';
                imageMarkup.push(filterCode);
                imageFilter = ' filter="url(#' + filterId + ')"';
            }
            if (!!this.origin_url && !angular.isDefined(this.cropped)) {
                imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.origin_url,
                    '" x="', x - this.cropX, '" y="', y - this.cropY,
                    '" width="', this.origin_width,
                    '" height="', this.origin_height,
                    '"', clipPath, imageFilter,
                    '></image>\n');
            } else {
                imageMarkup.push('\t<image ', 'COMMON_PARTS', 'xlink:href="', this.getSvgSrc(false),
                    '" x="', x - this.cropX, '" y="', y - this.cropY,
                    '" width="', this._element.width || this._element.naturalWidth,
                    '" height="', this._element.height || this._element.height,
                    '"', clipPath, imageFilter,
                    '></image>\n');
            }
            if (this.stroke || this.strokeDashArray) {
                var origFill = this.fill;
                this.fill = null;
                strokeSvg = [
                    '\t<rect ',
                    'x="', x, '" y="', y,
                    '" width="', this.width, '" height="', this.height,
                    '" style="', this.getSvgStyles(),
                    '"/>\n'
                ];
                this.fill = origFill;
            }
            if (this.paintFirst !== 'fill') {
                svgString = svgString.concat(strokeSvg, imageMarkup);
            } else {
                svgString = svgString.concat(imageMarkup, strokeSvg);
            }
            return svgString;
        };
    }
    fabric.Image.prototype._render = function (ctx) {
        if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {
            this.applyResizeFilters();
        }
        this._stroke(ctx);
        this._renderPaintInOrder(ctx);
    }

    fabric.Canvas.prototype._toObjectMethod = function (methodName, propertiesToInclude) {
        var clipPath = this.clipPath, data = {
            version: fabric.version,
            objects: this._toObjects(methodName, propertiesToInclude),
        };
        if (clipPath) {
            data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);
        }
        fabric.util.object.extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

        fabric.util.populateWithProperties(this, data, propertiesToInclude);
        return {...data, linearGradientAngle: this.linearGradientAngle || 0};
    }

    fabric.StaticCanvas.prototype._renderBackgroundOrOverlay = function (ctx, property) {
        var fill = this[property + 'Color'], object = this[property + 'Image'],
            v = this.viewportTransform, needsVpt = this[property + 'Vpt'];
        if (!fill && !object) {
            return;
        }
        if (fill) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(this.width, 0);
            ctx.lineTo(this.width, this.height);
            ctx.lineTo(0, this.height);
            ctx.closePath();
            ctx.fillStyle = fill.toLive
                ? fill.toLive(ctx, this)
                : fill;
            if (fill && fill.type && fill.type === 'linear' && typeof this.linearGradientAngle !== 'undefined') {
                const {left, top} = this.getCenter();
                ctx.translate(left, top);
                ctx.rotate(Number(this.linearGradientAngle || 0) * (Math.PI / 180));
            }
            ctx.fill();
            ctx.restore();
        }
        if (object) {
            ctx.save();
            if (needsVpt) {
                ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
            }
            object.render(ctx);
            ctx.restore();
        }
    }

    fabric.Object.prototype._renderPaintInOrder = function (ctx) {
        if (this.paintFirst === 'stroke') {
            this._renderStroke(ctx);
            this._renderFill(ctx);
        } else {
            if (this.linearGradientAngle || this.linearGradientAngle === 0) {
                ctx.rotate(Number(this.linearGradientAngle) * Math.PI / 180);
                this._renderFill(ctx);
                ctx.rotate(-(Number(this.linearGradientAngle) * Math.PI / 180));
                this._renderStroke(ctx);
            } else {
                this._renderFill(ctx);
                this._renderStroke(ctx);
            }
        }
    }

    fabric.Rect.prototype._render = function (ctx) {
        const borderRadius = this.get('borderRadius') || {
            radius: 0,
            leftTop: 0,
            rightTop: 0,
            rightBottom: 0,
            leftBottom: 0
        };
        const {leftTop, rightTop, rightBottom, leftBottom} = borderRadius;
        var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
            ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
            w = this.width,
            h = this.height,
            x = -this.width / 2,
            y = -this.height / 2,
            isRounded = rx !== 0 || ry !== 0,
            /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
            k = 1 - 0.5522847498;
        ctx.beginPath();

        ctx.moveTo(x + (leftTop || rx), y);

        ctx.lineTo(x + w - (rightTop || rx), y);
        isRounded && ctx.bezierCurveTo(x + w - k * (rightTop || rx), y, x + w, y + k * (rightTop || ry), x + w, y + (rightTop || ry));

        ctx.lineTo(x + w, y + h - (rightBottom || ry));
        isRounded && ctx.bezierCurveTo(x + w, y + h - k * (rightBottom || ry), x + w - k * (rightBottom || rx), y + h, x + w - (rightBottom || rx), y + h);

        ctx.lineTo(x + (leftBottom || rx), y + h);
        isRounded && ctx.bezierCurveTo(x + k * (leftBottom || rx), y + h, x, y + h - k * (leftBottom || ry), x, y + h - (leftBottom || ry));

        ctx.lineTo(x, y + (leftTop || ry));
        isRounded && ctx.bezierCurveTo(x, y + k * (leftTop || ry), x + k * (leftTop || rx), y, x + (leftTop || rx), y);

        ctx.closePath();

        this._renderPaintInOrder(ctx);
    }

    fabric.Image.prototype._renderFill = function (ctx) {
        function hasBorderRadius(borderRadius = {radius: 0, leftTop: 0, rightTop: 0, rightBottom: 0, leftBottom: 0}) {
            const {radius, leftTop, rightTop, rightBottom, leftBottom} = borderRadius;
            return radius !== 0 || leftTop !== 0 || rightTop !== 0 || rightBottom !== 0 || leftBottom !== 0;
        }

        function drawBorderRadius(ctx, x, y, w, h, r, shadow) {
            ctx.save();
            roundedImage(ctx, x, y, w, h, r);
            if (shadow) {
                ctx.shadowOffsetX = shadow.offsetX; // Sets the shadow offset x, positive number is right
                ctx.shadowOffsetY = shadow.offsetY; // Sets the shadow offset y, positive number is down
                ctx.shadowBlur = shadow.blur; // Sets the shadow blur size
                ctx.shadowColor = shadow.color; // Sets the shadow color
                ctx.fillStyle = 'none';
                ctx.fill();
            }
            ctx.clip();
        }

        function roundedImage(ctx, x, y, width, height, radius = {
            radius: 0,
            leftTop: 0,
            rightTop: 0,
            rightBottom: 0,
            leftBottom: 0
        }) {
            const {radius: r, leftTop, rightTop, rightBottom, leftBottom} = radius;
            ctx.beginPath();
            ctx.moveTo(x + (r || leftTop) * 5, y);
            ctx.lineTo(x + width - (r || rightTop) * 5, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + (r || rightTop) * 5);
            ctx.lineTo(x + width, y + height - (r || rightBottom) * 5);
            ctx.quadraticCurveTo(x + width, y + height, x + width - (r || rightBottom) * 5, y + height);
            ctx.lineTo(x + (r || leftBottom) * 5, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - (r || leftBottom) * 5);
            ctx.lineTo(x, y + (r || leftTop) * 5);
            ctx.quadraticCurveTo(x, y, x + (r || leftTop) * 5, y);
            ctx.closePath();
        }

        function drawImageProp(ctx, img, x, y, w, h, offsetX, offsetY, scaleX, scaleY, crop = {}, radius = {
            radius: 0,
            leftTop: 0,
            rightTop: 0,
            rightBottom: 0,
            leftBottom: 0
        }, shadow) {
            if (arguments.length === 2) {
                x = y = 0;
                w = ctx.canvas.width;
                h = ctx.canvas.height;
            }

            offsetX = typeof offsetX === "number" ? offsetX : 0.5;
            offsetY = typeof offsetY === "number" ? offsetY : 0.5;

            if (offsetX < 0) offsetX = 0;
            if (offsetY < 0) offsetY = 0;
            if (offsetX > 1) offsetX = 1;
            if (offsetY > 1) offsetY = 1;

            var iw = crop.width || img.width,
                ih = crop.height || img.height,
                r = Math.min(w / iw, h / ih),
                nw = iw * r,
                nh = ih * r,
                cx, cy, cw, ch, ar = 1;

            if (nw < w) ar = w / nw;
            if (Math.abs(ar - 1) < 1e-14 && nh < h) ar = h / nh;  // updated
            nw *= ar;
            nh *= ar;

            cw = iw / (nw / w);
            ch = ih / (nh / h);
            cx = (iw - cw) * offsetX;
            cy = (ih - ch) * offsetY;

            if (cx < 0) cx = 0;
            if (cy < 0) cy = 0;
            if (cw > iw) {
                cw = iw;
            }
            if (ch > ih) {
                ch = ih;
            }

            const imageHasBorderRadius = hasBorderRadius(radius);

            if (crop.width || crop.height) {
                if (imageHasBorderRadius) {
                    drawBorderRadius(ctx, x, y, w / scaleX, h / scaleY, radius, shadow);
                }
                ctx.drawImage(img, cx + crop.x, cy + crop.y, cw, ch, x, y, w / scaleX, h / scaleY);
                if (imageHasBorderRadius) {
                    ctx.restore();
                }
            } else {
                if (imageHasBorderRadius) {
                    drawBorderRadius(ctx, x, y, w / scaleX, h / scaleY, radius, shadow);
                }
                ctx.drawImage(img, cx, cy, cw, ch, x, y, w / scaleX, h / scaleY);
                if (imageHasBorderRadius) {
                    ctx.restore();
                }
            }
        }

        const stroke = this.get('strokeImage');
        const radius = this.get('borderRadius') || {radius: 0, leftTop: 0, rightTop: 0, rightBottom: 0, leftBottom: 0};
        const strokeWidth = this.get('strokeWidthImage') || 0;
        const crop = this.get('crop');
        const shadow = this.get('shadow');
        const {scaleX, scaleY} = this.getTotalObjectScaling();
        let elementToDraw = this._element,
            w = this.width, h = this.height,
            x = -w / 2, y = -h / 2;
        if (!strokeWidth) {
            elementToDraw && drawImageProp(ctx, elementToDraw, x, y, w * scaleX, h * scaleY, this.offsetX, this.offsetY, scaleX, scaleY, crop, radius, shadow);
        } else if (elementToDraw && strokeWidth) {
            const canvas1 = document.createElement("canvas");
            const ctx1 = canvas1.getContext("2d");
            const canvas2 = document.createElement("canvas");
            const ctx2 = canvas2.getContext("2d");
            canvas2.width = canvas1.width = this.width + strokeWidth * 2;
            canvas2.height = canvas1.height = this.height + strokeWidth * 2;
            drawImageProp(ctx1, this.getElement(), strokeWidth, strokeWidth, w * scaleX, h * scaleY, this.offsetX, this.offsetY, scaleX, scaleY, crop, radius);
            ctx2.shadowColor = stroke || 'white';
            ctx2.shadowBlur = 2;
            for (let i = 0; i < strokeWidth; i++) {
                ctx2.drawImage(canvas1, 0, 0);
                ctx1.drawImage(canvas2, 0, 0);
                ctx.drawImage(canvas2, x - strokeWidth, y - strokeWidth);
            }
        }
    }
    fabric.Image.prototype.applyFilters = function (filters, callback, reset) {
        filters = filters || this.filters || [];
        filters = filters.filter(function (filter) {
            return filter && !filter.isNeutralState();
        });
        this.set('dirty', true);

        this.removeTexture(this.cacheKey + '_filtered');

        if (filters.length === 0) {
            this._element = this._originalElement;
            this._filteredEl = null;
            this._filterScalingX = 1;
            this._filterScalingY = 1;
            if (typeof callback == 'function') callback();
            return this;
        }

        if (reset) {
            this._element = this._originalElement;
            this._filteredEl = null;
        }

        var imgElement = this._originalElement,
            sourceWidth = imgElement.naturalWidth || imgElement.width,
            sourceHeight = imgElement.naturalHeight || imgElement.height;

        if (this._element === this._originalElement) {
            var canvasEl = fabric.util.createCanvasElement();
            canvasEl.width = sourceWidth;
            canvasEl.height = sourceHeight;
            this._element = canvasEl;
            this._filteredEl = canvasEl;
        } else {
            this._element = this._filteredEl;
            this._filteredEl.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
            this._lastScaleX = 1;
            this._lastScaleY = 1;
        }
        if (!fabric.filterBackend) {
            fabric.filterBackend = fabric.initFilterBackend();
        }
        fabric.filterBackend.applyFilters(
            filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey, callback);
        if (this._originalElement.width !== this._element.width ||
            this._originalElement.height !== this._element.height) {
            this._filterScalingX = this._element.width / this._originalElement.width;
            this._filterScalingY = this._element.height / this._originalElement.height;
        }
        return this;
    };
    fabric.Canvas2dFilterBackend.prototype.applyFilters = async function (filters, sourceElement, sourceWidth, sourceHeight, targetCanvas, cacheKey, callback) {
        var ctx = targetCanvas.getContext('2d');
        ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
        var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
        var pipelineState = {
            sourceWidth: sourceWidth,
            sourceHeight: sourceHeight,
            imageData: imageData,
            originalEl: sourceElement,
            originalImageData: originalImageData,
            canvasEl: targetCanvas,
            ctx: ctx,
            filterBackend: this,
        };
        for (const filter of filters) {
            await filter.applyTo2d(pipelineState);
            if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
                targetCanvas.width = pipelineState.imageData.width;
                targetCanvas.height = pipelineState.imageData.height;
            }
            ctx.putImageData(pipelineState.imageData, 0, 0);
        }
        if (typeof callback == 'function') callback();
        return pipelineState;
    };
    canvas2dBackend = new fabric.Canvas2dFilterBackend();
    try {
        webglBackend = new fabric.WebglFilterBackend();
    } catch (e) {
        console.log(e)
    }
    fabric.filterBackend = canvas2dBackend;
    var filters = fabric.Image.filters,
        createClass = fabric.util.createClass;
    /*advanced*/
    if (typeof udc_nbd_js_config == "undefined" && NBDESIGNCONFIG['svg_filter'] != 'no') {
        filters.CustomFilter = createClass(filters.BaseFilter, {
            type: 'CustomFilter',
            initialize: function (options) {
                this.callSuper('initialize', options);
            },
            jOptions: '',
            mainParameter: 'jOptions',
            applyTo2d: function (options) {
                var imageData = options.imageData,
                    width = imageData.width,
                    height = imageData.height,
                    originUrl = options.canvasEl.toDataURL(),
                    jOptions = this.jOptions;
                var d = new Date(),
                    randomId = d.getTime() + Math.floor(Math.random() * 1000);
                return new Promise(function (resolve, reject) {
                    function buildSvg() {
                        var id = 'filter_' + randomId,
                            svg = '';

                        svg += '<svg version="1.1" width="' + width + '" height="' + height + '"' + ' viewBox="0 0 ' + width + ' ' + height + '" ' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">';
                        svg += '<defs>';
                        svg += '<filter id="' + id + '" x="0" y="0" width="100%" height="100%">';
                        svg += buildSvgFilter(jOptions);
                        svg += '</filter>';
                        svg += '</defs>';
                        svg += '<image xlink:href="' + originUrl + '" x="0" y="0" width="100%" height="100%" filter="url(#' + id + ')"></image>';
                        svg += '</svg>';

                        return svg;
                    }

                    var filterdSvg = buildSvg(),
                        img = new Image();
                    url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(filterdSvg);

                    img.onload = function () {
                        var kanvas = document.createElement("canvas");
                        kanvas.width = width;
                        kanvas.height = height,
                            context = kanvas.getContext('2d');
                        context.drawImage(img, 0, 0, width, height, 0, 0, width, height);

                        options.imageData = context.getImageData(0, 0, width, height);
                        return resolve({status: jOptions});
                    }
                    img.src = url;
                });
            }
        });
        fabric.Image.filters.CustomFilter.fromObject = fabric.Image.filters.BaseFilter.fromObject;
    }
    ;
    /*advanced*/
    if (typeof udc_nbd_js_config != 'undefined') {
        fabric.LimitedTextbox = fabric.util.createClass(fabric.Textbox, {
            // Override `insertChars` method
            updateFromTextArea: function () {
                //            if (this.maxWidth) {
                //                var textWidthUnderCursor = this._getLineWidth(this.ctx, this.get2DCursorLocation().lineIndex);
                //                if (textWidthUnderCursor + this.ctx.measureText(chars).width > this.maxWidth) {
                //                    chars = '\n' + chars;
                //                }
                //            }
                //            if (this.maxLines) {
                //                var newLinesLength = this._wrapText(this.ctx, this.text + chars).length;
                //                if (newLinesLength > this.maxLines) {
                //                    return;
                //                }
                //            }
                // Call parent class method
                this.callSuper('updateFromTextArea');
            }
        });
    }
    if (NBDESIGNCONFIG.nbdesigner_enable_font_to_outlines == 'yes') {
        fabric.Text.prototype._createTextCharSpan = function (_char, styleDecl, left, top) {
            var toFixed = fabric.util.toFixed,
                multipleSpacesRegex = /  +/g;
            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex),
                styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace),
                fillStyles = styleProps ? 'style="' + styleProps + '"' : '',
                dy = styleDecl.deltaY, dySpan = '',
                NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
            if (dy) {
                dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
            }

            var fontName = this.fontFamily,
                fontWeight = this.fontWeight,
                fontStyle = this.fontStyle;

            if (fontWeight == 'bold') {
                if (fontStyle == 'italic') {
                    fontName += '__bi';
                } else {
                    fontName += '__b';
                }
            } else {
                if (fontStyle == 'italic') {
                    fontName += '__i';
                }
            }
            if ($window.outlineFonts[fontName]) {
                var path = $window.outlineFonts[fontName].getPath(fabric.util.string.escapeXml(_char), toFixed(left, NUM_FRACTION_DIGITS), toFixed(top, NUM_FRACTION_DIGITS), this.fontSize)
                pathMarkup = path.toSVG(NUM_FRACTION_DIGITS);

                return pathMarkup;
            } else {
                return [
                    '<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
                    toFixed(top, NUM_FRACTION_DIGITS), '" ', dySpan,
                    fillStyles, '>',
                    fabric.util.string.escapeXml(_char),
                    '</tspan>'
                ].join('');
            }
        };
        fabric.Text.prototype._wrapSVGTextAndBg = function (textAndBg) {
            var noShadow = true;

            if (_.isEmpty($window.outlineFonts)) {
                var textDecoration = this.getSvgTextDecoration(this);
                return [
                    textAndBg.textBgRects.join(''),
                    '\t\t<text xml:space="preserve" ',
                    (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
                    (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
                    (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
                    (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
                    (textDecoration ? 'text-decoration="' + textDecoration + '" ' : ''),
                    'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
                    textAndBg.textSpans.join(''),
                    '</text>\n'
                ];
            } else {
                return [
                    textAndBg.textBgRects.join(''),
                    '\t\t<g ',
                    'style="', this.getSvgStyles(noShadow), '"', this.addPaintOrder(), ' >',
                    textAndBg.textSpans.join(''),
                    '</g>\n'
                ];
            }
        };
    }

    return $window.fabric;
}]);
nbdApp.directive('nbdCanvas', ['FabricWindow', '$timeout', '$rootScope', function (FabricWindow, $timeout, $rootScope) {
    return {
        restrict: "AE",
        scope: {
            stage: '=stage',
            index: '@',
            last: '@'
        },
        link: function (scope, element, attrs) {
            $timeout(function () {
                scope.stage.canvas = new FabricWindow.Canvas('nbd-stage-' + scope.index);
                scope.$emit('canvas:created', scope.index, scope.last);
                element.parent().children().on("contextmenu", function (e) {
                    e.preventDefault();
                    scope.$emit('nbd:contextmenu', e);
                });
            });
        }
    }
}]);
nbdApp.directive('tabs', function () {
    return {
        restrict: "AE",
        link: function (scope, element) {
            element.tabs({
                beforeActivate: function (event) {
                    const id = event.currentTarget.getAttribute('href');
                    if (event.type === "tabsbeforeactivate" && id === "#bgcolorpicker3") {
                        $('.bgImage')[0].style.display = 'block';
                        $('.bgImage')[0].style.visibility = 'visible';
                    } else {
                        $('.bgImage')[0].style.display = 'none';
                    }
                }
            }).removeClass('ui-widget');
        }
    }
});
nbdApp.directive('keypress', ['$window', function ($window) {
    return {
        restrict: "AE",
        link: function (scope, element, attrs) {
            $window.document.addEventListener("keydown", function (e) {
                scope.$emit('nbd:keypress', e);
            }, false);
        }
    }
}]);
nbdApp.directive('ngMouseWheelUp', function () {
    return function (scope, element, attrs) {
        element.bind("DOMMouseScroll mousewheel onmousewheel", function (event) {

            // cross-browser wheel delta
            var event = window.event || event; // old IE support
            var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));

            if (delta > 0) {
                scope.$apply(function () {
                    scope.$eval(attrs.ngMouseWheelUp, {$event: event});
                });

                // for IE
                event.returnValue = false;
                // for Chrome and Firefox
                if (event.preventDefault) {
                    event.preventDefault();
                }

            }
        });
    };
});

class PixabarPhotoFiltersController {
    transparent = false;
    color = null;
    orientation = "all";
    id = null;

    colorMenuActive = false;
    orientationMenuActive = false;

    constructor() {
        this.id = this.guid();
    }

    guid() {
        return Math.random()
            .toString(36)
            .slice(2);
    }

    handleVectorChanged() {
        this.onVectorChanged({$event: this.vector});
    }

    handleTransparentChanged() {
        this.onTransparentChanged({$event: this.transparent});
    }

    handleBlackAndWhiteChanged() {
        this.onBlackAndWhiteChanged({$event: this.blackAndWhite});
    }

    handleOrientationChanged() {
        this.onOrientationChanged({$event: this.orientation});
    }

    handleColorClicked(e) {
        if (this.color === e) {
            this.onColorChanged({$event: null});
            return;
        }
        this.onColorChanged({$event: e});
    }

    handleOrientationMenuStateChanged() {
        if (this.colorMenuActive) {
            this.colorMenuActive = false;
        }
    }

    handleColorMenuStateChanged() {
        if (this.orientationMenuActive) {
            this.orientationMenuActive = false;
        }
    }

}

nbdApp.component('pixabayPhotoFilters', {
    template: `
        <div class="pixabay-photo-filters">
            <p ng-if="$ctrl.showVector">
                <input type="checkbox" id="pixabayVector-{{$ctrl.id}}" ng-model="$ctrl.vector" ng-change="$ctrl.handleVectorChanged()"/>
                <label for="pixabayVector-{{$ctrl.id}}">Vector only</label>
            </p>

            <div class="pixabay-menu">
                <input id="pixabay-menu-1-{{$ctrl.id}}" class="pixabay-menu__checkbox" type="checkbox" name="menu" ng-model="$ctrl.orientationMenuActive" ng-change="$ctrl.handleOrientationMenuStateChanged()" />
                <label for="pixabay-menu-1-{{$ctrl.id}}" class="pixabay-menu__label">Orientation</label>
                <div class="submenu" style="width:115px;">
                    <form>
                        <fieldset>
                            <p>
                                <input id="orientation-all-{{$ctrl.id}}" type="radio" name="orientation" ng-model="$ctrl.orientation" value="all" ng-change="$ctrl.handleOrientationChanged($event)">
                                <label for="orientation-all-{{$ctrl.id}}">All</label>
                            </p>
                            <p>
                                <input id="orientation-horizontal-{{$ctrl.id}}" type="radio" name="orientation" ng-model="$ctrl.orientation" value="horizontal" ng-change="$ctrl.handleOrientationChanged($event)">
                                <label for="orientation-horizontal-{{$ctrl.id}}">Horizontal</label>
                            </p>
                            <p>
                                <input id="orientation-vertical-{{$ctrl.id}}" type="radio" name="orientation" ng-model="$ctrl.orientation" value="vertical" ng-change="$ctrl.handleOrientationChanged($event)">
                                <label for="orientation-vertical-{{$ctrl.id}}">Vertical</label>
                            </p>
                        </fieldset>
                    </form>
                </div>
            </div>
            
            <div class="pixabay-menu">
                <input id="pixabay-menu-2-{{$ctrl.id}}" class="pixabay-menu__checkbox" type="checkbox" name="menu" ng-model="$ctrl.colorMenuActive" ng-change="$ctrl.handleColorMenuStateChanged()" />
                <label for="pixabay-menu-2-{{$ctrl.id}}" class="pixabay-menu__label">Color</label>
                <div class="submenu" style="width:160px;">
                    <form>
                        <fieldset>
                            <p>
                                <input type="checkbox" id="pixabayTransparent-{{$ctrl.id}}" ng-model="$ctrl.transparent" ng-change="$ctrl.handleTransparentChanged()"/>
                                <label for="pixabayTransparent-{{$ctrl.id}}">Transparent</label>
                            </p>
                            <p>
                                <input type="checkbox" id="pixabayBlackAndWhite-{{$ctrl.id}}" ng-model="$ctrl.blackAndWhite" ng-change="$ctrl.handleBlackAndWhiteChanged()"/>
                                <label for="pixabayBlackAndWhite-{{$ctrl.id}}">Black and white</label>
                            </p>
                            <div class="pixabay-colors">
                                <div class="pixabay-color pixabay-color--red" ng-class="{ 'pixabay-color--active': $ctrl.color === 'red' }" ng-class ng-click="$ctrl.handleColorClicked('red')"></div>
                                <div class="pixabay-color pixabay-color--orange" ng-class="{ 'pixabay-color--active': $ctrl.color === 'orange' }" ng-click="$ctrl.handleColorClicked('orange')"></div>
                                <div class="pixabay-color pixabay-color--yellow" ng-class="{ 'pixabay-color--active': $ctrl.color === 'yellow' }" ng-click="$ctrl.handleColorClicked('yellow')"></div>
                                <div class="pixabay-color pixabay-color--green" ng-class="{ 'pixabay-color--active': $ctrl.color === 'green' }" ng-click="$ctrl.handleColorClicked('green')"></div>
                                <div class="pixabay-color pixabay-color--turquoise" ng-class="{ 'pixabay-color--active': $ctrl.color === 'turquoise' }" ng-click="$ctrl.handleColorClicked('turquoise')"></div>
                                <div class="pixabay-color pixabay-color--blue" ng-class="{ 'pixabay-color--active': $ctrl.color === 'blue' }" ng-click="$ctrl.handleColorClicked('blue')"></div>
                                <div class="pixabay-color pixabay-color--lilac" ng-class="{ 'pixabay-color--active': $ctrl.color === 'lilac' }" ng-click="$ctrl.handleColorClicked('lilac')"></div>
                                <div class="pixabay-color pixabay-color--pink" ng-class="{ 'pixabay-color--active': $ctrl.color === 'pink' }" ng-click="$ctrl.handleColorClicked('pink')"></div>
                                <div class="pixabay-color pixabay-color--white" ng-class="{ 'pixabay-color--active': $ctrl.color === 'white' }" ng-click="$ctrl.handleColorClicked('white')"></div>
                                <div class="pixabay-color pixabay-color--gray" ng-class="{ 'pixabay-color--active': $ctrl.color === 'gray' }" ng-click="$ctrl.handleColorClicked('gray')"></div>
                                <div class="pixabay-color pixabay-color--black" ng-class="{ 'pixabay-color--active': $ctrl.color === 'black' }" ng-click="$ctrl.handleColorClicked('black')"></div>
                                <div class="pixabay-color pixabay-color--brown" ng-class="{ 'pixabay-color--active': $ctrl.color === 'brown' }" ng-click="$ctrl.handleColorClicked('brown')"></div>
                            </div>
                        </fieldset>
                    </form>
                </div>
            </div>
        </div>
    `,
    controller: PixabarPhotoFiltersController,
    bindings: {
        showVector: "<",
        vector: "<",
        color: "<",
        orientation: "<",
        blackAndWhite: "<",
        onVectorChanged: "&",
        onColorChanged: "&",
        onTransparentChanged: "&",
        onOrientationChanged: "&",
        onBlackAndWhiteChanged: "&",
    }
});

nbdApp.component('photokitEditor', {
    template: `
        <div ng-if="$ctrl.enabled" style="width:100vw;height:calc(100vh + 20px);position:absolute;top:0;left:0;z-index:10000;padding-left:75px;padding-top:54px;background-color: #ffffff78;">
            <i class="icon-nbd icon-nbd-clear close-popup" ng-click="$ctrl.onClose()" alt="Close Photokit editor" style="position:absolute;right:0;top:54px;font-size:30px;color:white;cursor:pointer;"></i>
            <button ng-click="$ctrl.handleImportToCanvasClicked()" style="position:absolute;left:75px;top:50%;transform:translateY(-50%);border:2px solid #404762; background:white;padding:5px;border-left:none;border-radius: 0 5px 5px 0;">Import into Plasfy</button>
            <iframe id="photokit" src="https://photokit.com/editor/?lang=en" frameborder="no" border="0" scrolling="no" style="width: 100%;height:100%;">
        </div>
    `,
    controller: function () {
        this.$onInit = function () {
            window.addEventListener("message", (event) => {
                if (event.data.type == "photokitsdk" && event.data.name == "editorLoaded") {
                    photokit.contentWindow.postMessage({
                        type: 'photokitsdk',
                        name: 'saveimagetype',
                        savetype: 'postMessage'
                    }, '*');
                    photokit.contentWindow.postMessage({
                        type: 'photokitsdk',
                        name: 'openimage',
                        data: this.imageToOpen,
                        opentype: 0
                    }, '*');
                }
                if (event.data.type == "photokitsdk" && event.data.name == "saveimage") {
                    var imagebase64 = event.data.imagedata;
                    this.onSave({$event: imagebase64});
                }
            });
        }

        this.handleImportToCanvasClicked = function () {
            photokit.contentWindow.postMessage({type: 'photokitsdk', name: 'saveimage'}, '*');
        }
    },
    bindings: {
        enabled: '<',
        imageToOpen: '<',
        onSave: '&',
        onClose: '&'
    }
});


nbdApp.directive('ngMouseWheelDown', function () {
    return function (scope, element, attrs) {
        element.bind("DOMMouseScroll mousewheel onmousewheel", function (event) {

            // cross-browser wheel delta
            var event = window.event || event; // old IE support
            var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));

            if (delta < 0) {
                scope.$apply(function () {
                    scope.$eval(attrs.ngMouseWheelDown, {$event: event});
                });

                // for IE
                event.returnValue = false;
                // for Chrome and Firefox
                if (event.preventDefault) {
                    event.preventDefault();
                }

            }
        });
    };
});
nbdApp.directive('userRoleGuard', [function () {
    return {
        restrict: "A",
        priority: 2,
        scope: false,
        link: function (scope, element, attrs) {
            const id = attrs.pageId || 217;
            const disableClickHandlers = () => {
                element[0].removeAttribute('ng-click');
                attrs.ngClick = null;
                if (attrs.nbdDrag) {
                    element[0].setAttribute('draggable', false);
                    angular.element(element).unbind('dragstart');
                    element[0].addEventListener('dragstart', (e) => {
                        e.preventDefault();
                        scope.$emit('showFeatureLockedPopup', {id, text: attrs.iframeText, level: attrs.level});
                    });
                }
                angular.element(element).unbind('click');
                const watermark = element[0].querySelector('.nbd-pro-mark-wrap')
                if (watermark) {
                    watermark.style.display = 'block';
                }
                element[0].addEventListener('click', () => {
                    scope.$emit('showFeatureLockedPopup', {id, text: attrs.iframeText, level: attrs.level});
                });
                element[0].removeAttribute('user-role-guard');
                element[0].removeAttribute('available-to');
            }
            if (!attrs.userRoleGuard && attrs.availableTo) {
                disableClickHandlers();
                return;
            }
            let availableTo;
            if (attrs.availableTo) {
                availableTo = attrs.availableTo.replace(/\s/g, '').split(",");
            } else {
                element[0].removeAttribute('user-role-guard');
                element[0].removeAttribute('available-to');
                return;
            }
            const roles = attrs.userRoleGuard.split(",");
            const containingRoles = roles
                .reduce((result, role) => {
                    if (availableTo.includes(role)) {
                        result.push(role);
                    }
                    return result;
                }, []);
            if (!containingRoles.length) {
                disableClickHandlers();
            }
            element[0].removeAttribute('user-role-guard');
            element[0].removeAttribute('available-to');
        },
    }
}]);
nbdApp.directive('goldUserRoleGuard', [function () {
    return {
        restrict: "A",
        priority: 2,
        scope: false,
        link: function (scope, element, attrs) {
            const id = attrs.pageId || 7237;
            const disableClickHandlers = () => {
                element[0].removeAttribute('ng-click');
                attrs.ngClick = null;
                if (attrs.nbdDrag) {
                    element[0].setAttribute('draggable', false);
                    angular.element(element).unbind('dragstart');
                    element[0].addEventListener('dragstart', (e) => {
                        e.preventDefault();
                        scope.$emit('showFeatureLockedPopup', {id, text: attrs.iframeText, level: attrs.level});
                    });
                }
                angular.element(element).unbind('click');
                const watermark = element[0].querySelector('.nbd-pro-mark-wrap')
                if (watermark) {
                    watermark.style.display = 'block';
                }
                element[0].addEventListener('click', () => {
                    scope.$emit('showFeatureLockedPopup', {id, text: attrs.iframeText, level: attrs.level});
                });
                element[0].removeAttribute('gold-user-role-guard');
                element[0].removeAttribute('available-to');
            }
            if (!attrs.goldUserRoleGuard && attrs.availableTo) {
                disableClickHandlers();
                return;
            }
            let availableTo;
            const roles = attrs.goldUserRoleGuard.split(",");
            if (attrs.availableTo) {
                availableTo = attrs.availableTo.replace(/\s/g, '').split(",");
            } else {
                if (!roles.includes(SUPER_ROLE_NAME)) {
                    disableClickHandlers();
                }
                return;
            }
            const containingRoles = roles
                .reduce((result, role) => {
                    if (availableTo.includes(role)) {
                        result.push(role);
                    }
                    return result;
                }, []);
            if (!containingRoles.length && !roles.includes(SUPER_ROLE_NAME)) {
                disableClickHandlers();
            }
            element[0].removeAttribute('gold-user-role-guard');
            element[0].removeAttribute('available-to');
        },
    }
}]);
nbdApp.directive('nbdScroll', ['$timeout', function ($timeout) {
    return {
        restrict: "AE",
        scope: {
            container: '@',
            type: '@',
            offset: '@',
            currentType: '@',
            action: '&nbdScroll'
        },
        link: function (scope, element, attrs) {
            $timeout(function () {
                var el = scope.type != 'font' ? jQuery(scope.container + ' .tab-scroll') : jQuery(scope.container),
                    offset = parseInt(scope.offset),
                    elInfo = jQuery(scope.container + ' .info-support');
                el.on('ps-scroll-y', function () {
                    if (scope.type == 'globalTemplate' && angular.isDefined(scope.currentType) && scope.currentType != 'global') return;
                    if (el.prop("clientHeight") != el.prop("scrollHeight") && ((el.prop("scrollTop") + el.prop("clientHeight") - el.prop("scrollHeight") + offset) > 0)) {
                        scope.action({container: scope.container, type: scope.type});
                    }
                    ;
                    if (elInfo.length) {
                        el.prop("scrollTop") > 1500 && elInfo.addClass('slideInDown animated show') || elInfo.removeClass('slideInDown animated show');
                    }
                });
            });
        }
    }
}]);
nbdApp.directive('nbdScrollTemplateTab', ['$timeout', function ($timeout) {
    return {
        restrict: "AE",
        scope: {
            action: '&nbdScrollTemplateTab'
        },
        link: function (scope, element, attrs) {
            $timeout(function () {
                var offset = 30;
                var el = jQuery('#tab-product-template .tab-scroll');
                el.on('ps-scroll-y', function () {
                    if (el.prop("clientHeight") != el.prop("scrollHeight") && ((el.prop("scrollTop") + el.prop("clientHeight") - el.prop("scrollHeight") + offset) > 0)) {
                        scope.action();
                    }
                    ;
                });
            });
        }
    }
}]);
nbdApp.directive('endRepeatColorPicker', ['$timeout', function ($timeout) {
    return {
        restrict: "A",
        link: function (scope, element, attrs) {
            $timeout(function () {
                jQuery(element).nbdColorPalette();
            });
        }
    }
}]);
nbdApp.directive('repeatEnd', [function () {
    return {
        restrict: "AE",
        link: function (scope, element, attrs) {
            if (scope.$last) {
                scope.$eval(attrs.repeatEnd);
            }
        }
    }
}]);
nbdApp.directive('keyup', ['$window', function ($window) {
    return {
        restrict: "AE",
        link: function (scope, element, attrs) {
            $window.document.addEventListener("keyup", function (e) {
                scope.$emit('nbd:keyup', e);
            }, false);
        }
    }
}]);
nbdApp.filter('keyboardShortcut', function ($window) {
    return function (str) {
        if (!str)
            return;
        var keys = str.split('-');
        var isOSX = /Mac OS X/.test($window.navigator.userAgent);
        var seperator = (!isOSX || keys.length > 2) ? '+' : '';
        var abbreviations = {
            M: isOSX ? '⌘' : 'Ctrl',
            A: isOSX ? 'Option' : 'Alt',
            S: 'Shift'
        };
        return keys.map(function (key, index) {
            var last = index == keys.length - 1;
            return last ? key : abbreviations[key];
        }).join(seperator);
    };
});
nbdApp.filter('withoutParentId', function () {
    return function (cats) {
        if (!cats) {
            return false;
        }
        return cats
            .filter((cat) => !cat.parent_id);
    };
});
nbdApp.filter("filterFont", function () {
    return function (fonts, filterFont) {
        var arrFont = [];
        angular.forEach(fonts, function (font, key) {
            var check = [];
            check['limit'] = arrFont.length > (filterFont.perPage * filterFont.currentPage - 1) ? false : true;
            if (!!filterFont.search) {
                check['name'] = font.name.toLowerCase().indexOf(filterFont.search.toLowerCase()) >= 0 ? true : false;
                if (angular.isDefined(font.display_name) && font.display_name != '') {
                    check['name'] = check['name'] || (font.display_name.toLowerCase().indexOf(filterFont.search.toLowerCase()) >= 0 ? true : false);
                }
            } else {
                check['name'] = true;
            }
            ;
            if (check['limit'] && check['name']) arrFont.push(font);
        });
        arrFont = _.sortBy(arrFont, [function (o) {
            return o.name;
        }]);
        return arrFont
    }
});
nbdApp.filter("filterArt", function () {
    return function (arts, filterArt) {
        var arrArt = [];
        arts = _.sortBy(arts, [function (o) {
            return o.name;
        }]);
        angular.forEach(arts, function (art, key) {
            var check = [];
            check['limit'] = true;
            if (!!filterArt.search) {
                check['name'] = art.name.toLowerCase().indexOf(filterArt.search.toLowerCase()) >= 0 ? true : false;
            } else {
                check['name'] = true;
            }
            ;
            check['cat'] = true;
            if (check['limit'] && check['name'] && check['cat']) arrArt.push(art);
        });
        return arrArt
    }
});
nbdApp.filter("filterArtCat", function () {
    return function (arts, filterArt) {
        var arrArt = [];
        arts = _.sortBy(arts, [function (o) {
            return o.name;
        }]);
        angular.forEach(arts, function (art, key) {
            var check = [];
            check['limit'] = true;
            if (!!filterArt.search) {
                check['name'] = art.name.toLowerCase().indexOf(filterArt.search.toLowerCase()) >= 0 ? true : false;
            } else {
                check['name'] = true;
            }
            ;
            check['cat'] = true;
            if (check['limit'] && check['name'] && check['cat']) arrArt.push(art);
        });
        return arrArt
    }
});
nbdApp.filter("filterOverlayCat", function () {
    return function (overlays, filterOverlay) {
        var arrOverlay = [];
        arts = _.sortBy(overlays, [function (o) {
            return o.name;
        }]);
        angular.forEach(overlays, function (overlay, key) {
            var check = [];
            check['limit'] = true;
            if (!!filterOverlay.search) {
                check['name'] = overlay.name.toLowerCase().indexOf(filterOverlay.search.toLowerCase()) >= 0 ? true : false;
            } else {
                check['name'] = true;
            }
            ;
            check['cat'] = true;
            if (check['limit'] && check['name'] && check['cat']) arrOverlay.push(overlay);
        });
        return arrOverlay
    }
});
nbdApp.filter('category', function () {
    const cache = new Map();
    const cacheSizeLimit = 1000;

    return function categoryFilter(items, cat, scope) {
        const cacheKey = JSON.stringify({
            catId: cat.id,
            search: scope.resource.clipart.filter.search,
            currentCatId: scope.resource.clipart.filter.currentCat.id
        });
        if (cache.has(cacheKey)) {
            const value = cache.get(cacheKey);
            cache.delete(cacheKey); // remove old entry
            cache.set(cacheKey, value); // add it back to make it the most recently used
            return value;
        }

        let result;
        if (scope.resource.clipart.filter.search && scope.resource.clipart.filter.currentCat.id) {
            const currentCategory = scope.resource.clipart.filter.currentCat;
            const foldersArray = scope.resource.clipart.data.cat;
            const getChildIds = folder =>
                foldersArray
                    .filter((_folder) => Number(_folder.parent_id) === Number(folder.id));
            const getCategoryChildren = folder => {
                if (getChildIds(folder).length) {
                    return _.flatten(
                        getChildIds(folder)
                            .map((_f) => getCategoryChildren(_f)).concat(folder));
                } else {
                    return [].concat(folder);
                }
                ;
            }
            const categoriesIds = getCategoryChildren(currentCategory)
                .map((category) => Number(category.id));
            result = items.filter((item) => Boolean(categoriesIds.includes(Number(item.cat[0]))));
        } else {
            result = items.filter((item) => item.cat.includes(String(cat.id)));
        }

        // If the cache is full, remove the least recently used item
        if (cache.size >= cacheSizeLimit) {
            const leastRecentlyUsedKey = cache.keys().next().value;
            cache.delete(leastRecentlyUsedKey);
        }

        cache.set(cacheKey, result);
        return result;
    }
})
nbdApp.filter('category2', function () {
    return function categoryFilter(items, cat, scope) {
        if (scope.resource.overlay.filter.search && scope.resource.overlay.filter.currentCat.id) {
            const currentCategory = scope.resource.overlay.filter.currentCat;
            const foldersArray = scope.resource.overlay.data.cat;
            const getChildIds = folder =>
                foldersArray
                    .filter((_folder) => Number(_folder.parent_id) === Number(folder.id));
            const getCategoryChildren = folder => {
                if (getChildIds(folder).length) {
                    return _.flatten(
                        getChildIds(folder)
                            .map((_f) => getCategoryChildren(_f)).concat(folder));
                } else {
                    return [].concat(folder);
                }
                ;
            }
            const categoriesIds = getCategoryChildren(currentCategory)
                .map((category2) => Number(category2.id));
            return items.filter((item) => Boolean(categoriesIds.includes(Number(item.cat[0]))));
        }
        return items.filter((item) => item.cat.includes(String(cat.id)));
    }
});
nbdApp.filter('categoryAll2', function () {
    return function categoryFilter(items, cat, scope) {
        if (scope.resource.overlay_all.filter.search && scope.resource.overlay_all.filter.currentCat.id) {
            const currentCategory = scope.resource.overlay_all.filter.currentCat;
            const foldersArray = scope.resource.overlay_all.data.cat;
            const getChildIds = folder =>
                foldersArray
                    .filter((_folder) => Number(_folder.parent_id) === Number(folder.id));
            const getCategoryChildren = folder => {
                if (getChildIds(folder).length) {
                    return _.flatten(
                        getChildIds(folder)
                            .map((_f) => getCategoryChildren(_f)).concat(folder));
                } else {
                    return [].concat(folder);
                }
                ;
            }
            const categoriesIds = getCategoryChildren(currentCategory)
                .map((category2) => Number(category2.id));
            return items.filter((item) => Boolean(categoriesIds.includes(Number(item.cat[0]))));
        }
        if (!cat) {
            return items;
        }
        return items.filter((item) => item.cat.includes(String(cat.id)));
    }
});
nbdApp.filter('categorySearch2', function () {
    return function categoryFilter(items, category, categories) {

        const getChildIds = folder =>
            categories
                .filter((_folder) => angular.isDefined(folder) && Number(_folder.parent_id) === Number(folder.id));
        const getCategoryChildren = folder => {
            if (getChildIds(folder).length) {
                return _.flatten(
                    getChildIds(folder)
                        .map((_f) => getCategoryChildren(_f)).concat(folder));
            } else {
                return [].concat(folder);
            }
            ;
        }
        const categoriesIds = getCategoryChildren(category)
            .filter((category) => angular.isDefined(category))
            .map((category) => Number(category.id));
        return items.filter((item) => Boolean(categoriesIds.includes(Number(item.cat[0]))));
    }
});
CategoryController2.$inject = ['CONFIG', '$timeout', '$scope', '$element'];

function CategoryController2(CONFIG, $timeout, $scope, $element) {
    var vm = this;
    vm.$onInit = onInit;
    vm.perPage = 25;
    vm.categoryPerPage = 10;
    vm.searchPerPage = 25;
    vm.search = '';

    function onInit() {
        if (vm.categoryId) {
            vm.initialCategoryId = vm.categoryId;
            const category2 = vm.getCategoryById(vm.categoryId);
            if (category2) {
                vm.category = category2;
            }
        }
    }

    vm.onSearchChanged = function () {
        vm.resetPerPage();
        vm.resetCategoryPerPage();
        vm.resetSearchPerPage();
        vm.rebind();
    }

    vm.incrementPerPage = function () {
        vm.perPage += 25;
    }

    vm.incrementCategoryPerPage = function () {
        vm.categoryPerPage += 10;
    }

    vm.incrementSearchPerPage = function () {
        vm.searchPerPage += 25;
    }

    vm.resetPerPage = function () {
        vm.perPage = 25;
    }

    vm.resetCategoryPerPage = function () {
        vm.perPage = 25;
    }

    vm.resetSearchPerPage = function () {
        vm.searchPerPage = 25;
    }

    vm.getCategoryById = function (id) {
        return vm.resource.overlay_all.data.cat.filter((cat) => Number(cat.id) === Number(id))[0]
    }

    vm.detectOverlayAvailability = function (id) {
        let role;
        _.each(CONFIG.overlayRoles, function (value, key) {
            if (Array.isArray(value) && value.includes(id)) {
                role = key;
                return false;
            }
        });
        return role;
    }
    vm.addoverlay = function (overlay, showLoading, hideLoading, e) {
        var stage = $scope.stages[$scope.currentStage],
            btn = e.currentTarget,
            tempUrl = jQuery(btn).attr('data-type-src'),
            jsonData = jQuery.getJSON(tempUrl);
        _canvas = stage['canvas'];
        $scope.showDesignTab();
        jsonData.then(function (data, textStatus, jqxhr) {
            var result = jqxhr.responseJSON;
            $scope.loadOverlaysCustomize(result);
        })
    }

    vm.handleAddOverlay = function (data) {
        const addAsBackground = $element[0].hasAttribute('add-as-background') && $element[0].getAttribute('add-as-background') !== 'false';
        vm.onAddOverlay({...data, $addAsBackground: addAsBackground});
    }
    vm.handleOverlayBackClick = function () {
        if (vm.category.parent_id) {
            $timeout(() => {
                vm.categoryId = vm.category.parent_id;
                vm.category = vm.getCategoryById(vm.category.parent_id);
                vm.resetPerPage();
                vm.resetCategoryPerPage();
                vm.resetSearchPerPage();
                vm.search = '';
                vm.rebind();
            });
        }
    }

    vm.changeCat = function (category) {
        $timeout(() => {
            vm.categoryId = category.id;
            vm.category = vm.getCategoryById(vm.categoryId);
            vm.resetPerPage();
            vm.resetPerPage();
            vm.resetCategoryPerPage();
            vm.resetSearchPerPage();
            vm.rebind();
        })
    }

    vm.rebind = function () {
        $scope.$broadcast('$$rebind::refresh');
    }
}

nbdApp
    .directive('categoryComponent2', function () {
        return {
            restrict: "E",
            controller: CategoryController2,
            controllerAs: 'vm',
            link: function (scope, element) {
                element[0].setAttribute('id', scope.$id);
                scope.$on(
                    "scrollLoadMore",
                    function handleScrollLoadMore(e, id) {
                        if (Number(id) === scope.$id) {
                            scope.vm.incrementCategoryPerPage();
                            scope.vm.incrementPerPage();
                            scope.vm.incrementSearchPerPage();
                            scope.vm.rebind();
                        }
                    }
                );
            },
            scope: {
                resource: '=resource',
                categoryId: '=',
                roles: '@',
                onAddOverlay: '&'
            },
            bindToController: true,
            template: `
                <div style="min-height: 100px;">
                    <div class="nbd-search" style="position: relative; padding: 0;">
                        <input type="text" autocomplete="off" name="search" placeholder="Search results" ng-model="vm.search" ng-change="vm.onSearchChanged()"/>
                        <i class="icon-nbd icon-nbd-fomat-search"></i>
                    </div>
                    <div class="clipart-category clipart-category--back" ng-if="vm.categoryId !== vm.initialCategoryId" style="margin: 10px 0;">
                        <div class="clipart-category__action" ng-click="vm.handleOverlayBackClick()">
                            <i class="icon-nbd icon-nbd-chevron-right rotate180"></i>
                        </div>
                        <div class="clipart-category__name">{{ vm.category.name }}</div>
                    </div>
                    <div ng-if="!vm.search">
                        <div class="clipart-subcategories" style="padding: 0;">
                            <div ng-repeat="subcategory in :refresh:vm.resource.overlay_all.data.cat | subcategory:vm.categoryId | limitTo: vm.categoryPerPage" class="clipart-category__wrapper">
                                <div class="clipart-category">
                                    <div class="clipart-category__name">{{subcategory.name }}</div>
                                    <div class="clipart-category__action" ng-click="vm.changeCat(subcategory)">
                                        <span>View all</span>
                                        <i class="icon-nbd icon-nbd-chevron-right"></i>
                                    </div>
                                </div>
                                <div class="clipart-wrap">
                                    <div class="clipart-item in-view" style="display: inline-block; margin: 5px 0;" ng-init="role = vm.detectOverlayAvailability(overlay.id)" data-type-src="{{overlay.file_url || overlay.file}}" extenal="false" type="svg" ng-repeat="overlay in ::vm.resource.overlay_all.filteredOverlays | categoryOverlayWithSubcategoryContent: subcategory: vm.resource.overlay_all.data.cat: vm.resource.overlay_all.filteredOverlaysCats | limitTo: 3" ng-click="vm.handleAddOverlay(overlay, true, true, $event)" alt="{{overlay.name}}">
                                            <img  ng-src="{{overlay.thumbnail_url || overlay.url}}">
                                            <span class="nbd-pro-mark-wrap" style="display: none;">
                                                <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                                            </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="clipart-wrap" style="height: auto;">
                        <div class="clipart-item in-view" style="display: inline-block;margin: 5px 0;" ng-init="role = vm.detectOverlayAvailability(overlay.id)" data-type-src="{{overlay.file_url || overlay.file}}" extenal="false" type="svg"  ng-repeat="overlay in :refresh:vm.resource.overlay_all.filteredOverlays | categoryAll2: vm.category:vm | limitTo: vm.perPage" ng-click="vm.handleAddOverlay({$overlay: overlay, $showLoading: true, $hideLoading: true, $event: $event})" title="{{overlay.name}}" alt="{{overlay.name}}" user-role-guard="vm.roles" available-to="{{role}}" iframe-text="This overlay" level="{{role}}" ng-if="!vm.search">
                                <img  ng-src="{{overlay.thumbnail_url || overlay.url}}">
                                <span class="nbd-pro-mark-wrap" style="display: none;">
                                    <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                                </span>
                        </div>
                        <div class="clipart-item in-view" style="display: inline-block;margin: 5px 0;" ng-init="role = vm.detectOverlayAvailability(overlay.id)" data-type-src="{{overlay.file_url|| overlay.file}}" extenal="false" type="svg" ng-repeat="overlay in :refresh:filteredResultsInsideCategory = (vm.resource.overlay_all.filteredOverlays | categoryAll2: vm.category:vm | filterArt:vm | limitTo: vm.searchPerPage)"  ng-click="vm.handleAddOverlay({$overlay: overlay, $showLoading: true, $hideLoading: true})" title="{{overlay.name}}" alt="{{overlay.name}}" gold-user-role-guard="vm.roles" available-to="{{role}}" page-id="7237" iframe-text="This Overlay" level="{{role}}" ng-if="vm.search && vm.categoryId !== vm.initialCategoryId">
                            <img  ng-src="{{overlay.thumbnail_url || overlay.url}}">
                            <span class="nbd-pro-mark-wrap" style="display: none;">
                                <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                            </span>
                        </div>
                        <div class="clipart-item in-view" style="display: inline-block;margin: 5px 0;" ng-init="role = vm.detectOverlayAvailability(overlay.id)" data-type-src="{{overlay.file_url || overlay.file}}" extenal="false" type="svg" ng-repeat="overlay in :refresh:filteredResults = (vm.resource.overlay_all.filteredOverlays | filterOverlayCat:vm| categorySearch2: vm.category: vm.resource.overlay_all.data.cat | limitTo: vm.searchPerPage)"  ng-click="vm.handleAddOverlay({$overlay: overlay, $showLoading: true, $hideLoading: true})" title="{{overlay.name}}" alt="{{overlay.name}}" user-role-guard="vm.roles" available-to="{{role}}" page-id="7237" iframe-text="This Overlay" level="{{role}}" ng-if="vm.search && vm.categoryId === vm.initialCategoryId">
                            <img  ng-src="{{overlay.thumbnail_url || overlay.url}}">
                            <span class="nbd-pro-mark-wrap" style="display: none;">
                                <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                            </span>
                        </div>
                        <p style="margin: 20px 0;" ng-if="vm.search && vm.categoryId === vm.initialCategoryId && !filteredResults.length">No results found. Try another search</p>
                        <p style="margin: 20px 0;" ng-if="vm.search && vm.categoryId !== vm.initialCategoryId && !filteredResultsInsideCategory.length">No results found. Try another search</p>
                    </div>
                </div>
                `
        }
    });
nbdApp.filter('categoryAll', function () {
    return function categoryFilter(items, cat, scope) {
        if (scope.resource.clipart_all.filter.search && scope.resource.clipart_all.filter.currentCat.id) {
            const currentCategory = scope.resource.clipart_all.filter.currentCat;
            const foldersArray = scope.resource.clipart_all.data.cat;
            const getChildIds = folder =>
                foldersArray
                    .filter((_folder) => Number(_folder.parent_id) === Number(folder.id));
            const getCategoryChildren = folder => {
                if (getChildIds(folder).length) {
                    return _.flatten(
                        getChildIds(folder)
                            .map((_f) => getCategoryChildren(_f)).concat(folder));
                } else {
                    return [].concat(folder);
                }
                ;
            }
            const categoriesIds = getCategoryChildren(currentCategory)
                .map((category) => Number(category.id));
            return items.filter((item) => Boolean(categoriesIds.includes(Number(item.cat[0]))));
        }
        return items.filter((item) => cat && item.cat.includes(String(cat.id)));
    }
});
nbdApp.filter('categorySearch', function () {
    return function categoryFilter(items, category, categories) {

        const getChildIds = folder =>
            categories
                .filter((_folder) => folder && Number(_folder.parent_id) === Number(folder.id));
        const getCategoryChildren = folder => {
            if (folder && getChildIds(folder).length) {
                return _.flatten(
                    getChildIds(folder)
                        .map((_f) => getCategoryChildren(_f)).concat(folder));
            } else {
                return [].concat(folder);
            }
            ;
        }
        const categoriesIds = getCategoryChildren(category)
            .map((category) => category && Number(category.id));
        return items.filter((item) => Boolean(categoriesIds.includes(Number(item.cat[0]))));
    }
});
nbdApp.filter('categorySearch2', function () {
    return function categoryFilter(items, category, categories) {

        const getChildIds = folder =>
            categories
                .filter((_folder) => angular.isDefined(folder) && Number(_folder.parent_id) === Number(folder.id));
        const getCategoryChildren = folder => {
            if (getChildIds(folder).length) {
                return _.flatten(
                    getChildIds(folder)
                        .map((_f) => getCategoryChildren(_f)).concat(folder));
            } else {
                return [].concat(folder);
            }
            ;
        }
        const categoriesIds = getCategoryChildren(category)
            .filter((category) => angular.isDefined(category))
            .map((category) => Number(category.id));
        return items.filter((item) => Boolean(categoriesIds.includes(Number(item.cat[0]))));
    }
});
CategoryController.$inject = ['CONFIG', '$timeout', '$scope', '$element'];

function CategoryController(CONFIG, $timeout, $scope, $element) {
    var vm = this;
    vm.$onInit = onInit;
    vm.perPage = 25;
    vm.categoryPerPage = 10;
    vm.searchPerPage = 25;
    vm.search = '';

    function onInit() {
        if (vm.categoryId) {
            vm.initialCategoryId = vm.categoryId;
            const category = vm.getCategoryById(vm.categoryId);
            if (category) {
                vm.category = category;
            }
        }
    }

    vm.onSearchChanged = function () {
        vm.resetPerPage();
        vm.resetCategoryPerPage();
        vm.resetSearchPerPage();
        vm.rebind();
    }

    vm.incrementPerPage = function () {
        vm.perPage += 25;
    }

    vm.resetCat3 = function () {
        window.scroll({
            top: document.getElementById('clipart-wrap')?.offsetParent.offsetTop,
            behavior: 'smooth',
            block: 'start',
        })
    }

    vm.resetCat4 = function () {
        window.scroll({
            top: document.getElementById('clipart-wrap')?.offsetParent.offsetTop,
            behavior: 'smooth',
            block: 'start',
        })
    }

    vm.incrementCategoryPerPage = function () {
        vm.categoryPerPage += 10;
    }

    vm.incrementSearchPerPage = function () {
        vm.searchPerPage += 25;
    }

    vm.resetPerPage = function () {
        vm.perPage = 25;
    }

    vm.resetCategoryPerPage = function () {
        vm.searchPerPage = 25;
    }

    vm.resetSearchPerPage = function () {
        vm.perPage = 25;
    }

    vm.getCategoryById = function (id) {
        return vm.resource.clipart_all.data.cat.filter((cat) => Number(cat.id) === Number(id))[0]
    }

    vm.detectClipartAvailability = function (id) {
        let role;
        _.each(CONFIG.clipartRoles, function (value, key) {
            if (Array.isArray(value) && value.includes(id)) {
                role = key;
                return false;
            }
        });
        return role;
    }

    vm.handleClipartBackClick = function () {
        if (vm.category.parent_id) {
            $timeout(() => {
                vm.categoryId = vm.category.parent_id;
                vm.category = vm.getCategoryById(vm.category.parent_id);
                vm.resetPerPage();
                vm.resetCat4();
                vm.resetCategoryPerPage();
                vm.resetSearchPerPage();
                vm.search = '';
                vm.rebind();
                vm.updateActiveVerticalPerfectScrollbars();
            });
        }
    }

    vm.updateActiveVerticalPerfectScrollbars = function () {
        $timeout(() => {
            $('.tab-scroll.ps--active-y').each(function () {
                $(this).perfectScrollbar('destroy');
                $(this).perfectScrollbar();
            });
        });
    }

    vm.changeCat = function (category) {
        $timeout(() => {
            vm.categoryId = category.id;
            vm.category = vm.getCategoryById(vm.categoryId);
            vm.resetPerPage();
            vm.resetCat3();
            vm.resetCategoryPerPage();
            vm.resetSearchPerPage();
            vm.rebind();
            vm.updateActiveVerticalPerfectScrollbars();
        })
    }

    vm.rebind = function () {
        $scope.$broadcast('$$rebind::refresh');
    }

    vm.handleAddArt = function (art) {
        const addAsBackground = $element[0].hasAttribute('add-as-background') && $element[0].getAttribute('add-as-background') !== 'false';
        vm.onAddArt({$art: art, $showLoading: true, $hideLoading: true, $addAsBackground: addAsBackground});
    }
}

nbdApp
    .directive('categoryComponent', function () {
        return {
            restrict: "E",
            controller: CategoryController,
            controllerAs: 'vm',
            link: function (scope, element) {
                element[0].setAttribute('id', scope.$id);
                scope.$on(
                    "scrollLoadMore",
                    function handleScrollLoadMore(e, id) {
                        if (Number(id) === scope.$id) {
                            scope.vm.incrementCategoryPerPage();
                            scope.vm.incrementPerPage();
                            scope.vm.incrementSearchPerPage();
                            scope.vm.rebind();
                        }
                    }
                );
            },
            scope: {
                resource: '=resource',
                categoryId: '=',
                roles: '@',
                onAddArt: '&'
            },
            bindToController: true,
            template: `
                <div style="min-height: 100px;">
                    <div class="nbd-search" style="position: relative; padding: 0;">
                        <input type="text" autocomplete="off" name="search" placeholder="Search results" ng-model="vm.search" ng-change="vm.onSearchChanged()"/>
                        <i class="icon-nbd icon-nbd-fomat-search"></i>
                    </div>
                    <div class="clipart-category clipart-category--back" ng-if="vm.categoryId !== vm.initialCategoryId" style="margin: 10px 0;">
                        <div class="clipart-category__action" ng-click="vm.handleClipartBackClick()">
                            <i class="icon-nbd icon-nbd-chevron-right rotate180"></i>
                        </div>
                        <div class="clipart-category__name">{{ vm.category.name }}</div>
                    </div>
                    <div ng-if="!vm.search">
                        <div class="clipart-subcategories" style="padding: 0;">
                            <div ng-repeat="subcategory in :refresh:vm.resource.clipart_all.data.cat | subcategory:vm.categoryId | limitTo: vm.categoryPerPage" class="clipart-category__wrapper">
                                <div class="clipart-category">
                                    <div class="clipart-category__name">{{subcategory.name }}</div>
                                    <div class="clipart-category__action" ng-click="vm.changeCat(subcategory)">
                                        <span>View all</span>
                                        <i class="icon-nbd icon-nbd-chevron-right"></i>
                                    </div>
                                </div>
                                <div class="clipart-wrap">
                                   <div class="clipart-item in-view" style="display: inline-block; margin: 5px 0;" ng-init="role = vm.detectClipartAvailability(art.id)" nbd-drag="art.url" extenal="false" type="svg"  ng-repeat="art in ::vm.resource.clipart_all.filteredArts | categoryWithSubcategoryContent: subcategory: vm.resource.clipart_all.data.cat: vm.resource.clipart_all.filteredArtsCats | limitTo: 3" ng-click="vm.handleAddArt(art)" alt="{{art.name}}" gold-user-role-guard="{{vm.roles}}" available-to="{{role}}" page-id="7237" iframe-text="Premium Cliparts" level="{{role}}">
                                            <img  ng-src="{{art.thumbnail_url || art.url}}">
                                            <span class="nbd-pro-mark-wrap" style="display: none;">
                                                <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                                            </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="clipart-wrap" style="height: auto;">
                         <div class="clipart-item in-view" style="display: inline-block;margin: 5px 0;" ng-init="role = vm.detectClipartAvailability(art.id)" nbd-drag="art.url" extenal="false" type="svg"  ng-repeat="art in :refresh:vm.resource.clipart_all.filteredArts | categoryAll: vm.category:vm | limitTo: vm.perPage" ng-click="vm.handleAddArt(art)" alt="{{art.name}}" gold-user-role-guard="{{vm.roles}}" available-to="{{role}}" page-id="7237" iframe-text="Premium Cliparts" level="{{role}}" ng-if="!vm.search">
                                <img  ng-src="{{art.thumbnail_url || art.url}}">
                                <span class="nbd-pro-mark-wrap" style="display: none;">
                                    <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                                </span>
                        </div>
                        <div class="clipart-item in-view" style="display: inline-block;margin: 5px 0;" ng-init="role = vm.detectClipartAvailability(art.id)" nbd-drag="art.url" extenal="false" type="svg"  ng-repeat="art in :refresh:filteredResultsInsideCategory = (vm.resource.clipart_all.filteredArts | categoryAll: vm.category:vm | filterArt:vm | limitTo: vm.searchPerPage)"  ng-click="vm.handleAddArt(art)" alt="{{art.name}}" gold-user-role-guard="{{vm.roles}}" available-to="{{role}}" page-id="7237" iframe-text="Premium Cliparts" level="{{role}}" ng-if="vm.search && vm.categoryId !== vm.initialCategoryId">
                            <img  ng-src="{{art.thumbnail_url || art.url}}">
                            <span class="nbd-pro-mark-wrap" style="display: none;">
                                <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                            </span>
                                           </div>
                        <div class="clipart-item in-view" style="display: inline-block;margin: 5px 0;" ng-init="role = vm.detectClipartAvailability(art.id)" nbd-drag="art.url" extenal="false" type="svg"  ng-repeat="art in :refresh:filteredResults = (vm.resource.clipart_all.filteredArts | filterArtCat:vm| categorySearch: vm.category: vm.resource.clipart_all.data.cat | limitTo: vm.searchPerPage)"  ng-click="vm.handleAddArt(art)" alt="{{art.name}}" gold-user-role-guard="{{vm.roles}}" available-to="{{role}}" page-id="7237" iframe-text="Premium Cliparts" level="{{role}}" ng-if="vm.search && vm.categoryId === vm.initialCategoryId">
                            <img  ng-src="{{art.thumbnail_url || art.url}}">
                            <span class="nbd-pro-mark-wrap" style="display: none;">
                                <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                            </span>
                        </div>
                        <p style="margin: 20px 0;" ng-if="vm.search && vm.categoryId === vm.initialCategoryId && !filteredResults.length">No results found. Try another search</p>
                        <p style="margin: 20px 0;" ng-if="vm.search && vm.categoryId !== vm.initialCategoryId && !filteredResultsInsideCategory.length">No results found. Try another search</p>
                    </div>
                </div>
                `
        }
    });
SubcategoryPreviewController.$inject = ['CONFIG', '$filter', '$element'];

function SubcategoryPreviewController(CONFIG, $filter, $element) {
    var vm = this;
    vm.visibleItems = [];
    vm.$onInit = onInit;
    vm.detectClipartAvailability = detectClipartAvailability;
    vm.handleAddArt = handleAddArt;

    function onInit() {
        vm.visibleItems =
            $filter('categoryWithSubcategoryContent')(vm.resource.selectedCategoryItems, vm.subcategory, vm.resource.clipart.data.cat, vm.resource.clipart.filteredArtsCats)
                .slice(0, 3);
    }

    function detectClipartAvailability(id) {
        let role;
        _.each(CONFIG.clipartRoles, function (value, key) {
            if (Array.isArray(value) && value.includes(id)) {
                role = key;
                return false;
            }
        });
        return role;
    }

    function handleAddArt(art) {
        const addAsBackground = $element[0].hasAttribute('add-as-background') && $element[0].getAttribute('add-as-background') !== 'false';
        vm.onAddArt({art, showLoading: true, hideLoading: true, addAsBackground: addAsBackground});
    }
}

nbdApp
    .directive('subcategoryPreviewComponent', function () {
        return {
            restrict: "E",
            controller: SubcategoryPreviewController,
            controllerAs: 'vm',
            scope: {
                resource: '=resource',
                subcategory: '=',
                roles: '@',
                onAddArt: '&',
            },
            bindToController: true,
            template: `
                <div class="clipart-wrap">
                    <div class="clipart-item" ng-init="role = vm.detectClipartAvailability(art.id)" nbd-drag="art.url" extenal="false" type="svg"  ng-repeat="art in vm.visibleItems" ng-click="vm.handleAddArt(art, true, true, $event)" alt="{{art.name}}" gold-user-role-guard="{{vm.roles}}" available-to="{{role}}" iframe-text="Premium Cliparts" level="{{role}}" >
                            <img  ng-src="{{art.thumbnail_url || art.url}}">
                            <span class="nbd-pro-mark-wrap" style="display: none;">
                                <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                            </span>
                    </div>
                </div>
                `
        }
    });
SubcategoryPreviewController2.$inject = ['CONFIG', '$filter', '$element'];

function SubcategoryPreviewController2(CONFIG, $filter, $element) {
    var vm = this;
    vm.visibleItems = [];
    vm.$onInit = onInit;
    vm.detectOverlayAvailability = detectOverlayAvailability;
    vm.handleAddOverlay = handleAddOverlay;

    function onInit() {
        vm.visibleItems =
            $filter('categoryOverlayWithSubcategoryContent')(vm.resource.selectedOverlayCategoryItems, vm.subcategory, vm.resource.overlay.data.cat, vm.resource.overlay.filteredOverlaysCats)
                .slice(0, 3);
    }

    function detectOverlayAvailability(id) {
        let role;
        _.each(CONFIG.overlayRoles, function (value, key) {
            if (Array.isArray(value) && value.includes(id)) {
                role = key;
                return false;
            }
        });
        return role;
    }

    function handleAddOverlay(overlay, showLoading, hideLoading, $event) {
        const addAsBackground = $element[0].hasAttribute('add-as-background') && $element[0].getAttribute('add-as-background') !== 'false';
        vm.onAddOverlay({overlay, showLoading, hideLoading, $event, $addAsBackground: addAsBackground});
    }
}

nbdApp
    .directive('subcategoryPreviewComponent2', function () {
        return {
            restrict: "E",
            controller: SubcategoryPreviewController2,
            controllerAs: 'vm',
            scope: {
                resource: '=resource',
                subcategory: '=',
                roles: '@',
                onAddOverlay: '&',
            },
            bindToController: true,
            template: `
                <div class="overlay-wrap">
                    <div class="overlay-item" ng-init="role = vm.detectOverlayAvailability(overlay.id)" draggable="false" extenal="false" type="svg" ng-repeat="overlay in vm.visibleItems" ng-click="vm.handleAddOverlay(overlay, true, true, $event)" data-type-src="{{overlay.file_url}}" alt="{{overlay.name}}" gold-user-role-guard="{{vm.roles}}" available-to="{{role}}" page-id="7237" iframe-text="This Overlay" level="{{role}}" >
                            <img  ng-src="{{overlay.url}}">
                            <span class="nbd-pro-mark-wrap" style="display: none;">
                                <svg class="nbd-pro-mark" fill="#F3B600" xmlns="http://www.w3.org/2000/svg" viewBox="-505 380 12 10"><path d="M-503 388h8v1h-8zM-494 382.2c-.4 0-.8.3-.8.8 0 .1 0 .2.1.3l-2.3.7-1.5-2.2c.3-.2.5-.5.5-.8 0-.6-.4-1-1-1s-1 .4-1 1c0 .3.2.6.5.8l-1.5 2.2-2.3-.8c0-.1.1-.2.1-.3 0-.4-.3-.8-.8-.8s-.8.4-.8.8.3.8.8.8h.2l.8 3.3h8l.8-3.3h.2c.4 0 .8-.3.8-.8 0-.4-.4-.7-.8-.7z"></path></svg>
                            </span>
                    </div>
                </div>                `
        }
    });
nbdApp.filter('categoryWithSubcategoryContent', function () {
    const cache = new Map();
    const cacheSizeLimit = 1000;

    return function categoryWithSubcategoryContentFilter(items, cat, s, filteredArtsCats) {
        const cacheKey = JSON.stringify({catId: cat.id, sIds: s.map(s => s.id)});
        if (cache.has(cacheKey)) {
            const value = cache.get(cacheKey);
            cache.delete(cacheKey); // remove old entry
            cache.set(cacheKey, value); // add it back to make it the most recently used
            return value;
        }

        const subcategories = s.filter((category) => Number(category.parent_id) === Number(cat.id));

        let result;
        if (subcategories.length < 3) {
            result = items.filter((item) => item.cat.includes(String(cat.id)));
        } else {
            let subcategoriesItems = getSubcategoriesItems(subcategories, filteredArtsCats);

            if (!subcategoriesItems.length) {
                let nestedSubcategories = getNestedSubcategories(subcategories, s);
                subcategoriesItems = getSubcategoriesItems(nestedSubcategories, filteredArtsCats);
            }

            result = subcategoriesItems.length > 2 ? subcategoriesItems : [];
        }

        // If the cache is full, remove the least recently used item
        if (cache.size >= cacheSizeLimit) {
            const leastRecentlyUsedKey = cache.keys().next().value;
            cache.delete(leastRecentlyUsedKey);
        }

        cache.set(cacheKey, result);
        return result;
    }

    function getSubcategoriesItems(subcategories, filteredArtsCats) {
        return subcategories
            .map((subcategory) => filteredArtsCats[subcategory.id] ? filteredArtsCats[subcategory.id][0] : null)
            .filter((item) => !!item);
    }

    function getNestedSubcategories(subcategories, s) {
        return subcategories
            .map((subcategory) => s.find((category) => Number(category.parent_id) === Number(subcategory.id)))
            .filter((item) => !!item);
    }
})
nbdApp.filter('categoryOverlayWithSubcategoryContent', function () {
    return function categoryOverlayWithSubcategoryContentFilter(items, cat, s, filteredOverlaysCats) {
        const subcategories = s
            .filter((category2) => Number(category2.parent_id) === Number(cat.id));
        if (subcategories.length < 3) {
            return items.filter((item) => item.cat.includes(String(cat.id)));
        } else {
            const subcategoriesItems = subcategories
                .map(
                    (subcategory) =>
                        filteredOverlaysCats[subcategory.id] ? filteredOverlaysCats[subcategory.id][0] : null
                ).filter((item) => !!item);
            return subcategoriesItems.length > 2 ? subcategoriesItems : [];
        }
    }
})
nbdApp.filter('subcategory', function () {
    return function (categories, parentId, showSubcategoryContent = false, scope) {
        return categories.filter((category) => category.parent_id && Number(category.parent_id) === Number(parentId));
    }
});
nbdApp.filter('reverse', function () {
    return function (items) {
        return items ? items.slice().reverse() : items;
    };
});
nbdApp.directive("imageOnLoad", [function () {
    return {
        restrict: "A",
        scope: {
            src: '=imageOnLoad'
        },
        link: function (scope, element) {
            var img = new Image();
            img.onload = function () {
                element.removeClass('image-onload');
            };
            img.src = scope.src;
            element.addClass('image-onload');
        }
    };
}]);
nbdApp.directive("fontOnLoad", [function () {
    return {
        restrict: "A",
        scope: {
            font: '=',
            preview: '=',
            loadFontFailAction: '&'
        },
        link: function (scope, element) {
            var fontName = scope.font.alias,
                fontType = scope.font.type;
            if (fontName == '') return;
            var font_id = fontName.replace(/\s/gi, '').toLowerCase();
            if (!jQuery('#' + font_id).length) {
                if (fontType == 'google') {
                    jQuery('head').append('<link id="' + font_id + '" href="https://fonts.googleapis.com/css?family=' + fontName.replace(/\s/gi, '+') + ':400,400i,700,700i" rel="stylesheet" type="text/css">');
                } else {
                    var css = "<style type='text/css' id='" + font_id + "' >";
                    _.each(scope.font.file, function (file, index) {
                        var font_url = file;
                        if (!(file.indexOf("http") > -1)) font_url = NBDESIGNCONFIG['font_url'] + file;
                        css += "@font-face {font-family: '" + fontName + "';";
                        css += "src: ";
                        css += "url('" + font_url + "') format('truetype');";
                        switch (index) {
                            case "r":
                                css += "font-weight: normal;font-style: normal;"
                                break;
                            case "b":
                                css += "font-weight: bold;font-style: normal;"
                                break;
                            case "i":
                                css += "font-weight: normal;font-style: italic;"
                                break;
                            case "bi":
                                css += "font-weight: bold;font-style: italic;"
                                break;
                        }
                        ;
                        css += "}";
                    });
                    css += "</style>";
                    jQuery("head").append(css);
                }
            }
            ;
            var font = new FontFaceObserver(fontName);
            font.load(scope.preview, 3E4).then(function () {
                element.removeClass('font-loading');
            }, function () {
                scope.loadFontFailAction({font: scope.font});
            });
            element.addClass('font-loading');
        }
    }
}]);
nbdApp.directive("nbdUploadFile", ['$timeout', function ($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadFile: '&nbdUploadFile'
        },
        link: function (scope, element) {
            $timeout(function () {
                jQuery(element).on('change', function () {
                    handleFiles(this.files);
                });

                function handleFiles(files) {
                    if (files.length > 0) scope.uploadFile({files: files});
                }
            });
        }
    };
}]);
nbdApp.directive("nbdDndFile", ['$timeout', function ($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadFile: '&nbdDndFile'
        },
        link: function (scope, element) {
            $timeout(function () {
                var dropArea = jQuery(element),
                    Input = dropArea.find('input[type="file"]');
                _.each(['dragenter', 'dragover'], function (eventName, key) {
                    dropArea.on(eventName, highlight)
                });
                _.each(['dragleave', 'drop'], function (eventName, key) {
                    dropArea.on(eventName, unhighlight)
                });

                function highlight(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    dropArea.addClass('highlight');
                };

                function unhighlight(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    dropArea.removeClass('highlight');
                };
                dropArea.on('drop', handleDrop);

                function handleDrop(e) {
                    if (jQuery('#accept-term').length && !jQuery('#accept-term').is(':checked')) {
                        alert(NBDESIGNCONFIG.nbdlangs.alert_upload_term);
                        return;
                    } else {
                        if (e.originalEvent.dataTransfer) {
                            if (e.originalEvent.dataTransfer.files.length) {
                                e.preventDefault();
                                e.stopPropagation();
                                handleFiles(e.originalEvent.dataTransfer.files);
                            }
                        }
                    }
                };
                dropArea.on('click', function (e) {
                    Input.click();
                });
                Input.on('click', function (e) {
                    e.stopPropagation();
                    if (jQuery('#accept-term').length && !jQuery('#accept-term').is(':checked')) {
                        alert(NBDESIGNCONFIG.nbdlangs.alert_upload_term);
                        e.preventDefault();
                        return;
                    }
                });
                Input.on('change', function () {
                    handleFiles(this.files);
                });

                function handleFiles(files) {
                    if (files.length > 0) scope.uploadFile({files: files});
                }
            });
        }
    }
}]);
nbdApp.directive("nbdDropZone", ['$timeout', function ($timeout) {
    return {
        restrict: "A",
        scope: {
            uploadFile: '&nbdDropZone'
        },
        link: function (scope, element) {
            $timeout(function () {
                var dropArea = jQuery('#nbd-stages');
                dropArea.on('drop', handleDrop);

                function handleDrop(e) {
                    if (e.originalEvent.dataTransfer) {
                        if (e.originalEvent.dataTransfer.files.length) {
                            e.preventDefault();
                            e.stopPropagation();
                            handleFiles(e.originalEvent.dataTransfer.files);
                        }
                    }
                };

                function handleFiles(files) {
                    if (files.length > 0) scope.uploadFile({files: files});
                }
            });
        }
    };
}]);
/*advanced*/
if (typeof udc_nbd_js_config != 'undefined') {
    nbdApp.directive("nbdDrag", [function () {
        return {
            restrict: "AE",
            scope: {
                url: '=nbdDrag',
                download: '=nbdDragDownload',
                img: '=nbdImg',
                extenal: '@extenal',
                type: '@type',
                objecttype: '@overlaytype',
                objectfile: '@overlayfile'
            },
            link: function (scope, element, attrs) {
                element.attr("draggable", "true");
                element.on('dragstart', function (event) {
                    event.originalEvent.dataTransfer.setData("src", scope.url);
                    event.originalEvent.dataTransfer.setData("download", scope.download);
                    event.originalEvent.dataTransfer.setData("extenal", scope.extenal);
                    event.originalEvent.dataTransfer.setData("type", scope.type);
                    event.originalEvent.dataTransfer.setData("objecttype", scope.objecttype);
                    event.originalEvent.dataTransfer.setData("objectfile", scope.objectfile);
                    if (angular.isDefined(scope.img) && angular.isDefined(scope.img.origin_url)) {
                        event.originalEvent.dataTransfer.setData("origin_url", scope.img.origin_url);
                        event.originalEvent.dataTransfer.setData("origin_width", scope.img.width);
                        event.originalEvent.dataTransfer.setData("origin_height", scope.img.height);
                    }
                });
            }
        }
    }]);
} else {
    nbdApp.directive("nbdDrag", [function () {
        return {
            restrict: "AE",
            scope: {
                url: '=nbdDrag',
                img: '=nbdImg',
                extenal: '@extenal',
                type: '@type'
            },
            link: function (scope, element, attrs) {
                element.attr("draggable", "true");
                element.on('dragstart', function (event) {
                    event.originalEvent.dataTransfer.setData("src", scope.url);
                    event.originalEvent.dataTransfer.setData("extenal", scope.extenal);
                    event.originalEvent.dataTransfer.setData("type", scope.type);
                    if (angular.isDefined(scope.img) && angular.isDefined(scope.img.origin_url)) {
                        event.originalEvent.dataTransfer.setData("origin_url", scope.img.origin_url);
                        event.originalEvent.dataTransfer.setData("origin_width", scope.img.width);
                        event.originalEvent.dataTransfer.setData("origin_height", scope.img.height);
                    }
                });
            }
        }
    }]);
}
nbdApp.directive("boundingCorner", ['$timeout', function ($timeout) {
    return {
        restrict: "C",
        scope: {
            stage: '@',
            type: '@'
        },
        link: function (scope, element) {
            $timeout(function () {
                if (scope.type != '') {
                    jQuery(element).on('mousedown', function (e) {
                        var targetCanvas = document.querySelector("#stage-container-" + scope.stage + " .upper-canvas");
                        if (targetCanvas) {
                            var evt = document.createEvent("MouseEvents");
                            evt.initMouseEvent("mousedown", true, true, window, 0, e.originalEvent.pageX, e.originalEvent.pageY, e.originalEvent.clientX, e.originalEvent.clientY, false, false, false, false, 0, null);
                            targetCanvas.dispatchEvent(evt);
                        }
                        e.preventDefault();
                        e.stopPropagation();
                    });
                }
            });
        }
    }
}]);
nbdApp.directive('rulerGuideline', ['$timeout', function ($timeout) {
    return {
        restrict: "AE",
        scope: {
            direction: '@rulerGuideline',
            preventClick: '=preventClick',
            offset: '=offset',
            ratio: '@ratio',
            cwidth: '@cwidth'
        },
        link: function (scope, element, attrs) {
            $timeout(function () {
                var el = jQuery(element);
                var stageEl = el.parents('.stage');
                el.on('mousedown', function (event) {
                    stageEl.find('.guide-backdrop').removeClass('nbd-prevent-event');
                    stageEl.on('mousemove.nbd-move-guideline', function (event) {
                        var ratio = parseFloat(scope.ratio);
                        var cwidth = parseFloat(scope.cwidth);
                        var stagePos = stageEl.offset(),
                            top = event.pageY - stagePos.top + stageEl.scrollTop(),
                            left = event.pageX - stagePos.left + stageEl.scrollLeft();
                        top = top <= 40 ? top : (40 + (top - 40) / ratio);
                        var stageElWidth = stageEl.width();
                        var additionalPadding = (cwidth * ratio - stageElWidth) / 2;
                        if (additionalPadding < 0) {
                            left = left > 50 ? (stageElWidth / 2 - (stageElWidth / 2 + 50 - left) / ratio + 50) : left;
                        } else {
                            left = stageElWidth / 2 - (stageElWidth / 2 + 50 + additionalPadding - left) / ratio + 50;
                        }
                        ;
                        scope.offset = scope.direction == 'hor' ? top : left;
                    });
                    event.preventDefault();
                }).on('mouseup', function (event) {
                    stageEl.off('mousemove.nbd-move-guideline');
                    stageEl.find('.guide-backdrop').addClass('nbd-prevent-event');
                });
                stageEl.on('mouseup', function () {
                    stageEl.off('mousemove.nbd-move-guideline');
                    stageEl.find('.guide-backdrop').addClass('nbd-prevent-event');
                });
                el.trigger('mousedown');
            });
        }
    };
}]);
nbdApp.directive("nbdColorPicker", ['$timeout', function ($timeout) {
    return {
        restrict: "C",
        scope: {
            cattr: '@',
            color: '@',
            type: '@'
        },
        link: function (scope, element) {
            jQuery(element).on('click', function () {
                $timeout(function () {
                    jQuery('#nbd-global-color-palette').addClass('show');
                });
                scope.$emit('nbd:picker', scope.cattr, scope.color, scope.type);
            });
        }
    };
}]);
nbdApp.directive("nbdClearStage", function () {
    return {
        restrict: "A",
        link: function (scope, element) {
            jQuery(element).on('click', function () {
                if (NBDESIGNCONFIG.nbdesigner_prevent_delete_template_layer == 'yes' && !(NBDESIGNCONFIG.task == 'create' || (NBDESIGNCONFIG.task == 'edit' && NBDESIGNCONFIG.design_type == 'template'))) return;
                jQuery('.nbd-popup.clear-stage-alert, .v-popup.v-popup-select').nbShowPopup();
            });
        }
    };
});
nbdApp.directive("stageCell", ['$timeout', function ($timeout) {
    return {
        restrict: "E",
        transclude: true,
        template: '<ng-transclude></ng-transclude>'
    };
}]);
nbdApp.directive("stageCellInner", ['$timeout', function ($timeout) {
    return {
        restrict: "A",
        link: function (scope, element) {
            $timeout(function () {
                jQuery(element).on('dragstart', function (e) {
                    from = jQuery(this).attr('data-position');
                    e.originalEvent.dataTransfer.setData('data_position', from);
                    e.originalEvent.dataTransfer.setData('data_active', 1);
                });
                jQuery(element).on('dragover', function (e) {
                    e.preventDefault();

                    var position = jQuery(this).attr('data-position'),
                        next = position * 1 + 1;
                    if (e.originalEvent.pageX > (jQuery(element).offset().left + jQuery(element).width() / 2)) {
                        jQuery('.stage-space[data-position="' + next + '"]').addClass('active');
                        jQuery('.stage-space[data-position="' + position + '"]').removeClass('active');
                        jQuery(element).attr('data-drop-position', next);
                    } else {
                        jQuery('.stage-space[data-position="' + position + '"]').addClass('active');
                        jQuery('.stage-space[data-position="' + next + '"]').removeClass('active');
                        jQuery(element).attr('data-drop-position', position);
                    }
                });
                jQuery(element).on('dragleave', function (e) {
                    var position = jQuery(this).attr('data-position'),
                        next = position * 1 + 1;
                    jQuery('.stage-space[data-position="' + position + '"], .stage-space[data-position="' + next + '"]').removeClass('active');
                    jQuery(element).removeAttr('data-drop-position');
                    jQuery('.stage-space').removeClass('active');
                });
                jQuery(element).on('drop', function (e) {
                    e.preventDefault();
                    jQuery(this).removeClass('active');
                    var from = e.originalEvent.dataTransfer.getData('data_position'),
                        active = e.originalEvent.dataTransfer.getData('data_active'),
                        position = jQuery(this).attr('data-position');
                    if (position != from) {
                        var to = jQuery(this).attr('data-drop-position');
                        if (active == '1') {
                            scope.$emit('stage:move', from * 1, to * 1);
                        }
                    }
                    jQuery(element).removeAttr('data-drop-position');
                    jQuery('.stage-space').removeClass('active');
                });
            });
        }
    }
}]);
nbdApp.directive("stageSpace", ['$timeout', function ($timeout) {
    return {
        restrict: "A",
        link: function (scope, element) {
            $timeout(function () {
                jQuery(element).on('dragenter', function (e) {
                    jQuery(this).addClass('active');
                });
                jQuery(element).on('dragover', function (e) {
                    e.preventDefault();
                    jQuery(this).addClass('active');
                });
                jQuery(element).on('dragleave', function (e) {
                    jQuery(this).removeClass('active');
                });
                jQuery(element).on('drop', function (e) {
                    e.preventDefault();
                    jQuery(this).removeClass('active');
                    var from = e.originalEvent.dataTransfer.getData('data_position'),
                        active = e.originalEvent.dataTransfer.getData('data_active');
                    var to = jQuery(this).attr('data-position');
                    if (active == '1') {
                        scope.$emit('stage:move', from * 1, to * 1);
                    }
                });
            });
        }
    }
}]);
nbdApp.directive("nbdBackground", ['$timeout', function ($timeout) {
    return {
        restrict: "C",
        scope: {
            src: '@src'
        },
        link: function (scope, element) {
            $timeout(function () {
                var img = new Image();
                img.onload = function () {
                    jQuery(element).css({'background-image': 'url(' + scope.src + ')'});
                    jQuery(element).removeClass('loading');
                };
                img.src = scope.src;
            });
        }
    };
}]);
nbdApp.directive("nbdCapture", ['$timeout', function ($timeout) {
    return {
        restrict: "A",
        scope: {
            nbdCapture: '&'
        },
        link: function (scope, element) {
            $timeout(function () {
                jQuery(element).unbind("paste");
                jQuery(element).bind('paste', function (e) {
                    var clipboard = e.originalEvent.clipboardData;
                    if (clipboard) {
                        if (clipboard.items) {
                            var items = clipboard.items;
                            for (var i = 0; i < items.length; ++i) {
                                if (items[i].kind === 'file' && items[i].type.indexOf('image/') !== -1) {
                                    scope.nbdCapture({
                                        file: items[i].getAsFile(),
                                        type: items[i].type
                                    });
                                    return;
                                }
                            }
                        }

                        if (clipboard.files) {
                            var items = clipboard.files;
                            for (var i = 0; i < items.length; ++i) {
                                if (items[i].type.indexOf('image/') !== -1) {
                                    scope.nbdCapture({
                                        file: items[i],
                                        type: items[i].type
                                    });
                                    return;
                                }
                            }
                        }
                    }
                });
            });
        }
    };
}]);
if (NBDESIGNCONFIG.nbdesigner_show_all_template_sides == 'yes') {
    nbdApp.directive("nbdTemplateHover", ['$timeout', function ($timeout) {
        return {
            restrict: "A",
            scope: {
                idTmpl: '@nbdTemplateHover'
            },
            link: function (scope, element) {
                if (!checkMobileDevice()) {
                    $timeout(function () {
                        jQuery(element).tooltipster({
                            content: jQuery('#tooltip_content_' + scope.idTmpl),
                            interactive: true,
                            side: "right",
                            theme: 'tooltipster-template',
                            functionReady: function () {
                                jQuery('#tooltip_content_' + scope.idTmpl).perfectScrollbar('update');
                            }
                        });
                    }, 500);
                }
                ;
            }
        };
    }]);
}
;
nbdApp.directive("contextSubMenu", ['$timeout', '$window', function ($timeout, $window) {
    return {
        restrict: "C",
        link: function (scope, element) {
            jQuery(element).on('mouseenter', function () {
                jQuery('.second-contexts').removeClass('deactive');
                $timeout(function () {
                    var workBenchWidth = $window.innerWidth,
                        workBenchHeight = $window.innerHeight,
                        position = jQuery(element).offset(),
                        subMenu = jQuery(element).find('.second-contexts'),
                        parentWidth = jQuery(element).parent('.contexts').width(),
                        subMenuWidth = subMenu.width(),
                        subMenuHeight = subMenu.height();
                    if (workBenchWidth < (position.left + subMenuWidth + parentWidth + 15)) {
                        subMenu.removeClass('left').addClass('right');
                    } else {
                        subMenu.removeClass('right').addClass('left');
                    }
                    if (workBenchHeight < (position.top + subMenuHeight + 15)) {
                        subMenu.css('bottom', '-40px');
                    } else {
                        subMenu.css('bottom', 'unset');
                    }
                }, 100);
            });
        }
    };
}]);
nbdApp.directive("nbdPopupTrigger", ['$timeout', function ($timeout) {
    return {
        restrict: "A",
        link: function (scope, element) {
            $timeout(function () {
                jQuery(element).on('click', function () {
                    var target = jQuery(this).attr('data-popup');
                    jQuery('.' + target).nbShowPopup();
                });
            });
        }
    };
}]);
nbdApp.directive("nbdPerfectScroll", function ($timeout) {
    return {
        restrict: "A",
        link: function (scope, element) {
            $timeout(function () {
                jQuery(element).perfectScrollbar();
            })
        }
    };
});
nbdApp.directive("nbdPerfectHorizontalScroll", function ($timeout) {
    return {
        restrict: "A",
        link: function (scope, element) {
            $timeout(function () {
                jQuery(element).perfectScrollbar({
                    suppressScrollY: true,
                    useBothWheelAxes: true,
                });
            })
        }
    };
});
nbdApp.directive('convertToNumber', function () {
    return {
        require: 'ngModel',
        link: function (scope, element, attrs, ngModel) {
            ngModel.$parsers.push(function (val) {
                return val != null ? parseInt(val, 10) : null;
            });
            ngModel.$formatters.push(function (val) {
                return val != null ? '' + val : null;
            });
        }
    };
});
nbdApp.directive('photoFrame', function () {
    return {
        restrict: "EA",
        scope: {
            frame: "="
        },
        template: '<div class=\"frame-wrap-inner\" ng-style=\"getFrameStyle()\">' +
            '<div class=\"frame-panel\" ng-repeat=\"panel in framePanel\" ng-style=\"{\'grid-area\': panel + \'/\' + panel + \'/\' + panel + \'/\' + panel}\"></div>' +
            '</div>',
        controller: function ($scope) {
            $scope.framePanel = [];

            function init() {
                var rows = $scope.frame.areas.match(/[^"]+(?=(" ")|"$)/g),
                    panels = [];
                rows.forEach(function (row) {
                    panels = panels.concat(row.split(" "));
                });
                $scope.framePanel = _.uniq(panels);
            }

            init();
            $scope.getFrameStyle = function () {
                var objStyle = {};
                if ($scope.frame.areas != '') {
                    objStyle['grid-template-areas'] = $scope.frame.areas;
                }
                if ($scope.frame.rows != '') {
                    objStyle['grid-template-rows'] = $scope.frame.rows;
                }
                if ($scope.frame.columns != '') {
                    objStyle['grid-template-columns'] = $scope.frame.columns;
                }
                return objStyle;
            };
        }
    }
});
nbdApp.factory('NBDDataFactory', function ($http) {
    return {
        get: function (action, data, callback, progressCallback) {
            var formData = new FormData();
            formData.append("action", action);
            var nonce = action == 'nbd_get_resource' ? NBDESIGNCONFIG['nonce_get'] : NBDESIGNCONFIG['nonce'];
            formData.append("nonce", nonce);
            var isUploadFile = false;
            angular.forEach(data, function (value, key) {
                var keepDefault = ['file', 'design', 'config', 'product', 'upload', 'used_font', 'option', 'preview', 'template_thumb'];
                if (typeof value != 'object' || _.includes(keepDefault, key) || key.indexOf("frame") > -1) {
                    formData.append(key, value);
                } else {
                    var keyName;
                    for (var k in value) {
                        if (value.hasOwnProperty(k)) {
                            keyName = [key, '[', k, ']'].join('');
                            formData.append(keyName, value[k]);
                        }
                    }
                }
                if (key == 'file') isUploadFile = true;
            });
            var config = {
                transformRequest: angular.identity,
                transformResponse: angular.identity,
                headers: {
                    'Content-Type': undefined
                }
            };
            if (isUploadFile) {
                config.uploadEventHandlers = {
                    progress: function (e) {
                        if (e.lengthComputable) {
                            var progressBar = (e.loaded / e.total) * 100;
                            progressCallback(progressBar);
                        }
                    }
                };
            }
            var url = NBDESIGNCONFIG['ajax_url'];
            if (data.type == 'typography' || data.type == 'get_typo') url = appConfig.mediaUrl + '/typo';
            if (data.source == 'media') url = appConfig.mediaUrl + '/template';
            $http.post(url, formData, config).then(
                function (response) {
                    callback(response.data);
                },
                function (response) {
                    console.log(response);
                }
            );
        }
    }
});
nbdApp.filter('html_trusted', ['$sce', function ($sce) {
    return function (text) {
        var div = document.createElement('div');
        text += '';
        div.innerHTML = text;
        return $sce.trustAsHtml(div.textContent);
    };
}]);
nbdApp.filter('range', [function () {
    return function (input, total) {
        total = parseInt(total);
        for (var i = 0; i < total; i++) {
            input.push(i);
        }
        return input;
    };
}]);
/*advanced*/
if (typeof udc_nbd_js_config != "undefined") {
    nbdApp.filter('trusted', ['$sce', function ($sce) {
        return function (url) {
            return $sce.trustAsResourceUrl(url);
        };
    }]);
}
if (NBDESIGNCONFIG['nbdesigner_enable_facebook_photo'] == 'yes' && NBDESIGNCONFIG['fbID'] != '') {
    window.fbAsyncInit = function () {
        FB.init({
            appId: NBDESIGNCONFIG['fbID'],
            status: true,
            cookie: true,
            xfbml: true,
            autoLogAppEvents: true,
            version: 'v5.0'
        });
    };
    (function (d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) {
            return;
        }
        js = d.createElement(s);
        js.id = id;
        js.src = "https://connect.facebook.net/en_US/sdk.js";
        fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
    var nbdOnFBLogin = function () {
        FB.getLoginStatus(function (response) {
            if (response.status === "connected") {
                var uid = response.authResponse.userID;
                var accessToken = response.authResponse.accessToken;
                var scope = angular.element(document.getElementById("designer-controller")).scope();
                scope.getPersonalPhoto('facebook', [uid, accessToken]);
                scope.updateApp();
            }
        });
    };
}
;

function requestFullScreen(element) {
    var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;
    if (requestMethod) {
        requestMethod.call(element);
    } else if (typeof window.ActiveXObject !== "undefined") {
        var wscript = new ActiveXObject("WScript.Shell");
        if (wscript !== null) {
            wscript.SendKeys("{Esc}");
        }
    }
};

function exitFullscreen() {
    var a = document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen || document.exitFullscreen;
    a && a.call(document);
};

function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
};

function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
};
window.addEventListener("message", receiveMessage, false);

function receiveMessage(event) {
    if (event.origin == window.location.origin) {
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        if (event.data == 'change_nbo_options') {
            scope.changePrintingOptions();
        }
        ;
        if (event.data == 'change_nbd_qty' && NBDESIGNCONFIG['ui_mode'] == 1) {
            scope.resource.config.qty = nbd_window.NBDESIGNERPRODUCT.qty;
            scope.updateQtys();
        }
        ;
        if (event.data == 'start_load_3d_model') {
            jQuery('.preview-3d-wrap-inner .preview-3d-wrap-loading').removeClass('hiddden');
        }
        ;
        if (event.data == 'loaded_3d_model') {
            jQuery('.preview-3d-wrap-inner .preview-3d-wrap-loading').addClass('hiddden');
            scope.threeDimensionPreview.modelLoaded = true;
            scope.update3DPreviewTexture();
        }
    }
    ;
};

function pasteImage(e) {
    _stage = $scope.stages[$scope.currentStage];
    _canvas = _stage['canvas'];
    var items = e.clipboardData.items;

    e.preventDefault();
    e.stopPropagation();

    //Loop through files
    for (var i = 0; i < items.length; i++) {
        if (items[i].type.indexOf('image') == -1) continue;
        var file = items[i],
            type = items[i].type;
        var imageData = file.getAsFile();
        var URLobj = window.URL || window.webkitURL;
        var img = new Image();
        img.src = URLobj.createObjectURL(imageData);
        fabric.Image.fromURL(img.src, function (img) {
            // img.doesSnap();
            _canvas.add(img);
            _canvas.renderAll();
        });
    }
}

function nbdPostMessage() {
    nbd_window.postMessage("received", window.location.origin);
};

/* Change variation */
nbd_window.jQuery('input[name="variation_id"]').on('change', function () {
    if (NBDESIGNCONFIG['ui_mode'] == 1 || (NBDESIGNCONFIG['ui_mode'] == 3 && angular.isUndefined(window.nbOption))) {
        if (appConfig.ready) {
            var variation_id = nbd_window.jQuery('input[name="variation_id"]').val();
            if (NBDESIGNCONFIG['variation_id'] == variation_id) return;
            var scope = angular.element(document.getElementById("designer-controller")).scope();
            if (variation_id != '') {
                nbd_window.NBDESIGNERPRODUCT.nbdesigner_unready();
                if (NBDESIGNCONFIG['nbdesigner_hide_button_cart_in_detail_page'] == 'yes') {
                    nbd_window.jQuery('button[type="submit"].single_add_to_cart_button').hide();
                }
            }
            NBDESIGNCONFIG['variation_id'] = variation_id;
            if (variation_id != '') {
                scope.changeVariation();
            }
        }
    }
});
jQuery(document).on('change_nbo_options_without_od_option', function () {
    if (appConfig.ready) {
        if (NBDESIGNCONFIG['ui_mode'] == 3 || NBDESIGNCONFIG['ui_mode'] == 2) {
            if (nbd_window.jQuery('input[name="variation_id"]').length) {
                setTimeout(function () {
                    var variation_id = nbd_window.jQuery('input[name="variation_id"]').val();
                    if (NBDESIGNCONFIG['variation_id'] == variation_id) return;
                    NBDESIGNCONFIG['variation_id'] = variation_id;
                    if (variation_id > 0) {
                        var scope = angular.element(document.getElementById("designer-controller")).scope();
                        scope.changeVariation();
                    }
                });
            }
        }
    }
});
jQuery(document).on('change_nbo_options_with_od_option', function () {
    if (appConfig.ready) {
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        if (NBDESIGNCONFIG['ui_mode'] == 3 || (NBDESIGNCONFIG['ui_mode'] == 2 && scope.settings.nbdesigner_display_product_option == '2')) {
            if (nbd_window.jQuery('input[name="variation_id"]').length) {
                setTimeout(function () {
                    var variation_id = nbd_window.jQuery('input[name="variation_id"]').val();
                    NBDESIGNCONFIG['variation_id'] = variation_id;
                    scope.printingOptionsAvailable = (variation_id > 0) ? true : false;
                });
            } else {
                scope.printingOptionsAvailable = true;
            }
            scope.changePrintingOptions();
        }
    }
});
jQuery(document).on('change_nbo_options', function () {
    if (appConfig.ready) {
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        if (jQuery('input[name="variation_id"]').length) {
            setTimeout(function () {
                scope.printingOptionsAvailable = jQuery('input[name="variation_id"]').val() > 0 ? true : false;
                NBDESIGNCONFIG.variation_id = jQuery('input[name="variation_id"]').val();
            });
        } else {
            scope.printingOptionsAvailable = true;
        }
        scope.updateApp();
    }
});
jQuery(document).on('invalid_nbo_options', function () {
    if (appConfig.ready) {
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        scope.printingOptionsAvailable = false;
        scope.updateApp();
    }
});
jQuery(document).on('change_nbo_extra_od_options', function () {
    if (appConfig.ready) {
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        scope.changeExtraOdOptions();
        scope.updateApp();
    }
});
jQuery(document).on('nbc_enable_share_design', function (e, data) {
    if (appConfig.ready) {
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        scope.resource.shareDesign = true;
        scope.updateApp();
    }
});
jQuery(document).on('nbc_disable_share_design', function (e, data) {
    if (appConfig.ready) {
        var scope = angular.element(document.getElementById("designer-controller")).scope();
        scope.resource.shareDesign = true;
        scope.updateApp();
    }
});
if (NBDESIGNCONFIG['ui_mode'] == 1) {
    nbd_window.jQuery(nbd_window.document).on('change_nbo_extra_od_options', function () {
        if (appConfig.ready) {
            var scope = angular.element(document.getElementById("designer-controller")).scope();
            scope.changeExtraOdOptions();
            scope.updateApp();
        }
    });
    nbd_window.jQuery(nbd_window.document).triggerHandler('trigger_live_chat_from_iframe');
}
;
if (NBDESIGNCONFIG['ui_mode'] == 3) {
    function bootstrapNbdApp() {
        var nbdAppEl = document.getElementById('nbd-vista-app');
        angular.element(function () {
            angular.bootstrap(nbdAppEl, ['nbdApp']);
        });
    };
    if (window.nbOption) {
        jQuery(document).on('initialed_nbo_options', function () {
            bootstrapNbdApp();
        });
    } else {
        jQuery(document).ready(function () {
            bootstrapNbdApp();
        });
    }
}
;

function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
        }
        return arr2;
    } else {
        return Array.from(arr);
    }
}

function createPngDataTable() {
    /* Table of CRCs of all 8-bit messages. */
    var crcTable = new Int32Array(256);
    for (var n = 0; n < 256; n++) {
        var c = n;
        for (var k = 0; k < 8; k++) {
            c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;
        }
        crcTable[n] = c;
    }
    return crcTable;
}

function calcCrc(buf) {
    var c = -1;
    if (!pngDataTable) pngDataTable = createPngDataTable();
    for (var n = 0; n < buf.length; n++) {
        c = pngDataTable[(c ^ buf[n]) & 0xFF] ^ c >>> 8;
    }
    return c ^ -1;
}

var pngDataTable = void 0;

var PNG = 'image/png';
var WEBP = 'image/webp';
var JPEG = 'image/jpeg';

// those are 3 possible signature of the physBlock in base64.
// the pHYs signature block is preceed by the 4 bytes of lenght. The length of
// the block is always 9 bytes. So a phys block has always this signature:
// 0 0 0 9 p H Y s.
// However the data64 encoding aligns we will always find one of those 3 strings.
// this allow us to find this particular occurence of the pHYs block without
// converting from b64 back to string
var b64PhysSignature1 = 'AAlwSFlz';
var b64PhysSignature2 = 'AAAJcEhZ';
var b64PhysSignature3 = 'AAAACXBI';

var _P = 'p'.charCodeAt(0);
var _H = 'H'.charCodeAt(0);
var _Y = 'Y'.charCodeAt(0);
var _S = 's'.charCodeAt(0);

function changeDpiBlob(blob, dpi) {
    // 33 bytes are ok for pngs and jpegs
    // to contain the information.
    var headerChunk = blob.slice(0, 33);
    return new Promise(function (resolve, reject) {
        var fileReader = new FileReader();
        fileReader.onload = function () {
            var dataArray = new Uint8Array(fileReader.result);
            var tail = blob.slice(33);
            var changedArray = changeDpiOnArray(dataArray, dpi, blob.type);
            resolve(new Blob([changedArray, tail], {type: blob.type}));
        };
        fileReader.readAsArrayBuffer(headerChunk);
    });
}

function changeDpiDataUrl(base64Image, dpi) {
    var dataSplitted = base64Image.split(',');
    var format = dataSplitted[0];
    var body = dataSplitted[1];
    var type = void 0;
    var headerLength = void 0;
    var overwritepHYs = false;
    if (format.indexOf(PNG) !== -1) {
        type = PNG;
        var b64Index = detectPhysChunkFromDataUrl(body);
        // 28 bytes in dataUrl are 21bytes, length of phys chunk with everything inside.
        if (b64Index >= 0) {
            headerLength = Math.ceil((b64Index + 28) / 3) * 4;
            overwritepHYs = true;
        } else {
            headerLength = 33 / 3 * 4;
        }
    }
    if (format.indexOf(WEBP) !== -1) {
        type = WEBP;
        var b64Index = detectPhysChunkFromDataUrl(body);
        // 28 bytes in dataUrl are 21bytes, length of phys chunk with everything inside.
        if (b64Index >= 0) {
            headerLength = Math.ceil((b64Index + 28) / 3) * 4;
            overwritepHYs = true;
        } else {
            headerLength = 33 / 3 * 4;
        }
    }
    if (format.indexOf(JPEG) !== -1) {
        type = JPEG;
        headerLength = 18 / 3 * 4;
    }
    // 33 bytes are ok for pngs and jpegs
    // to contain the information.
    var stringHeader = body.substring(0, headerLength);
    var restOfData = body.substring(headerLength);
    var headerBytes = atob(stringHeader);
    var dataArray = new Uint8Array(headerBytes.length);
    for (var i = 0; i < dataArray.length; i++) {
        dataArray[i] = headerBytes.charCodeAt(i);
    }
    var finalArray = changeDpiOnArray(dataArray, dpi, type, overwritepHYs);
    var base64Header = btoa(String.fromCharCode.apply(String, _toConsumableArray(finalArray)));
    return [format, ',', base64Header, restOfData].join('');
}

function detectPhysChunkFromDataUrl(data) {
    var b64index = data.indexOf(b64PhysSignature1);
    if (b64index === -1) {
        b64index = data.indexOf(b64PhysSignature2);
    }
    if (b64index === -1) {
        b64index = data.indexOf(b64PhysSignature3);
    }
    // if b64index === -1 chunk is not found
    return b64index;
}

function searchStartOfPhys(data) {
    var length = data.length - 1;
    // we check from the end since we cut the string in proximity of the header
    // the header is within 21 bytes from the end.
    for (var i = length; i >= 4; i--) {
        if (data[i - 4] === 9 && data[i - 3] === _P && data[i - 2] === _H && data[i - 1] === _Y && data[i] === _S) {
            return i - 3;
        }
    }
}

function changeDpiOnArray(dataArray, dpi, format, overwritepHYs) {
    if (format === JPEG) {
        dataArray[13] = 1; // 1 pixel per inch or 2 pixel per cm
        dataArray[14] = dpi >> 8; // dpiX high byte
        dataArray[15] = dpi & 0xff; // dpiX low byte
        dataArray[16] = dpi >> 8; // dpiY high byte
        dataArray[17] = dpi & 0xff; // dpiY low byte
        return dataArray;
    }
    if (format === PNG || format === WEBP) {
        var physChunk = new Uint8Array(13);
        // chunk header pHYs
        // 9 bytes of data
        // 4 bytes of crc
        // this multiplication is because the standard is dpi per meter.
        dpi *= 39.3701;
        physChunk[0] = _P;
        physChunk[1] = _H;
        physChunk[2] = _Y;
        physChunk[3] = _S;
        physChunk[4] = dpi >>> 24; // dpiX highest byte
        physChunk[5] = dpi >>> 16; // dpiX veryhigh byte
        physChunk[6] = dpi >>> 8; // dpiX high byte
        physChunk[7] = dpi & 0xff; // dpiX low byte
        physChunk[8] = physChunk[4]; // dpiY highest byte
        physChunk[9] = physChunk[5]; // dpiY veryhigh byte
        physChunk[10] = physChunk[6]; // dpiY high byte
        physChunk[11] = physChunk[7]; // dpiY low byte
        physChunk[12] = 1; // dot per meter....

        var crc = calcCrc(physChunk);

        var crcChunk = new Uint8Array(4);
        crcChunk[0] = crc >>> 24;
        crcChunk[1] = crc >>> 16;
        crcChunk[2] = crc >>> 8;
        crcChunk[3] = crc & 0xff;

        if (overwritepHYs) {
            var startingIndex = searchStartOfPhys(dataArray);
            dataArray.set(physChunk, startingIndex);
            dataArray.set(crcChunk, startingIndex + 13);
            return dataArray;
        } else {
            // i need to give back an array of data that is divisible by 3 so that
            // dataurl encoding gives me integers, for luck this chunk is 17 + 4 = 21
            // if it was we could add a text chunk contaning some info, untill desired
            // length is met.

            // chunk structur 4 bytes for length is 9
            var chunkLength = new Uint8Array(4);
            chunkLength[0] = 0;
            chunkLength[1] = 0;
            chunkLength[2] = 0;
            chunkLength[3] = 9;

            var finalHeader = new Uint8Array(54);
            finalHeader.set(dataArray, 0);
            finalHeader.set(chunkLength, 33);
            finalHeader.set(physChunk, 37);
            finalHeader.set(crcChunk, 50);
            return finalHeader;
        }
    }
}

isInView = function (el, target) {
    const gap = 10;
    return target.scrollLeft + el.offsetWidth + gap === el.offsetLeft || el.offsetLeft - 1 === target.scrollLeft;
}
/*advanced*/
if (typeof adc_check_app_modern != "undefined") {
    document.addEventListener("contextmenu", function (e) {
        e.preventDefault()
    });
    $(document).on("dragstart", function () {
        return !1
    });
    jQuery(document).ready(function ($) {
        var w = window.screen.width;
        setTimeout(function () {
            if (w > 768) {
                $('.main-tabs li').removeClass('active').removeClass('tab-first');
                $('.tabs-content .tab').removeClass('active').removeClass('tab-first');
                $('#nav-cliparts').addClass('tab-first').insertBefore('#nav-templates');
                $('.tabs-content #tab-svg').addClass('tab-first').insertBefore('.tabs-content #tab-product-template');
                $('.main-tabs #nav-cliparts').click();
            } else {
                $('#nav-cliparts').insertBefore('#nav-templates');
                $('.tabs-content #tab-svg').insertBefore('.tabs-content #tab-product-template');
            }
        }, 1000);
    });
}


/*advanced*/
if (typeof kvlc_js_cusom != "undefined") {
    jQuery(document).ready(function () {
        var nbMainBar = jQuery(".nbd-main-menu.menu-center"),
            nbMobile = '.nbd-main-menu.menu-center .mobile';
        if (nbMainBar[0] && nbMobile[0]) {
            if (nbMainBar[0].offsetWidth < nbMainBar[0].scrollWidth) {
                jQuery(nbMobile).show();
            } else {
                jQuery(nbMobile).hide();
            }
            jQuery(nbMobile).click(function (e) {
                nbMainBar.toggleClass('active');
            });
            jQuery(document).mouseup(function (e) {

                if (!jQuery(nbMobile).is(e.target) && jQuery(nbMobile).has(e.target).length === 0) {
                    nbMainBar.removeClass('active');
                }
            });
        }
    });
}